(this.webpackJsonp=this.webpackJsonp||[]).push([[6],{Pcni:function(t,e,s){"use strict";s.r(e),s.d(e,"BlockAllocator",(function(){return i})),s.d(e,"Draw",(function(){return a})),s.d(e,"Color",(function(){return n})),s.d(e,"DrawFlags",(function(){return r})),s.d(e,"GrowableStack",(function(){return it})),s.d(e,"Mat22",(function(){return Dt})),s.d(e,"Mat33",(function(){return Ft})),s.d(e,"Rot",(function(){return Lt})),s.d(e,"Sweep",(function(){return Tt})),s.d(e,"Transform",(function(){return Rt})),s.d(e,"Vec2",(function(){return Mt})),s.d(e,"Vec3",(function(){return Gt})),s.d(e,"_pi_over_180",(function(){return nt})),s.d(e,"_180_over_pi",(function(){return ot})),s.d(e,"two_pi",(function(){return rt})),s.d(e,"Abs",(function(){return at})),s.d(e,"Acos",(function(){return At})),s.d(e,"Asin",(function(){return Ct})),s.d(e,"Atan2",(function(){return Vt})),s.d(e,"Cos",(function(){return Bt})),s.d(e,"IsValid",(function(){return ct})),s.d(e,"Pow",(function(){return pt})),s.d(e,"Sin",(function(){return St})),s.d(e,"Sqrt",(function(){return ft})),s.d(e,"Vec2_zero",(function(){return Pt})),s.d(e,"Clamp",(function(){return _t})),s.d(e,"DegToRad",(function(){return yt})),s.d(e,"InvSqrt",(function(){return dt})),s.d(e,"IsPowerOfTwo",(function(){return wt})),s.d(e,"Max",(function(){return lt})),s.d(e,"Min",(function(){return ht})),s.d(e,"NextPowerOfTwo",(function(){return gt})),s.d(e,"RadToDeg",(function(){return xt})),s.d(e,"Random",(function(){return vt})),s.d(e,"RandomRange",(function(){return bt})),s.d(e,"Sq",(function(){return ut})),s.d(e,"Swap",(function(){return mt})),s.d(e,"Version",(function(){return O})),s.d(e,"aabbExtension",(function(){return y})),s.d(e,"aabbMultiplier",(function(){return x})),s.d(e,"angularSleepTolerance",(function(){return X})),s.d(e,"angularSlop",(function(){return S})),s.d(e,"barrierCollisionTime",(function(){return N})),s.d(e,"baumgarte",(function(){return I})),s.d(e,"branch",(function(){return U})),s.d(e,"commit",(function(){return W})),s.d(e,"epsilon",(function(){return m})),s.d(e,"epsilon_sq",(function(){return c})),s.d(e,"invalidParticleIndex",(function(){return D})),s.d(e,"lengthUnitsPerMeter",(function(){return d})),s.d(e,"linearSleepTolerance",(function(){return J})),s.d(e,"linearSlop",(function(){return B})),s.d(e,"maxAngularCorrection",(function(){return w})),s.d(e,"maxFloat",(function(){return _})),s.d(e,"maxLinearCorrection",(function(){return g})),s.d(e,"maxManifoldPoints",(function(){return p})),s.d(e,"maxParticleForce",(function(){return k})),s.d(e,"maxParticleIndex",(function(){return F})),s.d(e,"maxParticlePressure",(function(){return T})),s.d(e,"maxPolygonVertices",(function(){return f})),s.d(e,"maxRotation",(function(){return M})),s.d(e,"maxRotationSquared",(function(){return P})),s.d(e,"maxSubSteps",(function(){return C})),s.d(e,"maxTOIContacts",(function(){return V})),s.d(e,"maxTranslation",(function(){return v})),s.d(e,"maxTranslationSquared",(function(){return b})),s.d(e,"maxTriadDistance",(function(){return q})),s.d(e,"maxTriadDistanceSquared",(function(){return z})),s.d(e,"minParticleSystemBufferCapacity",(function(){return E})),s.d(e,"minParticleWeight",(function(){return R})),s.d(e,"particleStride",(function(){return L})),s.d(e,"pi",(function(){return u})),s.d(e,"polygonRadius",(function(){return A})),s.d(e,"timeToSleep",(function(){return j})),s.d(e,"toiBaumgarte",(function(){return G})),s.d(e,"version",(function(){return Z})),s.d(e,"Alloc",(function(){return tt})),s.d(e,"Assert",(function(){return h})),s.d(e,"Free",(function(){return et})),s.d(e,"Log",(function(){return st})),s.d(e,"MakeArray",(function(){return K})),s.d(e,"MakeNullArray",(function(){return H})),s.d(e,"MakeNumberArray",(function(){return $})),s.d(e,"Maybe",(function(){return l})),s.d(e,"ParseInt",(function(){return Q})),s.d(e,"ParseUInt",(function(){return Y})),s.d(e,"StackAllocator",(function(){return kt})),s.d(e,"Counter",(function(){return zt})),s.d(e,"Timer",(function(){return qt})),s.d(e,"BroadPhase",(function(){return ze})),s.d(e,"Pair",(function(){return qe})),s.d(e,"ChainShape",(function(){return Xe})),s.d(e,"CircleShape",(function(){return Oe})),s.d(e,"CollideCircles",(function(){return We})),s.d(e,"CollidePolygonAndCircle",(function(){return He})),s.d(e,"CollideEdgeAndCircle",(function(){return as})),s.d(e,"CollideEdgeAndPolygon",(function(){return bs})),s.d(e,"CollidePolygons",(function(){return Zs})),s.d(e,"AABB",(function(){return Me})),s.d(e,"ClipVertex",(function(){return we})),s.d(e,"ContactFeature",(function(){return Be})),s.d(e,"ContactID",(function(){return Se})),s.d(e,"Manifold",(function(){return Ce})),s.d(e,"ManifoldPoint",(function(){return Ae})),s.d(e,"RayCastInput",(function(){return ve})),s.d(e,"RayCastOutput",(function(){return be})),s.d(e,"WorldManifold",(function(){return Ve})),s.d(e,"ContactFeatureType",(function(){return pe})),s.d(e,"ManifoldType",(function(){return ye})),s.d(e,"PointState",(function(){return xe})),s.d(e,"ClipSegmentToLine",(function(){return Ie})),s.d(e,"GetPointStates",(function(){return ge})),s.d(e,"TestOverlapAABB",(function(){return Pe})),s.d(e,"TestOverlapShape",(function(){return Le})),s.d(e,"DistanceInput",(function(){return jt})),s.d(e,"DistanceOutput",(function(){return Jt})),s.d(e,"DistanceProxy",(function(){return Et})),s.d(e,"ShapeCastInput",(function(){return Xt})),s.d(e,"ShapeCastOutput",(function(){return Ot})),s.d(e,"Simplex",(function(){return Kt})),s.d(e,"SimplexCache",(function(){return Nt})),s.d(e,"SimplexVertex",(function(){return Yt})),s.d(e,"Distance",(function(){return re})),s.d(e,"gjk_reset",(function(){return Qt})),s.d(e,"ShapeCast",(function(){return fe})),s.d(e,"gjkCalls",(function(){return Zt})),s.d(e,"gjkIters",(function(){return Ut})),s.d(e,"gjkMaxIters",(function(){return Wt})),s.d(e,"DynamicTree",(function(){return ke})),s.d(e,"TreeNode",(function(){return Te})),s.d(e,"EdgeShape",(function(){return Je})),s.d(e,"PolygonShape",(function(){return Us})),s.d(e,"Shape",(function(){return je})),s.d(e,"MassData",(function(){return Ee})),s.d(e,"ShapeType",(function(){return Ne})),s.d(e,"SeparationFunction",(function(){return ui})),s.d(e,"TOIInput",(function(){return li})),s.d(e,"TOIOutput",(function(){return ci})),s.d(e,"SeparationFunctionType",(function(){return mi})),s.d(e,"TOIOutputState",(function(){return _i})),s.d(e,"TimeOfImpact",(function(){return Vi})),s.d(e,"toi_reset",(function(){return ei})),s.d(e,"toiCalls",(function(){return Ys})),s.d(e,"toiIters",(function(){return Ks})),s.d(e,"toiMaxIters",(function(){return Hs})),s.d(e,"toiMaxRootIters",(function(){return ti})),s.d(e,"toiMaxTime",(function(){return Qs})),s.d(e,"toiRootIters",(function(){return $s})),s.d(e,"toiTime",(function(){return Ws})),s.d(e,"AreaJointDef",(function(){return Li})),s.d(e,"AreaJoint",(function(){return Ri})),s.d(e,"Body",(function(){return Ni})),s.d(e,"BodyDef",(function(){return Ei})),s.d(e,"BodyType",(function(){return wi})),s.d(e,"staticBody",(function(){return Qo})),s.d(e,"kinematicBody",(function(){return Yo})),s.d(e,"dynamicBody",(function(){return Ko})),s.d(e,"ChainAndCircleContact",(function(){return Ui})),s.d(e,"ChainAndPolygonContact",(function(){return Wi})),s.d(e,"CircleContact",(function(){return Qi})),s.d(e,"ContactFactory",(function(){return en})),s.d(e,"ContactRegister",(function(){return tn})),s.d(e,"ContactManager",(function(){return ln})),s.d(e,"ContactPositionConstraint",(function(){return Sn})),s.d(e,"ContactSolver",(function(){return Vn})),s.d(e,"ContactSolverDef",(function(){return An})),s.d(e,"ContactVelocityConstraint",(function(){return Bn})),s.d(e,"PositionSolverManifold",(function(){return Cn})),s.d(e,"VelocityConstraintPoint",(function(){return xn})),s.d(e,"blockSolve",(function(){return fn})),s.d(e,"get_g_blockSolve",(function(){return pn})),s.d(e,"set_g_blockSolve",(function(){return yn})),s.d(e,"Contact",(function(){return Zi})),s.d(e,"ContactEdge",(function(){return Oi})),s.d(e,"MixFriction",(function(){return ji})),s.d(e,"MixRestitution",(function(){return Ji})),s.d(e,"MixRestitutionThreshold",(function(){return Xi})),s.d(e,"DistanceJointDef",(function(){return Di})),s.d(e,"DistanceJoint",(function(){return Fi})),s.d(e,"EdgeAndCircleContact",(function(){return Hi})),s.d(e,"EdgeAndPolygonContact",(function(){return $i})),s.d(e,"Filter",(function(){return Ti})),s.d(e,"Fixture",(function(){return zi})),s.d(e,"FixtureDef",(function(){return ki})),s.d(e,"FixtureProxy",(function(){return qi})),s.d(e,"FrictionJointDef",(function(){return gn})),s.d(e,"FrictionJoint",(function(){return wn})),s.d(e,"GearJointDef",(function(){return vn})),s.d(e,"GearJoint",(function(){return bn})),s.d(e,"Island",(function(){return Mn})),s.d(e,"JointDef",(function(){return Mi})),s.d(e,"Joint",(function(){return Gi})),s.d(e,"Jacobian",(function(){return vi})),s.d(e,"JointEdge",(function(){return bi})),s.d(e,"JointType",(function(){return gi})),s.d(e,"AngularStiffness",(function(){return Ii})),s.d(e,"LinearStiffness",(function(){return Pi})),s.d(e,"MotorJointDef",(function(){return Pn})),s.d(e,"MotorJoint",(function(){return In})),s.d(e,"MouseJointDef",(function(){return Gn})),s.d(e,"MouseJoint",(function(){return Dn})),s.d(e,"PolygonAndCircleContact",(function(){return Ki})),s.d(e,"PolygonContact",(function(){return Yi})),s.d(e,"PrismaticJointDef",(function(){return Fn})),s.d(e,"PrismaticJoint",(function(){return Ln})),s.d(e,"PulleyJointDef",(function(){return Tn})),s.d(e,"PulleyJoint",(function(){return kn})),s.d(e,"minPulleyLength",(function(){return Rn})),s.d(e,"RevoluteJointDef",(function(){return qn})),s.d(e,"RevoluteJoint",(function(){return zn})),s.d(e,"Position",(function(){return cn})),s.d(e,"Profile",(function(){return _n})),s.d(e,"SolverData",(function(){return dn})),s.d(e,"TimeStep",(function(){return mn})),s.d(e,"Velocity",(function(){return un})),s.d(e,"WeldJointDef",(function(){return En})),s.d(e,"WeldJoint",(function(){return Nn})),s.d(e,"WheelJointDef",(function(){return jn})),s.d(e,"WheelJoint",(function(){return Jn})),s.d(e,"ContactFilter",(function(){return nn})),s.d(e,"ContactImpulse",(function(){return on})),s.d(e,"ContactListener",(function(){return rn})),s.d(e,"DestructionListener",(function(){return sn})),s.d(e,"QueryCallback",(function(){return an})),s.d(e,"RayCastCallback",(function(){return hn})),s.d(e,"World",(function(){return To})),s.d(e,"RopeDef",(function(){return qo})),s.d(e,"Rope",(function(){return No})),s.d(e,"RopeTuning",(function(){return ko})),s.d(e,"BendingModel",(function(){return Un})),s.d(e,"springAngleBendingModel",(function(){return Ho})),s.d(e,"pbdAngleBendingModel",(function(){return $o})),s.d(e,"xpbdAngleBendingModel",(function(){return tr})),s.d(e,"pbdDistanceBendingModel",(function(){return er})),s.d(e,"pbdHeightBendingModel",(function(){return sr})),s.d(e,"pbdTriangleBendingModel",(function(){return ir})),s.d(e,"StretchingModel",(function(){return Zn})),s.d(e,"pbdStretchingModel",(function(){return nr})),s.d(e,"xpbdStretchingModel",(function(){return or})),s.d(e,"BuoyancyController",(function(){return Xo})),s.d(e,"ConstantAccelController",(function(){return Oo})),s.d(e,"ConstantForceController",(function(){return Zo})),s.d(e,"Controller",(function(){return Jo})),s.d(e,"ControllerEdge",(function(){return jo})),s.d(e,"GravityController",(function(){return Uo})),s.d(e,"TensorDampingController",(function(){return Wo})),s.d(e,"ParticleGroup",(function(){return Hn})),s.d(e,"ParticleGroupDef",(function(){return Kn})),s.d(e,"ParticleGroupFlag",(function(){return On})),s.d(e,"FixtureParticleQueryCallback",(function(){return co})),s.d(e,"GrowableBuffer",(function(){return mo})),s.d(e,"ParticleBodyContact",(function(){return fo})),s.d(e,"ParticleContact",(function(){return uo})),s.d(e,"ParticlePair",(function(){return po})),s.d(e,"ParticlePairSet",(function(){return bo})),s.d(e,"ParticleSystem",(function(){return Bo})),s.d(e,"ParticleSystem_CompositeShape",(function(){return Do})),s.d(e,"ParticleSystem_ConnectionFilter",(function(){return Po})),s.d(e,"ParticleSystemDef",(function(){return xo})),s.d(e,"ParticleSystem_DestroyParticlesInShapeCallback",(function(){return Io})),s.d(e,"ParticleSystem_FixedSetAllocator",(function(){return go})),s.d(e,"ParticleSystem_FixtureParticleSet",(function(){return wo})),s.d(e,"ParticleSystem_InsideBoundsEnumerator",(function(){return Co})),s.d(e,"ParticleSystem_JoinParticleGroupsFilter",(function(){return Go})),s.d(e,"ParticleSystem_ParticleListNode",(function(){return Vo})),s.d(e,"ParticleSystem_Proxy",(function(){return Ao})),s.d(e,"ParticleSystem_ReactiveFilter",(function(){return Fo})),s.d(e,"ParticleSystem_SolveCollisionCallback",(function(){return Ro})),s.d(e,"ParticleSystem_UpdateBodyContactsCallback",(function(){return Lo})),s.d(e,"ParticleSystem_UserOverridableBuffer",(function(){return So})),s.d(e,"ParticleTriad",(function(){return yo})),s.d(e,"ParticleDef",(function(){return Wn})),s.d(e,"ParticleHandle",(function(){return Yn})),s.d(e,"ParticleFlag",(function(){return Xn})),s.d(e,"CalculateParticleIterations",(function(){return Qn})),s.d(e,"StackQueue",(function(){return $n})),s.d(e,"VoronoiDiagram",(function(){return to})),s.d(e,"VoronoiDiagram_Generator",(function(){return eo})),s.d(e,"VoronoiDiagram_Task",(function(){return so}));class i{}class n{constructor(t=.5,e=.5,s=.5,i=1){this.r=t,this.g=e,this.b=s,this.a=i}Clone(){return(new n).Copy(this)}Copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,s,i=this.a){this.SetRGBA(t,e,s,i)}SetByteRGB(t,e,s){return this.r=t/255,this.g=e/255,this.b=s/255,this}SetByteRGBA(t,e,s,i){return this.r=t/255,this.g=e/255,this.b=s/255,this.a=i/255,this}SetRGB(t,e,s){return this.r=t,this.g=e,this.b=s,this}SetRGBA(t,e,s,i){return this.r=t,this.g=e,this.b=s,this.a=i,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,e){n.MixColors(this,t,e)}static MixColors(t,e,s){const i=s*(e.r-t.r),n=s*(e.g-t.g),o=s*(e.b-t.b),r=s*(e.a-t.a);t.r+=i,t.g+=n,t.b+=o,t.a+=r,e.r-=i,e.g-=n,e.b-=o,e.a-=r}MakeStyleString(t=this.a){return n.MakeStyleString(this.r,this.g,this.b,t)}static MakeStyleString(t,e,s,i=1){return t*=255,e*=255,s*=255,i<1?`rgba(${t},${e},${s},${i})`:`rgb(${t},${e},${s})`}}n.ZERO=new n(0,0,0,0),n.RED=new n(1,0,0),n.GREEN=new n(0,1,0),n.BLUE=new n(0,0,1);class o{constructor(...t){if(t[0]instanceof Float32Array){if(4!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:.5,s="number"==typeof t[1]?t[1]:.5,i="number"==typeof t[2]?t[2]:.5,n="number"==typeof t[3]?t[3]:1;this.data=new Float32Array([e,s,i,n])}}get r(){return this.data[0]}set r(t){this.data[0]=t}get g(){return this.data[1]}set g(t){this.data[1]=t}get b(){return this.data[2]}set b(t){this.data[2]=t}get a(){return this.data[3]}set a(t){this.data[3]=t}Clone(){return new o(new Float32Array(this.data))}Copy(t){return t instanceof o?this.data.set(t.data):(this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a),this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}Set(t,e,s,i=this.a){this.SetRGBA(t,e,s,i)}SetByteRGB(t,e,s){return this.r=t/255,this.g=e/255,this.b=s/255,this}SetByteRGBA(t,e,s,i){return this.r=t/255,this.g=e/255,this.b=s/255,this.a=i/255,this}SetRGB(t,e,s){return this.r=t,this.g=e,this.b=s,this}SetRGBA(t,e,s,i){return this.r=t,this.g=e,this.b=s,this.a=i,this}SelfAdd(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Add(t,e){return e.r=this.r+t.r,e.g=this.g+t.g,e.b=this.b+t.b,e.a=this.a+t.a,e}SelfSub(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Sub(t,e){return e.r=this.r-t.r,e.g=this.g-t.g,e.b=this.b-t.b,e.a=this.a-t.a,e}SelfMul(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mul(t,e){return e.r=this.r*t,e.g=this.g*t,e.b=this.b*t,e.a=this.a*t,e}Mix(t,e){n.MixColors(this,t,e)}MakeStyleString(t=this.a){return n.MakeStyleString(this.r,this.g,this.b,t)}}var r;!function(t){t[t.e_none=0]="e_none",t[t.e_shapeBit=1]="e_shapeBit",t[t.e_jointBit=2]="e_jointBit",t[t.e_aabbBit=4]="e_aabbBit",t[t.e_pairBit=8]="e_pairBit",t[t.e_centerOfMassBit=16]="e_centerOfMassBit",t[t.e_particleBit=32]="e_particleBit",t[t.e_particleTriadBit=128]="e_particleTriadBit",t[t.e_controllerBit=64]="e_controllerBit",t[t.e_all=63]="e_all"}(r||(r={}));class a{constructor(){this.m_drawFlags=0}SetFlags(t){this.m_drawFlags=t}GetFlags(){return this.m_drawFlags}AppendFlags(t){this.m_drawFlags|=t}ClearFlags(t){this.m_drawFlags&=~t}}function h(t,...e){if(!t)throw new Error(...e)}function l(t,e){return void 0!==t?t:e}const _=1e37,m=1e-5,c=m*m,u=3.14159265359,d=1,f=8,p=2,y=.1*d,x=4,B=.005*d,S=2/180*u,A=2*B,C=8,V=32,g=.2*d,w=8/180*u,v=2*d,b=v*v,M=.5*u,P=M*M,I=.2,G=.75,D=-1,F=2147483647,L=.75,R=1,T=.25,k=.5,q=2*d,z=q*q,E=256,N=2.5,j=.5,J=.01*d,X=2/180*u;class O{constructor(t=0,e=0,s=0){this.major=0,this.minor=0,this.revision=0,this.major=t,this.minor=e,this.revision=s}toString(){return this.major+"."+this.minor+"."+this.revision}}const Z=new O(2,4,1),U="master",W="9ebbbcd960ad424e03e5de6e66a40764c16f51bc";function Q(t){return parseInt(t,10)}function Y(t){return Math.abs(parseInt(t,10))}function K(t,e){const s=new Array(t);for(let i=0;i<t;++i)s[i]=e(i);return s}function H(t){const e=new Array(t);for(let s=0;s<t;++s)e[s]=null;return e}function $(t,e=0){const s=new Array(t);for(let i=0;i<t;++i)s[i]=e;return s}function tt(t){return null}function et(t){}function st(t,...e){}class it{constructor(t){this.m_stack=[],this.m_count=0,this.m_stack=K(t,t=>null),this.m_count=0}Reset(){return this.m_count=0,this}Push(t){this.m_stack[this.m_count]=t,this.m_count++}Pop(){this.m_count--;const t=this.m_stack[this.m_count];return this.m_stack[this.m_count]=null,t}GetCount(){return this.m_count}}const nt=u/180,ot=180/u,rt=2*u,at=Math.abs;function ht(t,e){return t<e?t:e}function lt(t,e){return t>e?t:e}function _t(t,e,s){return t<e?e:t>s?s:t}function mt(t,e){const s=t[0];t[0]=e[0],e[0]=s}const ct=isFinite;function ut(t){return t*t}function dt(t){return 1/Math.sqrt(t)}const ft=Math.sqrt,pt=Math.pow;function yt(t){return t*nt}function xt(t){return t*ot}const Bt=Math.cos,St=Math.sin,At=Math.acos,Ct=Math.asin,Vt=Math.atan2;function gt(t){return t|=t>>1&2147483647,t|=t>>2&1073741823,t|=t>>4&268435455,t|=t>>8&16777215,(t|=t>>16&65535)+1}function wt(t){return t>0&&0==(t&t-1)}function vt(){return 2*Math.random()-1}function bt(t,e){return(e-t)*Math.random()+t}class Mt{constructor(t=0,e=0){this.x=t,this.y=e}Clone(){return new Mt(this.x,this.y)}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return this.x=t.x,this.y=t.y,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=m){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=m){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),s=Math.sin(t),i=this.x;return this.x=e*i-s*this.y,this.y=s*i+e*this.y,this}SelfRotateCosSin(t,e){const s=this.x;return this.x=t*s-e*this.y,this.y=e*s+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=ht(this.x,t.x),this.y=ht(this.y,t.y),this}SelfMaxV(t){return this.x=lt(this.x,t.x),this.y=lt(this.y,t.y),this}SelfAbs(){return this.x=at(this.x),this.y=at(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}static MakeArray(t){return K(t,t=>new Mt)}static AbsV(t,e){return e.x=at(t.x),e.y=at(t.y),e}static MinV(t,e,s){return s.x=ht(t.x,e.x),s.y=ht(t.y,e.y),s}static MaxV(t,e,s){return s.x=lt(t.x,e.x),s.y=lt(t.y,e.y),s}static ClampV(t,e,s,i){return i.x=_t(t.x,e.x,s.x),i.y=_t(t.y,e.y,s.y),i}static RotateV(t,e,s){const i=t.x,n=t.y,o=Math.cos(e),r=Math.sin(e);return s.x=o*i-r*n,s.y=r*i+o*n,s}static DotVV(t,e){return t.x*e.x+t.y*e.y}static CrossVV(t,e){return t.x*e.y-t.y*e.x}static CrossVS(t,e,s){const i=t.x;return s.x=e*t.y,s.y=-e*i,s}static CrossVOne(t,e){const s=t.x;return e.x=t.y,e.y=-s,e}static CrossSV(t,e,s){const i=e.x;return s.x=-t*e.y,s.y=t*i,s}static CrossOneV(t,e){const s=t.x;return e.x=-t.y,e.y=s,e}static AddVV(t,e,s){return s.x=t.x+e.x,s.y=t.y+e.y,s}static SubVV(t,e,s){return s.x=t.x-e.x,s.y=t.y-e.y,s}static MulSV(t,e,s){return s.x=e.x*t,s.y=e.y*t,s}static MulVS(t,e,s){return s.x=t.x*e,s.y=t.y*e,s}static AddVMulSV(t,e,s,i){return i.x=t.x+e*s.x,i.y=t.y+e*s.y,i}static SubVMulSV(t,e,s,i){return i.x=t.x-e*s.x,i.y=t.y-e*s.y,i}static AddVCrossSV(t,e,s,i){return i.x=t.x-e*s.y,i.y=t.y+e*s.x,i}static MidVV(t,e,s){return s.x=.5*(t.x+e.x),s.y=.5*(t.y+e.y),s}static ExtVV(t,e,s){return s.x=.5*(e.x-t.x),s.y=.5*(e.y-t.y),s}static IsEqualToV(t,e){return t.x===e.x&&t.y===e.y}static DistanceVV(t,e){const s=t.x-e.x,i=t.y-e.y;return Math.sqrt(s*s+i*i)}static DistanceSquaredVV(t,e){const s=t.x-e.x,i=t.y-e.y;return s*s+i*i}static NegV(t,e){return e.x=-t.x,e.y=-t.y,e}}Mt.ZERO=new Mt(0,0),Mt.UNITX=new Mt(1,0),Mt.UNITY=new Mt(0,1),Mt.s_t0=new Mt,Mt.s_t1=new Mt,Mt.s_t2=new Mt,Mt.s_t3=new Mt;const Pt=new Mt(0,0);class It{constructor(...t){if(t[0]instanceof Float32Array){if(2!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,s="number"==typeof t[1]?t[1]:0;this.data=new Float32Array([e,s])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}Clone(){return new It(new Float32Array(this.data))}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return t instanceof It?this.data.set(t.data):(this.x=t.x,this.y=t.y),this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this}SelfAddXY(t,e){return this.x+=t,this.y+=e,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this}SelfSubXY(t,e){return this.x-=t,this.y-=e,this}SelfMul(t){return this.x*=t,this.y*=t,this}SelfMulAdd(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SelfMulSub(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}LengthSquared(){const t=this.x,e=this.y;return t*t+e*e}Normalize(){const t=this.Length();if(t>=m){const e=1/t;this.x*=e,this.y*=e}return t}SelfNormalize(){const t=this.Length();if(t>=m){const e=1/t;this.x*=e,this.y*=e}return this}SelfRotate(t){const e=Math.cos(t),s=Math.sin(t),i=this.x;return this.x=e*i-s*this.y,this.y=s*i+e*this.y,this}SelfRotateCosSin(t,e){const s=this.x;return this.x=t*s-e*this.y,this.y=e*s+t*this.y,this}IsValid(){return isFinite(this.x)&&isFinite(this.y)}SelfCrossVS(t){const e=this.x;return this.x=t*this.y,this.y=-t*e,this}SelfCrossSV(t){const e=this.x;return this.x=-t*this.y,this.y=t*e,this}SelfMinV(t){return this.x=ht(this.x,t.x),this.y=ht(this.y,t.y),this}SelfMaxV(t){return this.x=lt(this.x,t.x),this.y=lt(this.y,t.y),this}SelfAbs(){return this.x=at(this.x),this.y=at(this.y),this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this}SelfSkew(){const t=this.x;return this.x=-this.y,this.y=t,this}}class Gt{constructor(...t){if(t[0]instanceof Float32Array){if(3!==t[0].length)throw new Error;this.data=t[0]}else{const e="number"==typeof t[0]?t[0]:0,s="number"==typeof t[1]?t[1]:0,i="number"==typeof t[2]?t[2]:0;this.data=new Float32Array([e,s,i])}}get x(){return this.data[0]}set x(t){this.data[0]=t}get y(){return this.data[1]}set y(t){this.data[1]=t}get z(){return this.data[2]}set z(t){this.data[2]=t}Clone(){return new Gt(this.x,this.y,this.z)}SetZero(){return this.x=0,this.y=0,this.z=0,this}SetXYZ(t,e,s){return this.x=t,this.y=e,this.z=s,this}Copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}SelfNeg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}SelfAdd(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}SelfAddXYZ(t,e,s){return this.x+=t,this.y+=e,this.z+=s,this}SelfSub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}SelfSubXYZ(t,e,s){return this.x-=t,this.y-=e,this.z-=s,this}SelfMul(t){return this.x*=t,this.y*=t,this.z*=t,this}static DotV3V3(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static CrossV3V3(t,e,s){const i=t.x,n=t.y,o=t.z,r=e.x,a=e.y,h=e.z;return s.x=n*h-o*a,s.y=o*r-i*h,s.z=i*a-n*r,s}}Gt.ZERO=new Gt(0,0,0),Gt.s_t0=new Gt;class Dt{constructor(){this.ex=new Mt(1,0),this.ey=new Mt(0,1)}Clone(){return(new Dt).Copy(this)}static FromVV(t,e){return(new Dt).SetVV(t,e)}static FromSSSS(t,e,s,i){return(new Dt).SetSSSS(t,e,s,i)}static FromAngle(t){return(new Dt).SetAngle(t)}SetSSSS(t,e,s,i){return this.ex.Set(t,s),this.ey.Set(e,i),this}SetVV(t,e){return this.ex.Copy(t),this.ey.Copy(e),this}SetAngle(t){const e=Math.cos(t),s=Math.sin(t);return this.ex.Set(e,s),this.ey.Set(-s,e),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this}SetIdentity(){return this.ex.Set(1,0),this.ey.Set(0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this}GetAngle(){return Math.atan2(this.ex.y,this.ex.x)}GetInverse(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,n=this.ey.y;let o=e*n-s*i;return 0!==o&&(o=1/o),t.ex.x=o*n,t.ey.x=-o*s,t.ex.y=-o*i,t.ey.y=o*e,t}Solve(t,e,s){const i=this.ex.x,n=this.ey.x,o=this.ex.y,r=this.ey.y;let a=i*r-n*o;return 0!==a&&(a=1/a),s.x=a*(r*t-n*e),s.y=a*(i*e-o*t),s}SelfAbs(){return this.ex.SelfAbs(),this.ey.SelfAbs(),this}SelfInv(){return this.GetInverse(this),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this}SelfSubM(t){return this.ex.SelfSub(t.ex),this.ey.SelfSub(t.ey),this}static AbsM(t,e){const s=t.ex,i=t.ey;return e.ex.x=at(s.x),e.ex.y=at(s.y),e.ey.x=at(i.x),e.ey.y=at(i.y),e}static MulMV(t,e,s){const i=t.ex,n=t.ey,o=e.x,r=e.y;return s.x=i.x*o+n.x*r,s.y=i.y*o+n.y*r,s}static MulTMV(t,e,s){const i=t.ex,n=t.ey,o=e.x,r=e.y;return s.x=i.x*o+i.y*r,s.y=n.x*o+n.y*r,s}static AddMM(t,e,s){const i=t.ex,n=t.ey,o=e.ex,r=e.ey;return s.ex.x=i.x+o.x,s.ex.y=i.y+o.y,s.ey.x=n.x+r.x,s.ey.y=n.y+r.y,s}static MulMM(t,e,s){const i=t.ex.x,n=t.ex.y,o=t.ey.x,r=t.ey.y,a=e.ex.x,h=e.ex.y,l=e.ey.x,_=e.ey.y;return s.ex.x=i*a+o*h,s.ex.y=n*a+r*h,s.ey.x=i*l+o*_,s.ey.y=n*l+r*_,s}static MulTMM(t,e,s){const i=t.ex.x,n=t.ex.y,o=t.ey.x,r=t.ey.y,a=e.ex.x,h=e.ex.y,l=e.ey.x,_=e.ey.y;return s.ex.x=i*a+n*h,s.ex.y=o*a+r*h,s.ey.x=i*l+n*_,s.ey.y=o*l+r*_,s}}Dt.IDENTITY=new Dt;class Ft{constructor(){this.data=new Float32Array([1,0,0,0,1,0,0,0,1]),this.ex=new Gt(this.data.subarray(0,3)),this.ey=new Gt(this.data.subarray(3,6)),this.ez=new Gt(this.data.subarray(6,9))}Clone(){return(new Ft).Copy(this)}SetVVV(t,e,s){return this.ex.Copy(t),this.ey.Copy(e),this.ez.Copy(s),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this.ez.Copy(t.ez),this}SetIdentity(){return this.ex.SetXYZ(1,0,0),this.ey.SetXYZ(0,1,0),this.ez.SetXYZ(0,0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this.ez.SetZero(),this}SelfAddM(t){return this.ex.SelfAdd(t.ex),this.ey.SelfAdd(t.ey),this.ez.SelfAdd(t.ez),this}Solve33(t,e,s,i){const n=this.ex.x,o=this.ex.y,r=this.ex.z,a=this.ey.x,h=this.ey.y,l=this.ey.z,_=this.ez.x,m=this.ez.y,c=this.ez.z;let u=n*(h*c-l*m)+o*(l*_-a*c)+r*(a*m-h*_);return 0!==u&&(u=1/u),i.x=u*(t*(h*c-l*m)+e*(l*_-a*c)+s*(a*m-h*_)),i.y=u*(n*(e*c-s*m)+o*(s*_-t*c)+r*(t*m-e*_)),i.z=u*(n*(h*s-l*e)+o*(l*t-a*s)+r*(a*e-h*t)),i}Solve22(t,e,s){const i=this.ex.x,n=this.ey.x,o=this.ex.y,r=this.ey.y;let a=i*r-n*o;return 0!==a&&(a=1/a),s.x=a*(r*t-n*e),s.y=a*(i*e-o*t),s}GetInverse22(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,n=this.ey.y;let o=e*n-s*i;0!==o&&(o=1/o),t.ex.x=o*n,t.ey.x=-o*s,t.ex.z=0,t.ex.y=-o*i,t.ey.y=o*e,t.ey.z=0,t.ez.x=0,t.ez.y=0,t.ez.z=0}GetSymInverse33(t){let e=Gt.DotV3V3(this.ex,Gt.CrossV3V3(this.ey,this.ez,Gt.s_t0));0!==e&&(e=1/e);const s=this.ex.x,i=this.ey.x,n=this.ez.x,o=this.ey.y,r=this.ez.y,a=this.ez.z;t.ex.x=e*(o*a-r*r),t.ex.y=e*(n*r-i*a),t.ex.z=e*(i*r-n*o),t.ey.x=t.ex.y,t.ey.y=e*(s*a-n*n),t.ey.z=e*(n*i-s*r),t.ez.x=t.ex.z,t.ez.y=t.ey.z,t.ez.z=e*(s*o-i*i)}static MulM33V3(t,e,s){const i=e.x,n=e.y,o=e.z;return s.x=t.ex.x*i+t.ey.x*n+t.ez.x*o,s.y=t.ex.y*i+t.ey.y*n+t.ez.y*o,s.z=t.ex.z*i+t.ey.z*n+t.ez.z*o,s}static MulM33XYZ(t,e,s,i,n){return n.x=t.ex.x*e+t.ey.x*s+t.ez.x*i,n.y=t.ex.y*e+t.ey.y*s+t.ez.y*i,n.z=t.ex.z*e+t.ey.z*s+t.ez.z*i,n}static MulM33V2(t,e,s){const i=e.x,n=e.y;return s.x=t.ex.x*i+t.ey.x*n,s.y=t.ex.y*i+t.ey.y*n,s}static MulM33XY(t,e,s,i){return i.x=t.ex.x*e+t.ey.x*s,i.y=t.ex.y*e+t.ey.y*s,i}}Ft.IDENTITY=new Ft;class Lt{constructor(t=0){this.s=0,this.c=1,t&&(this.s=Math.sin(t),this.c=Math.cos(t))}Clone(){return(new Lt).Copy(this)}Copy(t){return this.s=t.s,this.c=t.c,this}SetAngle(t){return this.s=Math.sin(t),this.c=Math.cos(t),this}SetIdentity(){return this.s=0,this.c=1,this}GetAngle(){return Math.atan2(this.s,this.c)}GetXAxis(t){return t.x=this.c,t.y=this.s,t}GetYAxis(t){return t.x=-this.s,t.y=this.c,t}static MulRR(t,e,s){const i=t.c,n=t.s,o=e.c,r=e.s;return s.s=n*o+i*r,s.c=i*o-n*r,s}static MulTRR(t,e,s){const i=t.c,n=t.s,o=e.c,r=e.s;return s.s=i*r-n*o,s.c=i*o+n*r,s}static MulRV(t,e,s){const i=t.c,n=t.s,o=e.x,r=e.y;return s.x=i*o-n*r,s.y=n*o+i*r,s}static MulTRV(t,e,s){const i=t.c,n=t.s,o=e.x,r=e.y;return s.x=i*o+n*r,s.y=-n*o+i*r,s}}Lt.IDENTITY=new Lt;class Rt{constructor(){this.p=new Mt,this.q=new Lt}Clone(){return(new Rt).Copy(this)}Copy(t){return this.p.Copy(t.p),this.q.Copy(t.q),this}SetIdentity(){return this.p.SetZero(),this.q.SetIdentity(),this}SetPositionRotation(t,e){return this.p.Copy(t),this.q.Copy(e),this}SetPositionAngle(t,e){return this.p.Copy(t),this.q.SetAngle(e),this}SetPosition(t){return this.p.Copy(t),this}SetPositionXY(t,e){return this.p.Set(t,e),this}SetRotation(t){return this.q.Copy(t),this}SetRotationAngle(t){return this.q.SetAngle(t),this}GetPosition(){return this.p}GetRotation(){return this.q}GetRotationAngle(){return this.q.GetAngle()}GetAngle(){return this.q.GetAngle()}static MulXV(t,e,s){const i=t.q.c,n=t.q.s,o=e.x,r=e.y;return s.x=i*o-n*r+t.p.x,s.y=n*o+i*r+t.p.y,s}static MulTXV(t,e,s){const i=t.q.c,n=t.q.s,o=e.x-t.p.x,r=e.y-t.p.y;return s.x=i*o+n*r,s.y=-n*o+i*r,s}static MulXX(t,e,s){return Lt.MulRR(t.q,e.q,s.q),Mt.AddVV(Lt.MulRV(t.q,e.p,s.p),t.p,s.p),s}static MulTXX(t,e,s){return Lt.MulTRR(t.q,e.q,s.q),Lt.MulTRV(t.q,Mt.SubVV(e.p,t.p,s.p),s.p),s}}Rt.IDENTITY=new Rt;class Tt{constructor(){this.localCenter=new Mt,this.c0=new Mt,this.c=new Mt,this.a0=0,this.a=0,this.alpha0=0}Clone(){return(new Tt).Copy(this)}Copy(t){return this.localCenter.Copy(t.localCenter),this.c0.Copy(t.c0),this.c.Copy(t.c),this.a0=t.a0,this.a=t.a,this.alpha0=t.alpha0,this}GetTransform(t,e){t.p.x=(1-e)*this.c0.x+e*this.c.x,t.p.y=(1-e)*this.c0.y+e*this.c.y;const s=(1-e)*this.a0+e*this.a;return t.q.SetAngle(s),t.p.SelfSub(Lt.MulRV(t.q,this.localCenter,Mt.s_t0)),t}Advance(t){const e=(t-this.alpha0)/(1-this.alpha0),s=1-e;this.c0.x=s*this.c0.x+e*this.c.x,this.c0.y=s*this.c0.y+e*this.c.y,this.a0=s*this.a0+e*this.a,this.alpha0=t}Normalize(){const t=rt*Math.floor(this.a0/rt);this.a0-=t,this.a-=t}}class kt{}class qt{constructor(){this.m_start=Date.now()}Reset(){return this.m_start=Date.now(),this}GetMilliseconds(){return Date.now()-this.m_start}}class zt{constructor(){this.m_count=0,this.m_min_count=0,this.m_max_count=0}GetCount(){return this.m_count}GetMinCount(){return this.m_min_count}GetMaxCount(){return this.m_max_count}ResetCount(){const t=this.m_count;return this.m_count=0,t}ResetMinCount(){this.m_min_count=0}ResetMaxCount(){this.m_max_count=0}Increment(){this.m_count++,this.m_max_count<this.m_count&&(this.m_max_count=this.m_count)}Decrement(){this.m_count--,this.m_min_count>this.m_count&&(this.m_min_count=this.m_count)}}class Et{constructor(){this.m_buffer=Mt.MakeArray(2),this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0}Copy(t){return t.m_vertices===t.m_buffer?(this.m_vertices=this.m_buffer,this.m_buffer[0].Copy(t.m_buffer[0]),this.m_buffer[1].Copy(t.m_buffer[1])):this.m_vertices=t.m_vertices,this.m_count=t.m_count,this.m_radius=t.m_radius,this}Reset(){return this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0,this}SetShape(t,e){t.SetupDistanceProxy(this,e)}SetVerticesRadius(t,e,s){this.m_vertices=t,this.m_count=e,this.m_radius=s}GetSupport(t){let e=0,s=Mt.DotVV(this.m_vertices[0],t);for(let i=1;i<this.m_count;++i){const n=Mt.DotVV(this.m_vertices[i],t);n>s&&(e=i,s=n)}return e}GetSupportVertex(t){let e=0,s=Mt.DotVV(this.m_vertices[0],t);for(let i=1;i<this.m_count;++i){const n=Mt.DotVV(this.m_vertices[i],t);n>s&&(e=i,s=n)}return this.m_vertices[e]}GetVertexCount(){return this.m_count}GetVertex(t){return this.m_vertices[t]}}class Nt{constructor(){this.metric=0,this.count=0,this.indexA=[0,0,0],this.indexB=[0,0,0]}Reset(){return this.metric=0,this.count=0,this}}class jt{constructor(){this.proxyA=new Et,this.proxyB=new Et,this.transformA=new Rt,this.transformB=new Rt,this.useRadii=!1}Reset(){return this.proxyA.Reset(),this.proxyB.Reset(),this.transformA.SetIdentity(),this.transformB.SetIdentity(),this.useRadii=!1,this}}class Jt{constructor(){this.pointA=new Mt,this.pointB=new Mt,this.distance=0,this.iterations=0}Reset(){return this.pointA.SetZero(),this.pointB.SetZero(),this.distance=0,this.iterations=0,this}}class Xt{constructor(){this.proxyA=new Et,this.proxyB=new Et,this.transformA=new Rt,this.transformB=new Rt,this.translationB=new Mt}}class Ot{constructor(){this.point=new Mt,this.normal=new Mt,this.lambda=0,this.iterations=0}}let Zt=0,Ut=0,Wt=0;function Qt(){Zt=0,Ut=0,Wt=0}class Yt{constructor(){this.wA=new Mt,this.wB=new Mt,this.w=new Mt,this.a=0,this.indexA=0,this.indexB=0}Copy(t){return this.wA.Copy(t.wA),this.wB.Copy(t.wB),this.w.Copy(t.w),this.a=t.a,this.indexA=t.indexA,this.indexB=t.indexB,this}}class Kt{constructor(){this.m_v1=new Yt,this.m_v2=new Yt,this.m_v3=new Yt,this.m_vertices=[],this.m_count=0,this.m_vertices[0]=this.m_v1,this.m_vertices[1]=this.m_v2,this.m_vertices[2]=this.m_v3}ReadCache(t,e,s,i,n){this.m_count=t.count;const o=this.m_vertices;for(let r=0;r<this.m_count;++r){const a=o[r];a.indexA=t.indexA[r],a.indexB=t.indexB[r];const h=e.GetVertex(a.indexA),l=i.GetVertex(a.indexB);Rt.MulXV(s,h,a.wA),Rt.MulXV(n,l,a.wB),Mt.SubVV(a.wB,a.wA,a.w),a.a=0}if(this.m_count>1){const e=t.metric,s=this.GetMetric();(s<.5*e||2*e<s||s<m)&&(this.m_count=0)}if(0===this.m_count){const t=o[0];t.indexA=0,t.indexB=0;const r=e.GetVertex(0),a=i.GetVertex(0);Rt.MulXV(s,r,t.wA),Rt.MulXV(n,a,t.wB),Mt.SubVV(t.wB,t.wA,t.w),t.a=1,this.m_count=1}}WriteCache(t){t.metric=this.GetMetric(),t.count=this.m_count;const e=this.m_vertices;for(let s=0;s<this.m_count;++s)t.indexA[s]=e[s].indexA,t.indexB[s]=e[s].indexB}GetSearchDirection(t){switch(this.m_count){case 1:return Mt.NegV(this.m_v1.w,t);case 2:{const e=Mt.SubVV(this.m_v2.w,this.m_v1.w,t);return Mt.CrossVV(e,Mt.NegV(this.m_v1.w,Mt.s_t0))>0?Mt.CrossOneV(e,t):Mt.CrossVOne(e,t)}default:return t.SetZero()}}GetClosestPoint(t){switch(this.m_count){case 0:return t.SetZero();case 1:return t.Copy(this.m_v1.w);case 2:return t.Set(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y);case 3:default:return t.SetZero()}}GetWitnessPoints(t,e){switch(this.m_count){case 0:break;case 1:t.Copy(this.m_v1.wA),e.Copy(this.m_v1.wB);break;case 2:t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x,t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y,e.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x,e.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:e.x=t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x,e.y=t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y}}GetMetric(){switch(this.m_count){case 0:case 1:return 0;case 2:return Mt.DistanceVV(this.m_v1.w,this.m_v2.w);case 3:return Mt.CrossVV(Mt.SubVV(this.m_v2.w,this.m_v1.w,Mt.s_t0),Mt.SubVV(this.m_v3.w,this.m_v1.w,Mt.s_t1));default:return 0}}Solve2(){const t=this.m_v1.w,e=this.m_v2.w,s=Mt.SubVV(e,t,Kt.s_e12),i=-Mt.DotVV(t,s);if(i<=0)return this.m_v1.a=1,void(this.m_count=1);const n=Mt.DotVV(e,s);if(n<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);const o=1/(n+i);this.m_v1.a=n*o,this.m_v2.a=i*o,this.m_count=2}Solve3(){const t=this.m_v1.w,e=this.m_v2.w,s=this.m_v3.w,i=Mt.SubVV(e,t,Kt.s_e12),n=Mt.DotVV(t,i),o=Mt.DotVV(e,i),r=-n,a=Mt.SubVV(s,t,Kt.s_e13),h=Mt.DotVV(t,a),l=Mt.DotVV(s,a),_=-h,m=Mt.SubVV(s,e,Kt.s_e23),c=Mt.DotVV(e,m),u=Mt.DotVV(s,m),d=-c,f=Mt.CrossVV(i,a),p=f*Mt.CrossVV(e,s),y=f*Mt.CrossVV(s,t),x=f*Mt.CrossVV(t,e);if(r<=0&&_<=0)return this.m_v1.a=1,void(this.m_count=1);if(o>0&&r>0&&x<=0){const t=1/(o+r);return this.m_v1.a=o*t,this.m_v2.a=r*t,void(this.m_count=2)}if(l>0&&_>0&&y<=0){const t=1/(l+_);return this.m_v1.a=l*t,this.m_v3.a=_*t,this.m_count=2,void this.m_v2.Copy(this.m_v3)}if(o<=0&&d<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);if(l<=0&&u<=0)return this.m_v3.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v3);if(u>0&&d>0&&p<=0){const t=1/(u+d);return this.m_v2.a=u*t,this.m_v3.a=d*t,this.m_count=2,void this.m_v1.Copy(this.m_v3)}const B=1/(p+y+x);this.m_v1.a=p*B,this.m_v2.a=y*B,this.m_v3.a=x*B,this.m_count=3}}Kt.s_e12=new Mt,Kt.s_e13=new Mt,Kt.s_e23=new Mt;const Ht=new Kt,$t=[0,0,0],te=[0,0,0],ee=new Mt,se=new Mt,ie=new Mt,ne=new Mt,oe=new Mt;function re(t,e,s){++Zt;const i=s.proxyA,n=s.proxyB,o=s.transformA,r=s.transformB,a=Ht;a.ReadCache(e,i,o,n,r);const h=a.m_vertices,l=$t,_=te;let u=0,d=0;for(;d<20;){u=a.m_count;for(let t=0;t<u;++t)l[t]=h[t].indexA,_[t]=h[t].indexB;switch(a.m_count){case 1:break;case 2:a.Solve2();break;case 3:a.Solve3()}if(3===a.m_count)break;const t=a.GetSearchDirection(se);if(t.LengthSquared()<c)break;const e=h[a.m_count];e.indexA=i.GetSupport(Lt.MulTRV(o.q,Mt.NegV(t,Mt.s_t0),ne)),Rt.MulXV(o,i.GetVertex(e.indexA),e.wA),e.indexB=n.GetSupport(Lt.MulTRV(r.q,t,oe)),Rt.MulXV(r,n.GetVertex(e.indexB),e.wB),Mt.SubVV(e.wB,e.wA,e.w),++d,++Ut;let s=!1;for(let t=0;t<u;++t)if(e.indexA===l[t]&&e.indexB===_[t]){s=!0;break}if(s)break;++a.m_count}if(Wt=lt(Wt,d),a.GetWitnessPoints(t.pointA,t.pointB),t.distance=Mt.DistanceVV(t.pointA,t.pointB),t.iterations=d,a.WriteCache(e),s.useRadii){const e=i.m_radius,s=n.m_radius;if(t.distance>e+s&&t.distance>m){t.distance-=e+s;const i=Mt.SubVV(t.pointB,t.pointA,ie);i.Normalize(),t.pointA.SelfMulAdd(e,i),t.pointB.SelfMulSub(s,i)}else{const e=Mt.MidVV(t.pointA,t.pointB,ee);t.pointA.Copy(e),t.pointB.Copy(e),t.distance=0}}}const ae=new Mt,he=new Kt,le=new Mt,_e=new Mt,me=new Mt,ce=new Mt,ue=new Mt,de=new Mt;function fe(t,e){t.iterations=0,t.lambda=1,t.normal.SetZero(),t.point.SetZero();const s=e.proxyA,i=e.proxyB,n=lt(s.m_radius,A)+lt(i.m_radius,A),o=e.transformA,r=e.transformB,a=e.translationB,h=ae.Set(0,0);let l=0;const _=he;_.m_count=0;const m=_.m_vertices;let c=s.GetSupport(Lt.MulTRV(o.q,Mt.NegV(a,Mt.s_t1),Mt.s_t0)),u=Rt.MulXV(o,s.GetVertex(c),le),d=i.GetSupport(Lt.MulTRV(r.q,a,Mt.s_t0)),f=Rt.MulXV(r,i.GetVertex(d),_e);const p=Mt.SubVV(u,f,me),y=lt(A,n-A),x=.5*B;let S=0;for(;S<20&&p.Length()-y>x;){t.iterations+=1,c=s.GetSupport(Lt.MulTRV(o.q,Mt.NegV(p,Mt.s_t1),Mt.s_t0)),u=Rt.MulXV(o,s.GetVertex(c),le),d=i.GetSupport(Lt.MulTRV(r.q,p,Mt.s_t0)),f=Rt.MulXV(r,i.GetVertex(d),_e);const e=Mt.SubVV(u,f,ce);p.Normalize();const n=Mt.DotVV(p,e),x=Mt.DotVV(p,a);if(n-y>l*x){if(x<=0)return!1;if(l=(n-y)/x,l>1)return!1;h.Copy(p).SelfNeg(),_.m_count=0}const B=m[_.m_count];switch(B.indexA=d,B.wA.Copy(f).SelfMulAdd(l,a),B.indexB=c,B.wB.Copy(u),B.w.Copy(B.wB).SelfSub(B.wA),B.a=1,_.m_count+=1,_.m_count){case 1:break;case 2:_.Solve2();break;case 3:_.Solve3()}if(3===_.m_count)return!1;_.GetClosestPoint(p),++S}if(0===S)return!1;const C=ue,V=de;return _.GetWitnessPoints(C,V),p.LengthSquared()>0&&(h.Copy(p).SelfNeg(),h.Normalize()),t.normal.Copy(h),t.lambda=l,t.iterations=S,!0}var pe,ye,xe;!function(t){t[t.e_vertex=0]="e_vertex",t[t.e_face=1]="e_face"}(pe||(pe={}));class Be{constructor(){this._key=0,this._key_invalid=!1,this._indexA=0,this._indexB=0,this._typeA=0,this._typeB=0}get key(){return this._key_invalid&&(this._key_invalid=!1,this._key=this._indexA|this._indexB<<8|this._typeA<<16|this._typeB<<24),this._key}set key(t){this._key=t,this._key_invalid=!1,this._indexA=255&this._key,this._indexB=this._key>>8&255,this._typeA=this._key>>16&255,this._typeB=this._key>>24&255}get indexA(){return this._indexA}set indexA(t){this._indexA=t,this._key_invalid=!0}get indexB(){return this._indexB}set indexB(t){this._indexB=t,this._key_invalid=!0}get typeA(){return this._typeA}set typeA(t){this._typeA=t,this._key_invalid=!0}get typeB(){return this._typeB}set typeB(t){this._typeB=t,this._key_invalid=!0}}class Se{constructor(){this.cf=new Be}Copy(t){return this.key=t.key,this}Clone(){return(new Se).Copy(this)}get key(){return this.cf.key}set key(t){this.cf.key=t}}class Ae{constructor(){this.localPoint=new Mt,this.normalImpulse=0,this.tangentImpulse=0,this.id=new Se}static MakeArray(t){return K(t,t=>new Ae)}Reset(){this.localPoint.SetZero(),this.normalImpulse=0,this.tangentImpulse=0,this.id.key=0}Copy(t){return this.localPoint.Copy(t.localPoint),this.normalImpulse=t.normalImpulse,this.tangentImpulse=t.tangentImpulse,this.id.Copy(t.id),this}}!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circles=0]="e_circles",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(ye||(ye={}));class Ce{constructor(){this.points=Ae.MakeArray(p),this.localNormal=new Mt,this.localPoint=new Mt,this.type=ye.e_unknown,this.pointCount=0}Reset(){for(let t=0;t<p;++t)this.points[t].Reset();this.localNormal.SetZero(),this.localPoint.SetZero(),this.type=ye.e_unknown,this.pointCount=0}Copy(t){this.pointCount=t.pointCount;for(let e=0;e<p;++e)this.points[e].Copy(t.points[e]);return this.localNormal.Copy(t.localNormal),this.localPoint.Copy(t.localPoint),this.type=t.type,this}Clone(){return(new Ce).Copy(this)}}class Ve{constructor(){this.normal=new Mt,this.points=Mt.MakeArray(p),this.separations=$(p)}Initialize(t,e,s,i,n){if(0!==t.pointCount)switch(t.type){case ye.e_circles:{this.normal.Set(1,0);const o=Rt.MulXV(e,t.localPoint,Ve.Initialize_s_pointA),r=Rt.MulXV(i,t.points[0].localPoint,Ve.Initialize_s_pointB);Mt.DistanceSquaredVV(o,r)>c&&Mt.SubVV(r,o,this.normal).SelfNormalize();const a=Mt.AddVMulSV(o,s,this.normal,Ve.Initialize_s_cA),h=Mt.SubVMulSV(r,n,this.normal,Ve.Initialize_s_cB);Mt.MidVV(a,h,this.points[0]),this.separations[0]=Mt.DotVV(Mt.SubVV(h,a,Mt.s_t0),this.normal);break}case ye.e_faceA:{Lt.MulRV(e.q,t.localNormal,this.normal);const o=Rt.MulXV(e,t.localPoint,Ve.Initialize_s_planePoint);for(let e=0;e<t.pointCount;++e){const r=Rt.MulXV(i,t.points[e].localPoint,Ve.Initialize_s_clipPoint),a=s-Mt.DotVV(Mt.SubVV(r,o,Mt.s_t0),this.normal),h=Mt.AddVMulSV(r,a,this.normal,Ve.Initialize_s_cA),l=Mt.SubVMulSV(r,n,this.normal,Ve.Initialize_s_cB);Mt.MidVV(h,l,this.points[e]),this.separations[e]=Mt.DotVV(Mt.SubVV(l,h,Mt.s_t0),this.normal)}break}case ye.e_faceB:{Lt.MulRV(i.q,t.localNormal,this.normal);const o=Rt.MulXV(i,t.localPoint,Ve.Initialize_s_planePoint);for(let i=0;i<t.pointCount;++i){const r=Rt.MulXV(e,t.points[i].localPoint,Ve.Initialize_s_clipPoint),a=n-Mt.DotVV(Mt.SubVV(r,o,Mt.s_t0),this.normal),h=Mt.AddVMulSV(r,a,this.normal,Ve.Initialize_s_cB),l=Mt.SubVMulSV(r,s,this.normal,Ve.Initialize_s_cA);Mt.MidVV(l,h,this.points[i]),this.separations[i]=Mt.DotVV(Mt.SubVV(l,h,Mt.s_t0),this.normal)}this.normal.SelfNeg();break}}}}function ge(t,e,s,i){let n;for(n=0;n<s.pointCount;++n){const e=s.points[n].id.key;t[n]=xe.b2_removeState;for(let s=0,o=i.pointCount;s<o;++s)if(i.points[s].id.key===e){t[n]=xe.b2_persistState;break}}for(;n<p;++n)t[n]=xe.b2_nullState;for(n=0;n<i.pointCount;++n){const t=i.points[n].id.key;e[n]=xe.b2_addState;for(let i=0,o=s.pointCount;i<o;++i)if(s.points[i].id.key===t){e[n]=xe.b2_persistState;break}}for(;n<p;++n)e[n]=xe.b2_nullState}Ve.Initialize_s_pointA=new Mt,Ve.Initialize_s_pointB=new Mt,Ve.Initialize_s_cA=new Mt,Ve.Initialize_s_cB=new Mt,Ve.Initialize_s_planePoint=new Mt,Ve.Initialize_s_clipPoint=new Mt,function(t){t[t.b2_nullState=0]="b2_nullState",t[t.b2_addState=1]="b2_addState",t[t.b2_persistState=2]="b2_persistState",t[t.b2_removeState=3]="b2_removeState"}(xe||(xe={}));class we{constructor(){this.v=new Mt,this.id=new Se}static MakeArray(t){return K(t,t=>new we)}Copy(t){return this.v.Copy(t.v),this.id.Copy(t.id),this}}class ve{constructor(){this.p1=new Mt,this.p2=new Mt,this.maxFraction=1}Copy(t){return this.p1.Copy(t.p1),this.p2.Copy(t.p2),this.maxFraction=t.maxFraction,this}}class be{constructor(){this.normal=new Mt,this.fraction=0}Copy(t){return this.normal.Copy(t.normal),this.fraction=t.fraction,this}}class Me{constructor(){this.lowerBound=new Mt,this.upperBound=new Mt,this.m_cache_center=new Mt,this.m_cache_extent=new Mt}Copy(t){return this.lowerBound.Copy(t.lowerBound),this.upperBound.Copy(t.upperBound),this}IsValid(){return!!this.lowerBound.IsValid()&&(!!this.upperBound.IsValid()&&(!(this.upperBound.x<this.lowerBound.x)&&!(this.upperBound.y<this.lowerBound.y)))}GetCenter(){return Mt.MidVV(this.lowerBound,this.upperBound,this.m_cache_center)}GetExtents(){return Mt.ExtVV(this.lowerBound,this.upperBound,this.m_cache_extent)}GetPerimeter(){return 2*(this.upperBound.x-this.lowerBound.x+(this.upperBound.y-this.lowerBound.y))}Combine1(t){return this.lowerBound.x=ht(this.lowerBound.x,t.lowerBound.x),this.lowerBound.y=ht(this.lowerBound.y,t.lowerBound.y),this.upperBound.x=lt(this.upperBound.x,t.upperBound.x),this.upperBound.y=lt(this.upperBound.y,t.upperBound.y),this}Combine2(t,e){return this.lowerBound.x=ht(t.lowerBound.x,e.lowerBound.x),this.lowerBound.y=ht(t.lowerBound.y,e.lowerBound.y),this.upperBound.x=lt(t.upperBound.x,e.upperBound.x),this.upperBound.y=lt(t.upperBound.y,e.upperBound.y),this}static Combine(t,e,s){return s.Combine2(t,e),s}Contains(t){let e=!0;return e=e&&this.lowerBound.x<=t.lowerBound.x,e=e&&this.lowerBound.y<=t.lowerBound.y,e=e&&t.upperBound.x<=this.upperBound.x,e=e&&t.upperBound.y<=this.upperBound.y,e}RayCast(t,e){let s=-_,i=_;const n=e.p1.x,o=e.p1.y,r=e.p2.x-e.p1.x,a=e.p2.y-e.p1.y,h=at(r),l=at(a),c=t.normal;if(h<m){if(n<this.lowerBound.x||this.upperBound.x<n)return!1}else{const t=1/r;let e=(this.lowerBound.x-n)*t,o=(this.upperBound.x-n)*t,a=-1;if(e>o){const t=e;e=o,o=t,a=1}if(e>s&&(c.x=a,c.y=0,s=e),i=ht(i,o),s>i)return!1}if(l<m){if(o<this.lowerBound.y||this.upperBound.y<o)return!1}else{const t=1/a;let e=(this.lowerBound.y-o)*t,n=(this.upperBound.y-o)*t,r=-1;if(e>n){const t=e;e=n,n=t,r=1}if(e>s&&(c.x=0,c.y=r,s=e),i=ht(i,n),s>i)return!1}return!(s<0||e.maxFraction<s)&&(t.fraction=s,!0)}TestContain(t){return!(t.x<this.lowerBound.x||this.upperBound.x<t.x)&&!(t.y<this.lowerBound.y||this.upperBound.y<t.y)}TestOverlap(t){return!(this.upperBound.x<t.lowerBound.x)&&(!(this.upperBound.y<t.lowerBound.y)&&(!(t.upperBound.x<this.lowerBound.x)&&!(t.upperBound.y<this.lowerBound.y)))}}function Pe(t,e){return!(t.upperBound.x<e.lowerBound.x)&&(!(t.upperBound.y<e.lowerBound.y)&&(!(e.upperBound.x<t.lowerBound.x)&&!(e.upperBound.y<t.lowerBound.y)))}function Ie(t,e,s,i,n){let o=0;const r=e[0],a=e[1],h=Mt.DotVV(s,r.v)-i,l=Mt.DotVV(s,a.v)-i;if(h<=0&&t[o++].Copy(r),l<=0&&t[o++].Copy(a),h*l<0){const e=h/(h-l),s=t[o].v;s.x=r.v.x+e*(a.v.x-r.v.x),s.y=r.v.y+e*(a.v.y-r.v.y);const i=t[o].id;i.cf.indexA=n,i.cf.indexB=r.id.cf.indexB,i.cf.typeA=pe.e_vertex,i.cf.typeB=pe.e_face,++o}return o}const Ge=new jt,De=new Nt,Fe=new Jt;function Le(t,e,s,i,n,o){const r=Ge.Reset();r.proxyA.SetShape(t,e),r.proxyB.SetShape(s,i),r.transformA.Copy(n),r.transformB.Copy(o),r.useRadii=!0;const a=De.Reset();a.count=0;const h=Fe.Reset();return re(h,a,r),h.distance<10*m}function Re(t){if(null===t)throw new Error;return t}class Te{constructor(t=0){this.m_id=0,this.aabb=new Me,this._userData=null,this.parent=null,this.child1=null,this.child2=null,this.height=0,this.moved=!1,this.m_id=t}get userData(){if(null===this._userData)throw new Error;return this._userData}set userData(t){if(null!==this._userData)throw new Error;this._userData=t}Reset(){this._userData=null}IsLeaf(){return null===this.child1}}class ke{constructor(){this.m_root=null,this.m_freeList=null,this.m_insertionCount=0,this.m_stack=new it(256)}Query(t,e){const s=this.m_stack.Reset();for(s.Push(this.m_root);s.GetCount()>0;){const i=s.Pop();if(null!==i&&i.aabb.TestOverlap(t))if(i.IsLeaf()){if(!e(i))return}else s.Push(i.child1),s.Push(i.child2)}}QueryPoint(t,e){const s=this.m_stack.Reset();for(s.Push(this.m_root);s.GetCount()>0;){const i=s.Pop();if(null!==i&&i.aabb.TestContain(t))if(i.IsLeaf()){if(!e(i))return}else s.Push(i.child1),s.Push(i.child2)}}RayCast(t,e){const s=t.p1,i=t.p2,n=Mt.SubVV(i,s,ke.s_r);n.Normalize();const o=Mt.CrossOneV(n,ke.s_v),r=Mt.AbsV(o,ke.s_abs_v);let a=t.maxFraction;const h=ke.s_segmentAABB;let l=s.x+a*(i.x-s.x),_=s.y+a*(i.y-s.y);h.lowerBound.x=ht(s.x,l),h.lowerBound.y=ht(s.y,_),h.upperBound.x=lt(s.x,l),h.upperBound.y=lt(s.y,_);const m=this.m_stack.Reset();for(m.Push(this.m_root);m.GetCount()>0;){const n=m.Pop();if(null===n)continue;if(!Pe(n.aabb,h))continue;const c=n.aabb.GetCenter(),u=n.aabb.GetExtents();if(!(at(Mt.DotVV(o,Mt.SubVV(s,c,Mt.s_t0)))-Mt.DotVV(r,u)>0))if(n.IsLeaf()){const o=ke.s_subInput;o.p1.Copy(t.p1),o.p2.Copy(t.p2),o.maxFraction=a;const r=e(o,n);if(0===r)return;r>0&&(a=r,l=s.x+a*(i.x-s.x),_=s.y+a*(i.y-s.y),h.lowerBound.x=ht(s.x,l),h.lowerBound.y=ht(s.y,_),h.upperBound.x=lt(s.x,l),h.upperBound.y=lt(s.y,_))}else m.Push(n.child1),m.Push(n.child2)}}AllocateNode(){if(null!==this.m_freeList){const t=this.m_freeList;return this.m_freeList=t.parent,t.parent=null,t.child1=null,t.child2=null,t.height=0,t.moved=!1,t}return new Te(ke.s_node_id++)}FreeNode(t){t.parent=this.m_freeList,t.child1=null,t.child2=null,t.height=-1,t.Reset(),this.m_freeList=t}CreateProxy(t,e){const s=this.AllocateNode(),i=y,n=y;return s.aabb.lowerBound.x=t.lowerBound.x-i,s.aabb.lowerBound.y=t.lowerBound.y-n,s.aabb.upperBound.x=t.upperBound.x+i,s.aabb.upperBound.y=t.upperBound.y+n,s.userData=e,s.height=0,s.moved=!0,this.InsertLeaf(s),s}DestroyProxy(t){this.RemoveLeaf(t),this.FreeNode(t)}MoveProxy(t,e,s){const i=ke.MoveProxy_s_fatAABB,n=y,o=y;i.lowerBound.x=e.lowerBound.x-n,i.lowerBound.y=e.lowerBound.y-o,i.upperBound.x=e.upperBound.x+n,i.upperBound.y=e.upperBound.y+o;const r=x*s.x,a=x*s.y;r<0?i.lowerBound.x+=r:i.upperBound.x+=r,a<0?i.lowerBound.y+=a:i.upperBound.y+=a;const h=t.aabb;if(h.Contains(e)){const t=ke.MoveProxy_s_hugeAABB;if(t.lowerBound.x=i.lowerBound.x-4*n,t.lowerBound.y=i.lowerBound.y-4*o,t.upperBound.x=i.upperBound.x+4*n,t.upperBound.y=i.upperBound.y+4*o,t.Contains(h))return!1}return this.RemoveLeaf(t),t.aabb.Copy(i),this.InsertLeaf(t),t.moved=!0,!0}InsertLeaf(t){if(++this.m_insertionCount,null===this.m_root)return this.m_root=t,void(this.m_root.parent=null);const e=t.aabb;let s=this.m_root;for(;!s.IsLeaf();){const t=Re(s.child1),i=Re(s.child2),n=s.aabb.GetPerimeter(),o=ke.s_combinedAABB;o.Combine2(s.aabb,e);const r=o.GetPerimeter(),a=2*r,h=2*(r-n);let l;const _=ke.s_aabb;let m,c,u;if(t.IsLeaf()?(_.Combine2(e,t.aabb),l=_.GetPerimeter()+h):(_.Combine2(e,t.aabb),m=t.aabb.GetPerimeter(),c=_.GetPerimeter(),l=c-m+h),i.IsLeaf()?(_.Combine2(e,i.aabb),u=_.GetPerimeter()+h):(_.Combine2(e,i.aabb),m=i.aabb.GetPerimeter(),c=_.GetPerimeter(),u=c-m+h),a<l&&a<u)break;s=l<u?t:i}const i=s.parent,n=this.AllocateNode();n.parent=i,n.aabb.Combine2(e,s.aabb),n.height=s.height+1,null!==i?(i.child1===s?i.child1=n:i.child2=n,n.child1=s,n.child2=t,s.parent=n,t.parent=n):(n.child1=s,n.child2=t,s.parent=n,t.parent=n,this.m_root=n);let o=t.parent;for(;null!==o;){o=this.Balance(o);const t=Re(o.child1),e=Re(o.child2);o.height=1+lt(t.height,e.height),o.aabb.Combine2(t.aabb,e.aabb),o=o.parent}}RemoveLeaf(t){if(t===this.m_root)return void(this.m_root=null);const e=Re(t.parent),s=e&&e.parent,i=Re(e.child1===t?e.child2:e.child1);if(null!==s){s.child1===e?s.child1=i:s.child2=i,i.parent=s,this.FreeNode(e);let t=s;for(;null!==t;){t=this.Balance(t);const e=Re(t.child1),s=Re(t.child2);t.aabb.Combine2(e.aabb,s.aabb),t.height=1+lt(e.height,s.height),t=t.parent}}else this.m_root=i,i.parent=null,this.FreeNode(e)}Balance(t){if(t.IsLeaf()||t.height<2)return t;const e=Re(t.child1),s=Re(t.child2),i=s.height-e.height;if(i>1){const i=Re(s.child1),n=Re(s.child2);return s.child1=t,s.parent=t.parent,t.parent=s,null!==s.parent?s.parent.child1===t?s.parent.child1=s:s.parent.child2=s:this.m_root=s,i.height>n.height?(s.child2=i,t.child2=n,n.parent=t,t.aabb.Combine2(e.aabb,n.aabb),s.aabb.Combine2(t.aabb,i.aabb),t.height=1+lt(e.height,n.height),s.height=1+lt(t.height,i.height)):(s.child2=n,t.child2=i,i.parent=t,t.aabb.Combine2(e.aabb,i.aabb),s.aabb.Combine2(t.aabb,n.aabb),t.height=1+lt(e.height,i.height),s.height=1+lt(t.height,n.height)),s}if(i<-1){const i=Re(e.child1),n=Re(e.child2);return e.child1=t,e.parent=t.parent,t.parent=e,null!==e.parent?e.parent.child1===t?e.parent.child1=e:e.parent.child2=e:this.m_root=e,i.height>n.height?(e.child2=i,t.child1=n,n.parent=t,t.aabb.Combine2(s.aabb,n.aabb),e.aabb.Combine2(t.aabb,i.aabb),t.height=1+lt(s.height,n.height),e.height=1+lt(t.height,i.height)):(e.child2=n,t.child1=i,i.parent=t,t.aabb.Combine2(s.aabb,i.aabb),e.aabb.Combine2(t.aabb,n.aabb),t.height=1+lt(s.height,i.height),e.height=1+lt(t.height,n.height)),e}return t}GetHeight(){return null===this.m_root?0:this.m_root.height}static GetAreaNode(t){if(null===t)return 0;if(t.IsLeaf())return 0;let e=t.aabb.GetPerimeter();return e+=ke.GetAreaNode(t.child1),e+=ke.GetAreaNode(t.child2),e}GetAreaRatio(){if(null===this.m_root)return 0;const t=this.m_root.aabb.GetPerimeter();return ke.GetAreaNode(this.m_root)/t}static ComputeHeightNode(t){if(null===t)return 0;if(t.IsLeaf())return 0;return 1+lt(ke.ComputeHeightNode(t.child1),ke.ComputeHeightNode(t.child2))}ComputeHeight(){return ke.ComputeHeightNode(this.m_root)}ValidateStructure(t){if(null===t)return;if(this.m_root,t.IsLeaf())return;const e=Re(t.child1),s=Re(t.child2);this.ValidateStructure(e),this.ValidateStructure(s)}ValidateMetrics(t){if(null===t)return;if(t.IsLeaf())return;const e=Re(t.child1),s=Re(t.child2);ke.s_aabb.Combine2(e.aabb,s.aabb),this.ValidateMetrics(e),this.ValidateMetrics(s)}Validate(){}static GetMaxBalanceNode(t,e){if(null===t)return e;if(t.height<=1)return e;const s=Re(t.child1),i=Re(t.child2);return lt(e,at(i.height-s.height))}GetMaxBalance(){return ke.GetMaxBalanceNode(this.m_root,0)}RebuildBottomUp(){this.Validate()}static ShiftOriginNode(t,e){if(null===t)return;if(t.height<=1)return;const s=t.child1,i=t.child2;ke.ShiftOriginNode(s,e),ke.ShiftOriginNode(i,e),t.aabb.lowerBound.SelfSub(e),t.aabb.upperBound.SelfSub(e)}ShiftOrigin(t){ke.ShiftOriginNode(this.m_root,t)}}ke.s_r=new Mt,ke.s_v=new Mt,ke.s_abs_v=new Mt,ke.s_segmentAABB=new Me,ke.s_subInput=new ve,ke.s_combinedAABB=new Me,ke.s_aabb=new Me,ke.s_node_id=0,ke.MoveProxy_s_fatAABB=new Me,ke.MoveProxy_s_hugeAABB=new Me;class qe{constructor(t,e){this.proxyA=t,this.proxyB=e}}class ze{constructor(){this.m_tree=new ke,this.m_proxyCount=0,this.m_moveBuffer=new Set,this.m_pairCount=0,this.m_pairBuffer=[]}CreateProxy(t,e){const s=this.m_tree.CreateProxy(t,e);return++this.m_proxyCount,this.BufferMove(s),s}DestroyProxy(t){this.UnBufferMove(t),--this.m_proxyCount,this.m_tree.DestroyProxy(t)}MoveProxy(t,e,s){this.m_tree.MoveProxy(t,e,s)&&this.BufferMove(t)}TouchProxy(t){this.BufferMove(t)}GetProxyCount(){return this.m_proxyCount}UpdatePairs(t){this.m_pairCount=0,this.m_moveBuffer.forEach(t=>{const e=t.aabb;this.m_tree.Query(e,e=>{if(e.m_id===t.m_id)return!0;if(e.moved&&e.m_id>t.m_id)return!0;let s,i;if(e.m_id<t.m_id?(s=e,i=t):(s=t,i=e),this.m_pairCount===this.m_pairBuffer.length)this.m_pairBuffer[this.m_pairCount]=new qe(s,i);else{const t=this.m_pairBuffer[this.m_pairCount];t.proxyA=s,t.proxyB=i}return++this.m_pairCount,!0})});for(let e=0;e<this.m_pairCount;++e){const s=this.m_pairBuffer[e];t(s.proxyA.userData,s.proxyB.userData)}this.m_moveBuffer.forEach(t=>t.moved=!1),this.m_moveBuffer.clear()}Query(t,e){this.m_tree.Query(t,e)}QueryPoint(t,e){this.m_tree.QueryPoint(t,e)}RayCast(t,e){this.m_tree.RayCast(t,e)}GetTreeHeight(){return this.m_tree.GetHeight()}GetTreeBalance(){return this.m_tree.GetMaxBalance()}GetTreeQuality(){return this.m_tree.GetAreaRatio()}ShiftOrigin(t){this.m_tree.ShiftOrigin(t)}BufferMove(t){this.m_moveBuffer.add(t)}UnBufferMove(t){this.m_moveBuffer.delete(t)}}class Ee{constructor(){this.mass=0,this.center=new Mt(0,0),this.I=0}}var Ne;!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circleShape=0]="e_circleShape",t[t.e_edgeShape=1]="e_edgeShape",t[t.e_polygonShape=2]="e_polygonShape",t[t.e_chainShape=3]="e_chainShape",t[t.e_shapeTypeCount=4]="e_shapeTypeCount"}(Ne||(Ne={}));class je{constructor(t,e){this.m_type=Ne.e_unknown,this.m_radius=0,this.m_type=t,this.m_radius=e}Copy(t){return this.m_radius=t.m_radius,this}GetType(){return this.m_type}}class Je extends je{constructor(){super(Ne.e_edgeShape,A),this.m_vertex1=new Mt,this.m_vertex2=new Mt,this.m_vertex0=new Mt,this.m_vertex3=new Mt,this.m_oneSided=!1}SetOneSided(t,e,s,i){return this.m_vertex0.Copy(t),this.m_vertex1.Copy(e),this.m_vertex2.Copy(s),this.m_vertex3.Copy(i),this.m_oneSided=!0,this}SetTwoSided(t,e){return this.m_vertex1.Copy(t),this.m_vertex2.Copy(e),this.m_oneSided=!1,this}Clone(){return(new Je).Copy(this)}Copy(t){return super.Copy(t),this.m_vertex1.Copy(t.m_vertex1),this.m_vertex2.Copy(t.m_vertex2),this.m_vertex0.Copy(t.m_vertex0),this.m_vertex3.Copy(t.m_vertex3),this.m_oneSided=t.m_oneSided,this}GetChildCount(){return 1}TestPoint(t,e){return!1}ComputeDistance(t,e,s,i){const n=Rt.MulXV(t,this.m_vertex1,Je.ComputeDistance_s_v1),o=Rt.MulXV(t,this.m_vertex2,Je.ComputeDistance_s_v2),r=Mt.SubVV(e,n,Je.ComputeDistance_s_d),a=Mt.SubVV(o,n,Je.ComputeDistance_s_s),h=Mt.DotVV(r,a);if(h>0){const t=Mt.DotVV(a,a);h>t?Mt.SubVV(e,o,r):r.SelfMulSub(h/t,a)}return s.Copy(r),s.Normalize()}RayCast(t,e,s,i){const n=Rt.MulTXV(s,e.p1,Je.RayCast_s_p1),o=Rt.MulTXV(s,e.p2,Je.RayCast_s_p2),r=Mt.SubVV(o,n,Je.RayCast_s_d),a=this.m_vertex1,h=this.m_vertex2,l=Mt.SubVV(h,a,Je.RayCast_s_e),_=t.normal.Set(l.y,-l.x).SelfNormalize(),m=Mt.DotVV(_,Mt.SubVV(a,n,Mt.s_t0));if(this.m_oneSided&&m>0)return!1;const c=Mt.DotVV(_,r);if(0===c)return!1;const u=m/c;if(u<0||e.maxFraction<u)return!1;const d=Mt.AddVMulSV(n,u,r,Je.RayCast_s_q),f=Mt.SubVV(h,a,Je.RayCast_s_r),p=Mt.DotVV(f,f);if(0===p)return!1;const y=Mt.DotVV(Mt.SubVV(d,a,Mt.s_t0),f)/p;return!(y<0||1<y)&&(t.fraction=u,Lt.MulRV(s.q,t.normal,t.normal),m>0&&t.normal.SelfNeg(),!0)}ComputeAABB(t,e,s){const i=Rt.MulXV(e,this.m_vertex1,Je.ComputeAABB_s_v1),n=Rt.MulXV(e,this.m_vertex2,Je.ComputeAABB_s_v2);Mt.MinV(i,n,t.lowerBound),Mt.MaxV(i,n,t.upperBound);const o=this.m_radius;t.lowerBound.SelfSubXY(o,o),t.upperBound.SelfAddXY(o,o)}ComputeMass(t,e){t.mass=0,Mt.MidVV(this.m_vertex1,this.m_vertex2,t.center),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertex1),t.m_vertices[1].Copy(this.m_vertex2),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){return i.SetZero(),0}Dump(t){t("    const shape: b2EdgeShape = new b2EdgeShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_vertex0.Set(%.15f, %.15f);\n",this.m_vertex0.x,this.m_vertex0.y),t("    shape.m_vertex1.Set(%.15f, %.15f);\n",this.m_vertex1.x,this.m_vertex1.y),t("    shape.m_vertex2.Set(%.15f, %.15f);\n",this.m_vertex2.x,this.m_vertex2.y),t("    shape.m_vertex3.Set(%.15f, %.15f);\n",this.m_vertex3.x,this.m_vertex3.y),t("    shape.m_oneSided = %s;\n",this.m_oneSided)}}Je.ComputeDistance_s_v1=new Mt,Je.ComputeDistance_s_v2=new Mt,Je.ComputeDistance_s_d=new Mt,Je.ComputeDistance_s_s=new Mt,Je.RayCast_s_p1=new Mt,Je.RayCast_s_p2=new Mt,Je.RayCast_s_d=new Mt,Je.RayCast_s_e=new Mt,Je.RayCast_s_q=new Mt,Je.RayCast_s_r=new Mt,Je.ComputeAABB_s_v1=new Mt,Je.ComputeAABB_s_v2=new Mt;class Xe extends je{constructor(){super(Ne.e_chainShape,A),this.m_vertices=[],this.m_count=0,this.m_prevVertex=new Mt,this.m_nextVertex=new Mt}CreateLoop(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._CreateLoop(t=>({x:e[2*t],y:e[2*t+1]}),e.length/2)}{const e=t[0],s=t[1]||e.length;return this._CreateLoop(t=>e[t],s)}}_CreateLoop(t,e){if(e<3)return this;this.m_count=e+1,this.m_vertices=Mt.MakeArray(this.m_count);for(let s=0;s<e;++s)this.m_vertices[s].Copy(t(s));return this.m_vertices[e].Copy(this.m_vertices[0]),this.m_prevVertex.Copy(this.m_vertices[this.m_count-2]),this.m_nextVertex.Copy(this.m_vertices[1]),this}CreateChain(...t){if("number"==typeof t[0][0]){const e=t[0],s=t[1],i=t[2];if(e.length%2!=0)throw new Error;return this._CreateChain(t=>({x:e[2*t],y:e[2*t+1]}),e.length/2,s,i)}{const e=t[0],s=t[1]||e.length,i=t[2],n=t[3];return this._CreateChain(t=>e[t],s,i,n)}}_CreateChain(t,e,s,i){this.m_count=e,this.m_vertices=Mt.MakeArray(e);for(let s=0;s<e;++s)this.m_vertices[s].Copy(t(s));return this.m_prevVertex.Copy(s),this.m_nextVertex.Copy(i),this}Clone(){return(new Xe).Copy(this)}Copy(t){return super.Copy(t),this._CreateChain(e=>t.m_vertices[e],t.m_count,t.m_prevVertex,t.m_nextVertex),this.m_prevVertex.Copy(t.m_prevVertex),this.m_nextVertex.Copy(t.m_nextVertex),this}GetChildCount(){return this.m_count-1}GetChildEdge(t,e){t.m_radius=this.m_radius,t.m_vertex1.Copy(this.m_vertices[e]),t.m_vertex2.Copy(this.m_vertices[e+1]),t.m_oneSided=!0,e>0?t.m_vertex0.Copy(this.m_vertices[e-1]):t.m_vertex0.Copy(this.m_prevVertex),e<this.m_count-2?t.m_vertex3.Copy(this.m_vertices[e+2]):t.m_vertex3.Copy(this.m_nextVertex)}TestPoint(t,e){return!1}ComputeDistance(t,e,s,i){const n=Xe.ComputeDistance_s_edgeShape;return this.GetChildEdge(n,i),n.ComputeDistance(t,e,s,0)}RayCast(t,e,s,i){const n=Xe.RayCast_s_edgeShape;return n.m_vertex1.Copy(this.m_vertices[i]),n.m_vertex2.Copy(this.m_vertices[(i+1)%this.m_count]),n.RayCast(t,e,s,0)}ComputeAABB(t,e,s){const i=this.m_vertices[s],n=this.m_vertices[(s+1)%this.m_count],o=Rt.MulXV(e,i,Xe.ComputeAABB_s_v1),r=Rt.MulXV(e,n,Xe.ComputeAABB_s_v2),a=Mt.MinV(o,r,Xe.ComputeAABB_s_lower),h=Mt.MaxV(o,r,Xe.ComputeAABB_s_upper);t.lowerBound.x=a.x-this.m_radius,t.lowerBound.y=a.y-this.m_radius,t.upperBound.x=h.x+this.m_radius,t.upperBound.y=h.y+this.m_radius}ComputeMass(t,e){t.mass=0,t.center.SetZero(),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertices[e]),e+1<this.m_count?t.m_vertices[1].Copy(this.m_vertices[e+1]):t.m_vertices[1].Copy(this.m_vertices[0]),t.m_count=2,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){return i.SetZero(),0}Dump(t){t("    const shape: b2ChainShape = new b2ChainShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new bVec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.CreateChain(vs, %d);\n",this.m_count),t("    shape.m_prevVertex.Set(%.15f, %.15f);\n",this.m_prevVertex.x,this.m_prevVertex.y),t("    shape.m_nextVertex.Set(%.15f, %.15f);\n",this.m_nextVertex.x,this.m_nextVertex.y)}}Xe.ComputeDistance_s_edgeShape=new Je,Xe.RayCast_s_edgeShape=new Je,Xe.ComputeAABB_s_v1=new Mt,Xe.ComputeAABB_s_v2=new Mt,Xe.ComputeAABB_s_lower=new Mt,Xe.ComputeAABB_s_upper=new Mt;class Oe extends je{constructor(t=0){super(Ne.e_circleShape,t),this.m_p=new Mt}Set(t,e=this.m_radius){return this.m_p.Copy(t),this.m_radius=e,this}Clone(){return(new Oe).Copy(this)}Copy(t){return super.Copy(t),this.m_p.Copy(t.m_p),this}GetChildCount(){return 1}TestPoint(t,e){const s=Rt.MulXV(t,this.m_p,Oe.TestPoint_s_center),i=Mt.SubVV(e,s,Oe.TestPoint_s_d);return Mt.DotVV(i,i)<=ut(this.m_radius)}ComputeDistance(t,e,s,i){const n=Rt.MulXV(t,this.m_p,Oe.ComputeDistance_s_center);return Mt.SubVV(e,n,s),s.Normalize()-this.m_radius}RayCast(t,e,s,i){const n=Rt.MulXV(s,this.m_p,Oe.RayCast_s_position),o=Mt.SubVV(e.p1,n,Oe.RayCast_s_s),r=Mt.DotVV(o,o)-ut(this.m_radius),a=Mt.SubVV(e.p2,e.p1,Oe.RayCast_s_r),h=Mt.DotVV(o,a),l=Mt.DotVV(a,a),_=h*h-l*r;if(_<0||l<m)return!1;let c=-(h+ft(_));return 0<=c&&c<=e.maxFraction*l&&(c/=l,t.fraction=c,Mt.AddVMulSV(o,c,a,t.normal).SelfNormalize(),!0)}ComputeAABB(t,e,s){const i=Rt.MulXV(e,this.m_p,Oe.ComputeAABB_s_p);t.lowerBound.Set(i.x-this.m_radius,i.y-this.m_radius),t.upperBound.Set(i.x+this.m_radius,i.y+this.m_radius)}ComputeMass(t,e){const s=ut(this.m_radius);t.mass=e*u*s,t.center.Copy(this.m_p),t.I=t.mass*(.5*s+Mt.DotVV(this.m_p,this.m_p))}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_p),t.m_count=1,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){const n=Rt.MulXV(s,this.m_p,new Mt),o=-(Mt.DotVV(t,n)-e);if(o<-this.m_radius+m)return 0;if(o>this.m_radius)return i.Copy(n),u*this.m_radius*this.m_radius;const r=this.m_radius*this.m_radius,a=o*o,h=r*(Ct(o/this.m_radius)+u/2)+o*ft(r-a),l=-2/3*pt(r-a,1.5)/h;return i.x=n.x+t.x*l,i.y=n.y+t.y*l,h}Dump(t){t("    const shape: b2CircleShape = new b2CircleShape();\n"),t("    shape.m_radius = %.15f;\n",this.m_radius),t("    shape.m_p.Set(%.15f, %.15f);\n",this.m_p.x,this.m_p.y)}}Oe.TestPoint_s_center=new Mt,Oe.TestPoint_s_d=new Mt,Oe.ComputeDistance_s_center=new Mt,Oe.RayCast_s_position=new Mt,Oe.RayCast_s_s=new Mt,Oe.RayCast_s_r=new Mt,Oe.ComputeAABB_s_p=new Mt;const Ze=new Mt,Ue=new Mt;function We(t,e,s,i,n){t.pointCount=0;const o=Rt.MulXV(s,e.m_p,Ze),r=Rt.MulXV(n,i.m_p,Ue),a=Mt.DistanceSquaredVV(o,r),h=e.m_radius+i.m_radius;a>h*h||(t.type=ye.e_circles,t.localPoint.Copy(e.m_p),t.localNormal.SetZero(),t.pointCount=1,t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0)}const Qe=new Mt,Ye=new Mt,Ke=new Mt;function He(t,e,s,i,n){t.pointCount=0;const o=Rt.MulXV(n,i.m_p,Qe),r=Rt.MulTXV(s,o,Ye);let a=0,h=-_;const l=e.m_radius+i.m_radius,c=e.m_count,u=e.m_vertices,d=e.m_normals;for(let t=0;t<c;++t){const e=Mt.DotVV(d[t],Mt.SubVV(r,u[t],Mt.s_t0));if(e>l)return;e>h&&(h=e,a=t)}const f=a,p=(f+1)%c,y=u[f],x=u[p];if(h<m)return t.pointCount=1,t.type=ye.e_faceA,t.localNormal.Copy(d[a]),Mt.MidVV(y,x,t.localPoint),t.points[0].localPoint.Copy(i.m_p),void(t.points[0].id.key=0);const B=Mt.DotVV(Mt.SubVV(r,y,Mt.s_t0),Mt.SubVV(x,y,Mt.s_t1)),S=Mt.DotVV(Mt.SubVV(r,x,Mt.s_t0),Mt.SubVV(y,x,Mt.s_t1));if(B<=0){if(Mt.DistanceSquaredVV(r,y)>l*l)return;t.pointCount=1,t.type=ye.e_faceA,Mt.SubVV(r,y,t.localNormal).SelfNormalize(),t.localPoint.Copy(y),t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0}else if(S<=0){if(Mt.DistanceSquaredVV(r,x)>l*l)return;t.pointCount=1,t.type=ye.e_faceA,Mt.SubVV(r,x,t.localNormal).SelfNormalize(),t.localPoint.Copy(x),t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0}else{const e=Mt.MidVV(y,x,Ke);if(Mt.DotVV(Mt.SubVV(r,e,Mt.s_t1),d[f])>l)return;t.pointCount=1,t.type=ye.e_faceA,t.localNormal.Copy(d[f]).SelfNormalize(),t.localPoint.Copy(e),t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0}}const $e=new Mt,ts=new Mt,es=new Mt,ss=new Mt,is=new Mt,ns=new Mt,os=new Mt,rs=new Se;function as(t,e,s,i,n){t.pointCount=0;const o=Rt.MulTXV(s,Rt.MulXV(n,i.m_p,Mt.s_t0),$e),r=e.m_vertex1,a=e.m_vertex2,h=Mt.SubVV(a,r,ts),l=os.Set(h.y,-h.x),_=Mt.DotVV(l,Mt.SubVV(o,r,Mt.s_t0));if(e.m_oneSided&&_<0)return;const m=Mt.DotVV(h,Mt.SubVV(a,o,Mt.s_t0)),c=Mt.DotVV(h,Mt.SubVV(o,r,Mt.s_t0)),u=e.m_radius+i.m_radius,d=rs;if(d.cf.indexB=0,d.cf.typeB=pe.e_vertex,c<=0){const s=r,n=Mt.SubVV(o,s,es);if(Mt.DotVV(n,n)>u*u)return;if(e.m_oneSided){const t=e.m_vertex0,s=r,i=Mt.SubVV(s,t,ss);if(Mt.DotVV(i,Mt.SubVV(s,o,Mt.s_t0))>0)return}return d.cf.indexA=0,d.cf.typeA=pe.e_vertex,t.pointCount=1,t.type=ye.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(s),t.points[0].id.Copy(d),void t.points[0].localPoint.Copy(i.m_p)}if(m<=0){const s=a,n=Mt.SubVV(o,s,es);if(Mt.DotVV(n,n)>u*u)return;if(e.m_oneSided){const t=e.m_vertex3,s=a,i=Mt.SubVV(t,s,is);if(Mt.DotVV(i,Mt.SubVV(o,s,Mt.s_t0))>0)return}return d.cf.indexA=1,d.cf.typeA=pe.e_vertex,t.pointCount=1,t.type=ye.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(s),t.points[0].id.Copy(d),void t.points[0].localPoint.Copy(i.m_p)}const f=Mt.DotVV(h,h),p=ns;p.x=1/f*(m*r.x+c*a.x),p.y=1/f*(m*r.y+c*a.y);const y=Mt.SubVV(o,p,es);Mt.DotVV(y,y)>u*u||(_<0&&l.Set(-l.x,-l.y),l.Normalize(),d.cf.indexA=0,d.cf.typeA=pe.e_face,t.pointCount=1,t.type=ye.e_faceA,t.localNormal.Copy(l),t.localPoint.Copy(r),t.points[0].id.Copy(d),t.points[0].localPoint.Copy(i.m_p))}var hs;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_edgeA=1]="e_edgeA",t[t.e_edgeB=2]="e_edgeB"}(hs||(hs={}));class ls{constructor(){this.normal=new Mt,this.type=hs.e_unknown,this.index=0,this.separation=0}}const _s=new ls,ms=[new Mt,new Mt];const cs=new ls,us=new Mt;const ds=new Rt,fs=new Mt,ps=new Mt,ys=new Mt,xs=new Mt,Bs=new Mt,Ss=new Mt,As=new Mt,Cs=new class{constructor(){this.vertices=[],this.normals=[],this.count=0}},Vs=new class{constructor(){this.i1=0,this.i2=0,this.v1=new Mt,this.v2=new Mt,this.normal=new Mt,this.sideNormal1=new Mt,this.sideOffset1=0,this.sideNormal2=new Mt,this.sideOffset2=0}},gs=[new we,new we],ws=[new we,new we],vs=[new we,new we];function bs(t,e,s,i,n){t.pointCount=0;const o=Rt.MulTXX(s,n,ds),r=Rt.MulXV(o,i.m_centroid,fs),a=e.m_vertex1,h=e.m_vertex2,l=Mt.SubVV(h,a,ps);l.Normalize();const _=ys.Set(l.y,-l.x),m=Mt.DotVV(_,Mt.SubVV(r,a,Mt.s_t0)),c=e.m_oneSided;if(c&&m<0)return;const u=Cs;u.count=i.m_count;for(let t=0;t<i.m_count;++t)u.vertices.length<=t&&u.vertices.push(new Mt),u.normals.length<=t&&u.normals.push(new Mt),Rt.MulXV(o,i.m_vertices[t],u.vertices[t]),Lt.MulRV(o.q,i.m_normals[t],u.normals[t]);const d=i.m_radius+e.m_radius,f=function(t,e,s){const i=_s;i.type=hs.e_edgeA,i.index=-1,i.separation=-Number.MAX_VALUE,i.normal.SetZero();const n=ms;n[0].Copy(s),n[1].Copy(s).SelfNeg();for(let s=0;s<2;++s){let o=Number.MAX_VALUE;for(let i=0;i<t.count;++i){const r=Mt.DotVV(n[s],Mt.SubVV(t.vertices[i],e,Mt.s_t0));r<o&&(o=r)}o>i.separation&&(i.index=s,i.separation=o,i.normal.Copy(n[s]))}return i}(u,a,_);if(f.separation>d)return;const y=function(t,e,s){const i=cs;i.type=hs.e_unknown,i.index=-1,i.separation=-Number.MAX_VALUE,i.normal.SetZero();for(let n=0;n<t.count;++n){const o=Mt.NegV(t.normals[n],us),r=ht(Mt.DotVV(o,Mt.SubVV(t.vertices[n],e,Mt.s_t0)),Mt.DotVV(o,Mt.SubVV(t.vertices[n],s,Mt.s_t0)));r>i.separation&&(i.type=hs.e_edgeB,i.index=n,i.separation=r,i.normal.Copy(o))}return i}(u,a,h);if(y.separation>d)return;let x;if(x=y.separation-d>.98*(f.separation-d)+.001?y:f,c){const t=Mt.SubVV(a,e.m_vertex0,xs);t.Normalize();const s=Bs.Set(t.y,-t.x),i=Mt.CrossVV(t,l)>=0,n=Mt.SubVV(e.m_vertex3,h,Ss);n.Normalize();const o=As.Set(n.y,-n.x),r=Mt.CrossVV(l,n)>=0,_=.1;if(Mt.DotVV(x.normal,l)<=0)if(i){if(Mt.CrossVV(x.normal,s)>_)return}else x=f;else if(r){if(Mt.CrossVV(o,x.normal)>_)return}else x=f}const B=gs,S=Vs;if(x.type===hs.e_edgeA){t.type=ye.e_faceA;let e=0,s=Mt.DotVV(x.normal,u.normals[0]);for(let t=1;t<u.count;++t){const i=Mt.DotVV(x.normal,u.normals[t]);i<s&&(s=i,e=t)}const i=e,n=i+1<u.count?i+1:0;B[0].v.Copy(u.vertices[i]),B[0].id.cf.indexA=0,B[0].id.cf.indexB=i,B[0].id.cf.typeA=pe.e_face,B[0].id.cf.typeB=pe.e_vertex,B[1].v.Copy(u.vertices[n]),B[1].id.cf.indexA=0,B[1].id.cf.indexB=n,B[1].id.cf.typeA=pe.e_face,B[1].id.cf.typeB=pe.e_vertex,S.i1=0,S.i2=1,S.v1.Copy(a),S.v2.Copy(h),S.normal.Copy(x.normal),S.sideNormal1.Copy(l).SelfNeg(),S.sideNormal2.Copy(l)}else t.type=ye.e_faceB,B[0].v.Copy(h),B[0].id.cf.indexA=1,B[0].id.cf.indexB=x.index,B[0].id.cf.typeA=pe.e_vertex,B[0].id.cf.typeB=pe.e_face,B[1].v.Copy(a),B[1].id.cf.indexA=0,B[1].id.cf.indexB=x.index,B[1].id.cf.typeA=pe.e_vertex,B[1].id.cf.typeB=pe.e_face,S.i1=x.index,S.i2=S.i1+1<u.count?S.i1+1:0,S.v1.Copy(u.vertices[S.i1]),S.v2.Copy(u.vertices[S.i2]),S.normal.Copy(u.normals[S.i1]),S.sideNormal1.Set(S.normal.y,-S.normal.x),S.sideNormal2.Copy(S.sideNormal1).SelfNeg();S.sideOffset1=Mt.DotVV(S.sideNormal1,S.v1),S.sideOffset2=Mt.DotVV(S.sideNormal2,S.v2);const A=ws,C=vs;let V;if(V=Ie(A,B,S.sideNormal1,S.sideOffset1,S.i1),V<p)return;if(V=Ie(C,A,S.sideNormal2,S.sideOffset2,S.i2),V<p)return;x.type===hs.e_edgeA?(t.localNormal.Copy(S.normal),t.localPoint.Copy(S.v1)):(t.localNormal.Copy(i.m_normals[S.i1]),t.localPoint.Copy(i.m_vertices[S.i1]));let g=0;for(let e=0;e<p;++e){if(Mt.DotVV(S.normal,Mt.SubVV(C[e].v,S.v1,Mt.s_t0))<=d){const s=t.points[g];x.type===hs.e_edgeA?(Rt.MulTXV(o,C[e].v,s.localPoint),s.id.Copy(C[e].id)):(s.localPoint.Copy(C[e].v),s.id.cf.typeA=C[e].id.cf.typeB,s.id.cf.typeB=C[e].id.cf.typeA,s.id.cf.indexA=C[e].id.cf.indexB,s.id.cf.indexB=C[e].id.cf.indexA),++g}}t.pointCount=g}const Ms=new Rt,Ps=new Mt,Is=new Mt;function Gs(t,e,s,i,n){const o=e.m_count,r=i.m_count,a=e.m_normals,h=e.m_vertices,l=i.m_vertices,m=Rt.MulTXX(n,s,Ms);let c=0,u=-_;for(let t=0;t<o;++t){const e=Lt.MulRV(m.q,a[t],Ps),s=Rt.MulXV(m,h[t],Is);let i=_;for(let t=0;t<r;++t){const n=Mt.DotVV(e,Mt.SubVV(l[t],s,Mt.s_t0));n<i&&(i=n)}i>u&&(u=i,c=t)}return t[0]=c,u}const Ds=new Mt;const Fs=[new we,new we],Ls=[new we,new we],Rs=[new we,new we],Ts=[0],ks=[0],qs=new Mt,zs=new Mt,Es=new Mt,Ns=new Mt,js=new Mt,Js=new Mt,Xs=new Mt,Os=new Mt;function Zs(t,e,s,i,n){t.pointCount=0;const o=e.m_radius+i.m_radius,r=Ts;r[0]=0;const a=Gs(r,e,s,i,n);if(a>o)return;const h=ks;h[0]=0;const l=Gs(h,i,n,e,s);if(l>o)return;let m,c,u,d,f=0,y=0;l>a+.1*B?(m=i,c=e,u=n,d=s,f=h[0],t.type=ye.e_faceB,y=1):(m=e,c=i,u=s,d=n,f=r[0],t.type=ye.e_faceA,y=0);const x=Fs;!function(t,e,s,i,n,o){const r=e.m_normals,a=n.m_count,h=n.m_vertices,l=n.m_normals,m=Lt.MulTRV(o.q,Lt.MulRV(s.q,r[i],Mt.s_t0),Ds);let c=0,u=_;for(let t=0;t<a;++t){const e=Mt.DotVV(m,l[t]);e<u&&(u=e,c=t)}const d=c,f=d+1<a?d+1:0,p=t[0];Rt.MulXV(o,h[d],p.v);const y=p.id.cf;y.indexA=i,y.indexB=d,y.typeA=pe.e_face,y.typeB=pe.e_vertex;const x=t[1];Rt.MulXV(o,h[f],x.v);const B=x.id.cf;B.indexA=i,B.indexB=f,B.typeA=pe.e_face,B.typeB=pe.e_vertex}(x,m,u,f,c,d);const S=m.m_count,A=m.m_vertices,C=f,V=f+1<S?f+1:0,g=A[C],w=A[V],v=Mt.SubVV(w,g,qs);v.Normalize();const b=Mt.CrossVOne(v,zs),M=Mt.MidVV(g,w,Es),P=Lt.MulRV(u.q,v,js),I=Mt.CrossVOne(P,Ns),G=Rt.MulXV(u,g,Xs),D=Rt.MulXV(u,w,Os),F=Mt.DotVV(I,G),L=-Mt.DotVV(P,G)+o,R=Mt.DotVV(P,D)+o,T=Ls,k=Rs;let q;if(q=Ie(T,x,Mt.NegV(P,Js),L,C),q<2)return;if(q=Ie(k,T,P,R,V),q<2)return;t.localNormal.Copy(b),t.localPoint.Copy(M);let z=0;for(let e=0;e<p;++e){const s=k[e];if(Mt.DotVV(I,s.v)-F<=o){const e=t.points[z];if(Rt.MulTXV(d,s.v,e.localPoint),e.id.Copy(s.id),y){const t=e.id.cf;e.id.cf.indexA=t.indexB,e.id.cf.indexB=t.indexA,e.id.cf.typeA=t.typeB,e.id.cf.typeB=t.typeA}++z}}t.pointCount=z}class Us extends je{constructor(){super(Ne.e_polygonShape,A),this.m_centroid=new Mt(0,0),this.m_vertices=[],this.m_normals=[],this.m_count=0}Clone(){return(new Us).Copy(this)}Copy(t){super.Copy(t),this.m_centroid.Copy(t.m_centroid),this.m_count=t.m_count,this.m_vertices=Mt.MakeArray(this.m_count),this.m_normals=Mt.MakeArray(this.m_count);for(let e=0;e<this.m_count;++e)this.m_vertices[e].Copy(t.m_vertices[e]),this.m_normals[e].Copy(t.m_normals[e]);return this}GetChildCount(){return 1}Set(...t){if("number"==typeof t[0][0]){const e=t[0];if(e.length%2!=0)throw new Error;return this._Set(t=>({x:e[2*t],y:e[2*t+1]}),e.length/2)}{const e=t[0],s=t[1]||e.length;return this._Set(t=>e[t],s)}}_Set(t,e){if(e<3)return this.SetAsBox(1,1);let s=e;const i=[];for(let e=0;e<s;++e){const s=t(e);let n=!0;for(let t=0;t<i.length;++t)if(Mt.DistanceSquaredVV(s,i[t])<.5*B*(.5*B)){n=!1;break}n&&i.push(s)}if(s=i.length,s<3)return this.SetAsBox(1,1);let n=0,o=i[0].x;for(let t=1;t<s;++t){const e=i[t].x;(e>o||e===o&&i[t].y<i[n].y)&&(n=t,o=e)}const r=[];let a=0,h=n;for(;;){r[a]=h;let t=0;for(let e=1;e<s;++e){if(t===h){t=e;continue}const s=Mt.SubVV(i[t],i[r[a]],Us.Set_s_r),n=Mt.SubVV(i[e],i[r[a]],Us.Set_s_v),o=Mt.CrossVV(s,n);o<0&&(t=e),0===o&&n.LengthSquared()>s.LengthSquared()&&(t=e)}if(++a,h=t,t===n)break}this.m_count=a,this.m_vertices=Mt.MakeArray(this.m_count),this.m_normals=Mt.MakeArray(this.m_count);for(let t=0;t<a;++t)this.m_vertices[t].Copy(i[r[t]]);for(let t=0;t<a;++t){const e=this.m_vertices[t],s=this.m_vertices[(t+1)%a],i=Mt.SubVV(s,e,Mt.s_t0);Mt.CrossVOne(i,this.m_normals[t]).SelfNormalize()}return Us.ComputeCentroid(this.m_vertices,a,this.m_centroid),this}SetAsBox(t,e,s,i=0){if(this.m_count=4,this.m_vertices=Mt.MakeArray(this.m_count),this.m_normals=Mt.MakeArray(this.m_count),this.m_vertices[0].Set(-t,-e),this.m_vertices[1].Set(t,-e),this.m_vertices[2].Set(t,e),this.m_vertices[3].Set(-t,e),this.m_normals[0].Set(0,-1),this.m_normals[1].Set(1,0),this.m_normals[2].Set(0,1),this.m_normals[3].Set(-1,0),this.m_centroid.SetZero(),s){this.m_centroid.Copy(s);const t=new Rt;t.SetPosition(s),t.SetRotationAngle(i);for(let e=0;e<this.m_count;++e)Rt.MulXV(t,this.m_vertices[e],this.m_vertices[e]),Lt.MulRV(t.q,this.m_normals[e],this.m_normals[e])}return this}TestPoint(t,e){const s=Rt.MulTXV(t,e,Us.TestPoint_s_pLocal);for(let t=0;t<this.m_count;++t){if(Mt.DotVV(this.m_normals[t],Mt.SubVV(s,this.m_vertices[t],Mt.s_t0))>0)return!1}return!0}ComputeDistance(t,e,s,i){const n=Rt.MulTXV(t,e,Us.ComputeDistance_s_pLocal);let o=-_;const r=Us.ComputeDistance_s_normalForMaxDistance.Copy(n);for(let t=0;t<this.m_count;++t){const e=Mt.DotVV(this.m_normals[t],Mt.SubVV(n,this.m_vertices[t],Mt.s_t0));e>o&&(o=e,r.Copy(this.m_normals[t]))}if(o>0){const e=Us.ComputeDistance_s_minDistance.Copy(r);let i=o*o;for(let t=0;t<this.m_count;++t){const s=Mt.SubVV(n,this.m_vertices[t],Us.ComputeDistance_s_distance),o=s.LengthSquared();i>o&&(e.Copy(s),i=o)}return Lt.MulRV(t.q,e,s),s.Normalize(),Math.sqrt(i)}return Lt.MulRV(t.q,r,s),o}RayCast(t,e,s,i){const n=Rt.MulTXV(s,e.p1,Us.RayCast_s_p1),o=Rt.MulTXV(s,e.p2,Us.RayCast_s_p2),r=Mt.SubVV(o,n,Us.RayCast_s_d);let a=0,h=e.maxFraction,l=-1;for(let t=0;t<this.m_count;++t){const e=Mt.DotVV(this.m_normals[t],Mt.SubVV(this.m_vertices[t],n,Mt.s_t0)),s=Mt.DotVV(this.m_normals[t],r);if(0===s){if(e<0)return!1}else s<0&&e<a*s?(a=e/s,l=t):s>0&&e<h*s&&(h=e/s);if(h<a)return!1}return l>=0&&(t.fraction=a,Lt.MulRV(s.q,this.m_normals[l],t.normal),!0)}ComputeAABB(t,e,s){const i=Rt.MulXV(e,this.m_vertices[0],t.lowerBound),n=t.upperBound.Copy(i);for(let t=0;t<this.m_count;++t){const s=Rt.MulXV(e,this.m_vertices[t],Us.ComputeAABB_s_v);Mt.MinV(s,i,i),Mt.MaxV(s,n,n)}const o=this.m_radius;i.SelfSubXY(o,o),n.SelfAddXY(o,o)}ComputeMass(t,e){const s=Us.ComputeMass_s_center.SetZero();let i=0,n=0;const o=Us.ComputeMass_s_s.Copy(this.m_vertices[0]);for(let t=0;t<this.m_count;++t){const e=Mt.SubVV(this.m_vertices[t],o,Us.ComputeMass_s_e1),r=Mt.SubVV(this.m_vertices[(t+1)%this.m_count],o,Us.ComputeMass_s_e2),a=Mt.CrossVV(e,r),h=.5*a;i+=h,s.SelfAdd(Mt.MulSV(h*(1/3),Mt.AddVV(e,r,Mt.s_t0),Mt.s_t1));const l=e.x,_=e.y,m=r.x,c=r.y;n+=1/3*.25*a*(l*l+m*l+m*m+(_*_+c*_+c*c))}t.mass=e*i,s.SelfMul(1/i),Mt.AddVV(s,o,t.center),t.I=e*n,t.I+=t.mass*(Mt.DotVV(t.center,t.center)-Mt.DotVV(s,s))}Validate(){for(let t=0;t<this.m_count;++t){const e=t,s=(t+1)%this.m_count,i=this.m_vertices[e],n=Mt.SubVV(this.m_vertices[s],i,Us.Validate_s_e);for(let t=0;t<this.m_count;++t){if(t===e||t===s)continue;const o=Mt.SubVV(this.m_vertices[t],i,Us.Validate_s_v);if(Mt.CrossVV(n,o)<0)return!1}}return!0}SetupDistanceProxy(t,e){t.m_vertices=this.m_vertices,t.m_count=this.m_count,t.m_radius=this.m_radius}ComputeSubmergedArea(t,e,s,i){const n=Lt.MulTRV(s.q,t,Us.ComputeSubmergedArea_s_normalL),o=e-Mt.DotVV(t,s.p),r=[];let a=0,h=-1,l=-1,_=!1;for(let t=0;t<this.m_count;++t){r[t]=Mt.DotVV(n,this.m_vertices[t])-o;const e=r[t]<-m;t>0&&(e?_||(h=t-1,a++):_&&(l=t-1,a++)),_=e}switch(a){case 0:if(_){const t=Us.ComputeSubmergedArea_s_md;return this.ComputeMass(t,1),Rt.MulXV(s,t.center,i),t.mass}return 0;case 1:-1===h?h=this.m_count-1:l=this.m_count-1}const c=(h+1)%this.m_count,u=(l+1)%this.m_count,d=(0-r[h])/(r[c]-r[h]),f=(0-r[l])/(r[u]-r[l]),p=Us.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[h].x*(1-d)+this.m_vertices[c].x*d,this.m_vertices[h].y*(1-d)+this.m_vertices[c].y*d),y=Us.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[l].x*(1-f)+this.m_vertices[u].x*f,this.m_vertices[l].y*(1-f)+this.m_vertices[u].y*f);let x=0;const B=Us.ComputeSubmergedArea_s_center.SetZero();let S,A=this.m_vertices[c],C=c;for(;C!==u;){C=(C+1)%this.m_count,S=C===u?y:this.m_vertices[C];const t=.5*((A.x-p.x)*(S.y-p.y)-(A.y-p.y)*(S.x-p.x));x+=t,B.x+=t*(p.x+A.x+S.x)/3,B.y+=t*(p.y+A.y+S.y)/3,A=S}return B.SelfMul(1/x),Rt.MulXV(s,B,i),x}Dump(t){t("    const shape: b2PolygonShape = new b2PolygonShape();\n"),t("    const vs: b2Vec2[] = [];\n");for(let e=0;e<this.m_count;++e)t("    vs[%d] = new b2Vec2(%.15f, %.15f);\n",e,this.m_vertices[e].x,this.m_vertices[e].y);t("    shape.Set(vs, %d);\n",this.m_count)}static ComputeCentroid(t,e,s){const i=s;i.SetZero();let n=0;const o=Us.ComputeCentroid_s_s.Copy(t[0]);for(let s=0;s<e;++s){const r=Mt.SubVV(t[0],o,Us.ComputeCentroid_s_p1),a=Mt.SubVV(t[s],o,Us.ComputeCentroid_s_p2),h=Mt.SubVV(t[(s+1)%e],o,Us.ComputeCentroid_s_p3),l=Mt.SubVV(a,r,Us.ComputeCentroid_s_e1),_=Mt.SubVV(h,r,Us.ComputeCentroid_s_e2),m=.5*Mt.CrossVV(l,_);n+=m,i.x+=m*(1/3)*(r.x+a.x+h.x),i.y+=m*(1/3)*(r.y+a.y+h.y)}return i.x=1/n*i.x+o.x,i.y=1/n*i.y+o.y,i}}Us.Set_s_r=new Mt,Us.Set_s_v=new Mt,Us.TestPoint_s_pLocal=new Mt,Us.ComputeDistance_s_pLocal=new Mt,Us.ComputeDistance_s_normalForMaxDistance=new Mt,Us.ComputeDistance_s_minDistance=new Mt,Us.ComputeDistance_s_distance=new Mt,Us.RayCast_s_p1=new Mt,Us.RayCast_s_p2=new Mt,Us.RayCast_s_d=new Mt,Us.ComputeAABB_s_v=new Mt,Us.ComputeMass_s_center=new Mt,Us.ComputeMass_s_s=new Mt,Us.ComputeMass_s_e1=new Mt,Us.ComputeMass_s_e2=new Mt,Us.Validate_s_e=new Mt,Us.Validate_s_v=new Mt,Us.ComputeSubmergedArea_s_normalL=new Mt,Us.ComputeSubmergedArea_s_md=new Ee,Us.ComputeSubmergedArea_s_intoVec=new Mt,Us.ComputeSubmergedArea_s_outoVec=new Mt,Us.ComputeSubmergedArea_s_center=new Mt,Us.ComputeCentroid_s_s=new Mt,Us.ComputeCentroid_s_p1=new Mt,Us.ComputeCentroid_s_p2=new Mt,Us.ComputeCentroid_s_p3=new Mt,Us.ComputeCentroid_s_e1=new Mt,Us.ComputeCentroid_s_e2=new Mt;let Ws=0,Qs=0,Ys=0,Ks=0,Hs=0,$s=0,ti=0;function ei(){Ws=0,Qs=0,Ys=0,Ks=0,Hs=0,$s=0,ti=0}const si=new Rt,ii=new Rt,ni=new Mt,oi=new Mt,ri=new Mt,ai=new Mt,hi=new Mt;class li{constructor(){this.proxyA=new Et,this.proxyB=new Et,this.sweepA=new Tt,this.sweepB=new Tt,this.tMax=0}}var _i,mi;!function(t){t[t.e_unknown=0]="e_unknown",t[t.e_failed=1]="e_failed",t[t.e_overlapped=2]="e_overlapped",t[t.e_touching=3]="e_touching",t[t.e_separated=4]="e_separated"}(_i||(_i={}));class ci{constructor(){this.state=_i.e_unknown,this.t=0}}!function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_points=0]="e_points",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(mi||(mi={}));class ui{constructor(){this.m_sweepA=new Tt,this.m_sweepB=new Tt,this.m_type=mi.e_unknown,this.m_localPoint=new Mt,this.m_axis=new Mt}Initialize(t,e,s,i,n,o){this.m_proxyA=e,this.m_proxyB=i;const r=t.count;this.m_sweepA.Copy(s),this.m_sweepB.Copy(n);const a=si,h=ii;if(this.m_sweepA.GetTransform(a,o),this.m_sweepB.GetTransform(h,o),1===r){this.m_type=mi.e_points;const e=this.m_proxyA.GetVertex(t.indexA[0]),s=this.m_proxyB.GetVertex(t.indexB[0]),i=Rt.MulXV(a,e,ni),n=Rt.MulXV(h,s,oi);Mt.SubVV(n,i,this.m_axis);const o=this.m_axis.Normalize();return this.m_localPoint.SetZero(),o}if(t.indexA[0]===t.indexA[1]){this.m_type=mi.e_faceB;const e=this.m_proxyB.GetVertex(t.indexB[0]),s=this.m_proxyB.GetVertex(t.indexB[1]);Mt.CrossVOne(Mt.SubVV(s,e,Mt.s_t0),this.m_axis).SelfNormalize();const i=Lt.MulRV(h.q,this.m_axis,ri);Mt.MidVV(e,s,this.m_localPoint);const n=Rt.MulXV(h,this.m_localPoint,oi),o=this.m_proxyA.GetVertex(t.indexA[0]),r=Rt.MulXV(a,o,ni);let l=Mt.DotVV(Mt.SubVV(r,n,Mt.s_t0),i);return l<0&&(this.m_axis.SelfNeg(),l=-l),l}{this.m_type=mi.e_faceA;const e=this.m_proxyA.GetVertex(t.indexA[0]),s=this.m_proxyA.GetVertex(t.indexA[1]);Mt.CrossVOne(Mt.SubVV(s,e,Mt.s_t0),this.m_axis).SelfNormalize();const i=Lt.MulRV(a.q,this.m_axis,ri);Mt.MidVV(e,s,this.m_localPoint);const n=Rt.MulXV(a,this.m_localPoint,ni),o=this.m_proxyB.GetVertex(t.indexB[0]),r=Rt.MulXV(h,o,oi);let l=Mt.DotVV(Mt.SubVV(r,n,Mt.s_t0),i);return l<0&&(this.m_axis.SelfNeg(),l=-l),l}}FindMinSeparation(t,e,s){const i=si,n=ii;switch(this.m_sweepA.GetTransform(i,s),this.m_sweepB.GetTransform(n,s),this.m_type){case mi.e_points:{const s=Lt.MulTRV(i.q,this.m_axis,ai),o=Lt.MulTRV(n.q,Mt.NegV(this.m_axis,Mt.s_t0),hi);t[0]=this.m_proxyA.GetSupport(s),e[0]=this.m_proxyB.GetSupport(o);const r=this.m_proxyA.GetVertex(t[0]),a=this.m_proxyB.GetVertex(e[0]),h=Rt.MulXV(i,r,ni),l=Rt.MulXV(n,a,oi);return Mt.DotVV(Mt.SubVV(l,h,Mt.s_t0),this.m_axis)}case mi.e_faceA:{const s=Lt.MulRV(i.q,this.m_axis,ri),o=Rt.MulXV(i,this.m_localPoint,ni),r=Lt.MulTRV(n.q,Mt.NegV(s,Mt.s_t0),hi);t[0]=-1,e[0]=this.m_proxyB.GetSupport(r);const a=this.m_proxyB.GetVertex(e[0]),h=Rt.MulXV(n,a,oi);return Mt.DotVV(Mt.SubVV(h,o,Mt.s_t0),s)}case mi.e_faceB:{const s=Lt.MulRV(n.q,this.m_axis,ri),o=Rt.MulXV(n,this.m_localPoint,oi),r=Lt.MulTRV(i.q,Mt.NegV(s,Mt.s_t0),ai);e[0]=-1,t[0]=this.m_proxyA.GetSupport(r);const a=this.m_proxyA.GetVertex(t[0]),h=Rt.MulXV(i,a,ni);return Mt.DotVV(Mt.SubVV(h,o,Mt.s_t0),s)}default:return t[0]=-1,e[0]=-1,0}}Evaluate(t,e,s){const i=si,n=ii;switch(this.m_sweepA.GetTransform(i,s),this.m_sweepB.GetTransform(n,s),this.m_type){case mi.e_points:{const s=this.m_proxyA.GetVertex(t),o=this.m_proxyB.GetVertex(e),r=Rt.MulXV(i,s,ni),a=Rt.MulXV(n,o,oi);return Mt.DotVV(Mt.SubVV(a,r,Mt.s_t0),this.m_axis)}case mi.e_faceA:{const t=Lt.MulRV(i.q,this.m_axis,ri),s=Rt.MulXV(i,this.m_localPoint,ni),o=this.m_proxyB.GetVertex(e),r=Rt.MulXV(n,o,oi);return Mt.DotVV(Mt.SubVV(r,s,Mt.s_t0),t)}case mi.e_faceB:{const e=Lt.MulRV(n.q,this.m_axis,ri),s=Rt.MulXV(n,this.m_localPoint,oi),o=this.m_proxyA.GetVertex(t),r=Rt.MulXV(i,o,ni);return Mt.DotVV(Mt.SubVV(r,s,Mt.s_t0),e)}default:return 0}}}const di=new qt,fi=new Nt,pi=new jt,yi=new Jt,xi=new ui,Bi=[0],Si=[0],Ai=new Tt,Ci=new Tt;function Vi(t,e){const s=di.Reset();++Ys,t.state=_i.e_unknown,t.t=e.tMax;const i=e.proxyA,n=e.proxyB,o=lt(f,lt(i.m_count,n.m_count)),r=Ai.Copy(e.sweepA),a=Ci.Copy(e.sweepB);r.Normalize(),a.Normalize();const h=e.tMax,l=i.m_radius+n.m_radius,_=lt(B,l-3*B),m=.25*B;let c=0;let u=0;const d=fi;d.count=0;const p=pi;for(p.proxyA.Copy(e.proxyA),p.proxyB.Copy(e.proxyB),p.useRadii=!1;;){const e=si,s=ii;r.GetTransform(e,c),a.GetTransform(s,c),p.transformA.Copy(e),p.transformB.Copy(s);const l=yi;if(re(l,d,p),l.distance<=0){t.state=_i.e_overlapped,t.t=0;break}if(l.distance<_+m){t.state=_i.e_touching,t.t=c;break}const f=xi;f.Initialize(d,i,r,n,a,c);let y=!1,x=h,B=0;for(;;){const e=Bi,s=Si;let i=f.FindMinSeparation(e,s,x);if(i>_+m){t.state=_i.e_separated,t.t=h,y=!0;break}if(i>_-m){c=x;break}let n=f.Evaluate(e[0],s[0],c);if(n<_-m){t.state=_i.e_failed,t.t=c,y=!0;break}if(n<=_+m){t.state=_i.e_touching,t.t=c,y=!0;break}let r=0,a=c,l=x;for(;;){let t=0;t=1&r?a+(_-n)*(l-a)/(i-n):.5*(a+l),++r,++$s;const o=f.Evaluate(e[0],s[0],t);if(at(o-_)<m){x=t;break}if(o>_?(a=t,n=o):(l=t,i=o),50===r)break}if(ti=lt(ti,r),++B,B===o)break}if(++u,++Ks,y)break;if(20===u){t.state=_i.e_failed,t.t=c;break}}Hs=lt(Hs,u);const y=s.GetMilliseconds();Qs=lt(Qs,y),Ws+=y}var gi,wi;!function(t){t[t.e_unknownJoint=0]="e_unknownJoint",t[t.e_revoluteJoint=1]="e_revoluteJoint",t[t.e_prismaticJoint=2]="e_prismaticJoint",t[t.e_distanceJoint=3]="e_distanceJoint",t[t.e_pulleyJoint=4]="e_pulleyJoint",t[t.e_mouseJoint=5]="e_mouseJoint",t[t.e_gearJoint=6]="e_gearJoint",t[t.e_wheelJoint=7]="e_wheelJoint",t[t.e_weldJoint=8]="e_weldJoint",t[t.e_frictionJoint=9]="e_frictionJoint",t[t.e_ropeJoint=10]="e_ropeJoint",t[t.e_motorJoint=11]="e_motorJoint",t[t.e_areaJoint=12]="e_areaJoint"}(gi||(gi={}));class vi{constructor(){this.linear=new Mt,this.angularA=0,this.angularB=0}SetZero(){return this.linear.SetZero(),this.angularA=0,this.angularB=0,this}Set(t,e,s){return this.linear.Copy(t),this.angularA=e,this.angularB=s,this}}class bi{constructor(t){this._other=null,this.prev=null,this.next=null,this.joint=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class Mi{constructor(t){this.type=gi.e_unknownJoint,this.userData=null,this.collideConnected=!1,this.type=t}}function Pi(t,e,s,i,n){const o=i.GetMass(),r=n.GetMass();let a;a=o>0&&r>0?o*r/(o+r):o>0?o:r;const h=2*u*e;t.stiffness=a*h*h,t.damping=2*a*s*h}function Ii(t,e,s,i,n){const o=i.GetInertia(),r=n.GetInertia();let a;a=o>0&&r>0?o*r/(o+r):o>0?o:r;const h=2*u*e;t.stiffness=a*h*h,t.damping=2*a*s*h}class Gi{constructor(t){this.m_type=gi.e_unknownJoint,this.m_prev=null,this.m_next=null,this.m_edgeA=new bi(this),this.m_edgeB=new bi(this),this.m_index=0,this.m_islandFlag=!1,this.m_collideConnected=!1,this.m_userData=null,this.m_type=t.type,this.m_edgeA.other=t.bodyB,this.m_edgeB.other=t.bodyA,this.m_bodyA=t.bodyA,this.m_bodyB=t.bodyB,this.m_collideConnected=l(t.collideConnected,!1),this.m_userData=l(t.userData,null)}GetType(){return this.m_type}GetBodyA(){return this.m_bodyA}GetBodyB(){return this.m_bodyB}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}IsEnabled(){return this.m_bodyA.IsEnabled()&&this.m_bodyB.IsEnabled()}GetCollideConnected(){return this.m_collideConnected}Dump(t){t("// Dump is not supported for this joint type.\n")}ShiftOrigin(t){}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=e.p,n=s.p,o=this.GetAnchorA(Gi.Draw_s_p1),r=this.GetAnchorB(Gi.Draw_s_p2),a=Gi.Draw_s_color.SetRGB(.5,.8,.8);switch(this.m_type){case gi.e_distanceJoint:t.DrawSegment(o,r,a);break;case gi.e_pulleyJoint:{const e=this,s=e.GetGroundAnchorA(),i=e.GetGroundAnchorB();t.DrawSegment(s,o,a),t.DrawSegment(i,r,a),t.DrawSegment(s,i,a)}break;case gi.e_mouseJoint:{const e=Gi.Draw_s_c;e.Set(0,1,0),t.DrawPoint(o,4,e),t.DrawPoint(r,4,e),e.Set(.8,.8,.8),t.DrawSegment(o,r,e)}break;default:t.DrawSegment(i,o,a),t.DrawSegment(o,r,a),t.DrawSegment(n,r,a)}}}Gi.Draw_s_p1=new Mt,Gi.Draw_s_p2=new Mt,Gi.Draw_s_color=new n(.5,.8,.8),Gi.Draw_s_c=new n;class Di extends Mi{constructor(){super(gi.e_distanceJoint),this.localAnchorA=new Mt,this.localAnchorB=new Mt,this.length=1,this.minLength=0,this.maxLength=_,this.stiffness=0,this.damping=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(i,this.localAnchorB),this.length=lt(Mt.DistanceVV(s,i),B),this.minLength=this.length,this.maxLength=this.length}}class Fi extends Gi{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_length=0,this.m_minLength=0,this.m_maxLength=0,this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_gamma=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_indexA=0,this.m_indexB=0,this.m_u=new Mt,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_currentLength=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_softMass=0,this.m_mass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_localAnchorA.Copy(l(t.localAnchorA,Mt.ZERO)),this.m_localAnchorB.Copy(l(t.localAnchorB,Mt.ZERO)),this.m_length=lt(l(t.length,this.GetCurrentLength()),B),this.m_minLength=lt(l(t.minLength,this.m_length),B),this.m_maxLength=lt(l(t.maxLength,this.m_length),this.m_minLength),this.m_stiffness=l(t.stiffness,0),this.m_damping=l(t.damping,0)}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.x,e.y=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_u.y,e}GetReactionTorque(t){return 0}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetLength(t){return this.m_impulse=0,this.m_length=lt(B,t),this.m_length}GetLength(){return this.m_length}SetMinLength(t){return this.m_lowerImpulse=0,this.m_minLength=_t(t,B,this.m_maxLength),this.m_minLength}SetMaxLength(t){return this.m_upperImpulse=0,this.m_maxLength=lt(t,this.m_minLength),this.m_maxLength}GetCurrentLength(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,new Mt),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,new Mt);return Mt.DistanceVV(t,e)}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.length = %.15f;\n",this.m_length),t("  jd.minLength = %.15f;\n",this.m_minLength),t("  jd.maxLength = %.15f;\n",this.m_maxLength),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const l=this.m_qA.SetAngle(s),_=this.m_qB.SetAngle(r);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),Lt.MulRV(l,this.m_lalcA,this.m_rA),Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),Lt.MulRV(_,this.m_lalcB,this.m_rB),this.m_u.x=o.x+this.m_rB.x-e.x-this.m_rA.x,this.m_u.y=o.y+this.m_rB.y-e.y-this.m_rA.y,this.m_currentLength=this.m_u.Length(),this.m_currentLength>B?this.m_u.SelfMul(1/this.m_currentLength):(this.m_u.SetZero(),this.m_mass=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0);const m=Mt.CrossVV(this.m_rA,this.m_u),c=Mt.CrossVV(this.m_rB,this.m_u);let u=this.m_invMassA+this.m_invIA*m*m+this.m_invMassB+this.m_invIB*c*c;if(this.m_mass=0!==u?1/u:0,this.m_stiffness>0&&this.m_minLength<this.m_maxLength){const e=this.m_currentLength-this.m_length,s=this.m_damping,i=this.m_stiffness,n=t.step.dt;this.m_gamma=n*(s+n*i),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=e*n*i*this.m_gamma,u+=this.m_gamma,this.m_softMass=0!==u?1/u:0}else this.m_gamma=0,this.m_bias=0,this.m_softMass=this.m_mass;if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=Mt.MulSV(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse,this.m_u,Fi.InitVelocityConstraints_s_P);i.SelfMulSub(this.m_invMassA,e),n-=this.m_invIA*Mt.CrossVV(this.m_rA,e),a.SelfMulAdd(this.m_invMassB,e),h+=this.m_invIB*Mt.CrossVV(this.m_rB,e)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;if(this.m_minLength<this.m_maxLength){if(this.m_stiffness>0){const t=Mt.AddVCrossSV(e,s,this.m_rA,Fi.SolveVelocityConstraints_s_vpA),o=Mt.AddVCrossSV(i,n,this.m_rB,Fi.SolveVelocityConstraints_s_vpB),r=Mt.DotVV(this.m_u,Mt.SubVV(o,t,Mt.s_t0)),a=-this.m_softMass*(r+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=a;const h=Mt.MulSV(a,this.m_u,Fi.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,h),s-=this.m_invIA*Mt.CrossVV(this.m_rA,h),i.SelfMulAdd(this.m_invMassB,h),n+=this.m_invIB*Mt.CrossVV(this.m_rB,h)}{const o=lt(0,this.m_currentLength-this.m_minLength)*t.step.inv_dt,r=Mt.AddVCrossSV(e,s,this.m_rA,Fi.SolveVelocityConstraints_s_vpA),a=Mt.AddVCrossSV(i,n,this.m_rB,Fi.SolveVelocityConstraints_s_vpB),h=Mt.DotVV(this.m_u,Mt.SubVV(a,r,Mt.s_t0));let l=-this.m_mass*(h+o);const _=this.m_lowerImpulse;this.m_lowerImpulse=lt(0,this.m_lowerImpulse+l),l=this.m_lowerImpulse-_;const m=Mt.MulSV(l,this.m_u,Fi.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,m),s-=this.m_invIA*Mt.CrossVV(this.m_rA,m),i.SelfMulAdd(this.m_invMassB,m),n+=this.m_invIB*Mt.CrossVV(this.m_rB,m)}{const o=lt(0,this.m_maxLength-this.m_currentLength)*t.step.inv_dt,r=Mt.AddVCrossSV(e,s,this.m_rA,Fi.SolveVelocityConstraints_s_vpA),a=Mt.AddVCrossSV(i,n,this.m_rB,Fi.SolveVelocityConstraints_s_vpB),h=Mt.DotVV(this.m_u,Mt.SubVV(r,a,Mt.s_t0));let l=-this.m_mass*(h+o);const _=this.m_upperImpulse;this.m_upperImpulse=lt(0,this.m_upperImpulse+l),l=this.m_upperImpulse-_;const m=Mt.MulSV(-l,this.m_u,Fi.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,m),s-=this.m_invIA*Mt.CrossVV(this.m_rA,m),i.SelfMulAdd(this.m_invMassB,m),n+=this.m_invIB*Mt.CrossVV(this.m_rB,m)}}else{const t=Mt.AddVCrossSV(e,s,this.m_rA,Fi.SolveVelocityConstraints_s_vpA),o=Mt.AddVCrossSV(i,n,this.m_rB,Fi.SolveVelocityConstraints_s_vpB),r=Mt.DotVV(this.m_u,Mt.SubVV(o,t,Mt.s_t0)),a=-this.m_mass*r;this.m_impulse+=a;const h=Mt.MulSV(a,this.m_u,Fi.SolveVelocityConstraints_s_P);e.SelfMulSub(this.m_invMassA,h),s-=this.m_invIA*Mt.CrossVV(this.m_rA,h),i.SelfMulAdd(this.m_invMassB,h),n+=this.m_invIB*Mt.CrossVV(this.m_rB,h)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n),a=Lt.MulRV(o,this.m_lalcA,this.m_rA),h=Lt.MulRV(r,this.m_lalcB,this.m_rB),l=this.m_u;l.x=i.x+h.x-e.x-a.x,l.y=i.y+h.y-e.y-a.y;const _=this.m_u.Normalize();let m;if(this.m_minLength===this.m_maxLength)m=_-this.m_minLength;else if(_<this.m_minLength)m=_-this.m_minLength;else{if(!(this.m_maxLength<_))return!0;m=_-this.m_maxLength}const c=-this.m_mass*m,u=Mt.MulSV(c,l,Fi.SolvePositionConstraints_s_P);return e.SelfMulSub(this.m_invMassA,u),s-=this.m_invIA*Mt.CrossVV(a,u),i.SelfMulAdd(this.m_invMassB,u),n+=this.m_invIB*Mt.CrossVV(h,u),t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,at(m)<B}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=Rt.MulXV(e,this.m_localAnchorA,Fi.Draw_s_pA),n=Rt.MulXV(s,this.m_localAnchorB,Fi.Draw_s_pB),o=Mt.SubVV(n,i,Fi.Draw_s_axis);o.Normalize();const r=Fi.Draw_s_c1,a=Fi.Draw_s_c2,h=Fi.Draw_s_c3,l=Fi.Draw_s_c4;t.DrawSegment(i,n,l);const m=Mt.AddVMulSV(i,this.m_length,o,Fi.Draw_s_pRest);if(t.DrawPoint(m,8,r),this.m_minLength!==this.m_maxLength){if(this.m_minLength>B){const e=Mt.AddVMulSV(i,this.m_minLength,o,Fi.Draw_s_pMin);t.DrawPoint(e,4,a)}if(this.m_maxLength<_){const e=Mt.AddVMulSV(i,this.m_maxLength,o,Fi.Draw_s_pMax);t.DrawPoint(e,4,h)}}}}Fi.InitVelocityConstraints_s_P=new Mt,Fi.SolveVelocityConstraints_s_vpA=new Mt,Fi.SolveVelocityConstraints_s_vpB=new Mt,Fi.SolveVelocityConstraints_s_P=new Mt,Fi.SolvePositionConstraints_s_P=new Mt,Fi.Draw_s_pA=new Mt,Fi.Draw_s_pB=new Mt,Fi.Draw_s_axis=new Mt,Fi.Draw_s_c1=new n(.7,.7,.7),Fi.Draw_s_c2=new n(.3,.9,.3),Fi.Draw_s_c3=new n(.9,.3,.3),Fi.Draw_s_c4=new n(.4,.4,.4),Fi.Draw_s_pRest=new Mt,Fi.Draw_s_pMin=new Mt,Fi.Draw_s_pMax=new Mt;class Li extends Mi{constructor(){super(gi.e_areaJoint),this.bodies=[],this.stiffness=0,this.damping=0}AddBody(t){this.bodies.push(t),1===this.bodies.length?this.bodyA=t:2===this.bodies.length&&(this.bodyB=t)}}class Ri extends Gi{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_impulse=0,this.m_targetArea=0,this.m_delta=new Mt,this.m_bodies=t.bodies,this.m_stiffness=l(t.stiffness,0),this.m_damping=l(t.damping,0),this.m_targetLengths=$(t.bodies.length),this.m_normals=Mt.MakeArray(t.bodies.length),this.m_joints=[],this.m_deltas=Mt.MakeArray(t.bodies.length);const e=new Di;e.stiffness=this.m_stiffness,e.damping=this.m_damping,this.m_targetArea=0;for(let t=0;t<this.m_bodies.length;++t){const s=this.m_bodies[t],i=this.m_bodies[(t+1)%this.m_bodies.length],n=s.GetWorldCenter(),o=i.GetWorldCenter();this.m_targetLengths[t]=Mt.DistanceVV(n,o),this.m_targetArea+=Mt.CrossVV(n,o),e.Initialize(s,i,n,o),this.m_joints[t]=s.GetWorld().CreateJoint(e)}this.m_targetArea*=.5}GetAnchorA(t){return t}GetAnchorB(t){return t}GetReactionForce(t,e){return e}GetReactionTorque(t){return 0}SetStiffness(t){this.m_stiffness=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetStiffness(t)}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t;for(let e=0;e<this.m_joints.length;++e)this.m_joints[e].SetDamping(t)}GetDamping(){return this.m_damping}Dump(t){t("Area joint dumping is not supported.\n")}InitVelocityConstraints(t){for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[(e+this.m_bodies.length-1)%this.m_bodies.length],i=this.m_bodies[(e+1)%this.m_bodies.length],n=t.positions[s.m_islandIndex].c,o=t.positions[i.m_islandIndex].c,r=this.m_deltas[e];Mt.SubVV(o,n,r)}if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],i=t.velocities[s.m_islandIndex].v,n=this.m_deltas[e];i.x+=s.m_invMass*n.y*.5*this.m_impulse,i.y+=s.m_invMass*-n.x*.5*this.m_impulse}}else this.m_impulse=0}SolveVelocityConstraints(t){let e=0,s=0;for(let i=0;i<this.m_bodies.length;++i){const n=this.m_bodies[i],o=t.velocities[n.m_islandIndex].v,r=this.m_deltas[i];e+=r.LengthSquared()/n.GetMass(),s+=Mt.CrossVV(o,r)}const i=-2*s/e;this.m_impulse+=i;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],n=t.velocities[s.m_islandIndex].v,o=this.m_deltas[e];n.x+=s.m_invMass*o.y*.5*i,n.y+=s.m_invMass*-o.x*.5*i}}SolvePositionConstraints(t){let e=0,s=0;for(let i=0;i<this.m_bodies.length;++i){const n=this.m_bodies[i],o=this.m_bodies[(i+1)%this.m_bodies.length],r=t.positions[n.m_islandIndex].c,a=t.positions[o.m_islandIndex].c,h=Mt.SubVV(a,r,this.m_delta);let l=h.Length();l<m&&(l=1),this.m_normals[i].x=h.y/l,this.m_normals[i].y=-h.x/l,e+=l,s+=Mt.CrossVV(r,a)}s*=.5;const i=.5*(this.m_targetArea-s)/e;let n=!0;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],o=t.positions[s.m_islandIndex].c,r=(e+1)%this.m_bodies.length,a=Mt.AddVV(this.m_normals[e],this.m_normals[r],this.m_delta);a.SelfMul(i);const h=a.LengthSquared();h>ut(g)&&a.SelfMul(g/ft(h)),h>ut(B)&&(n=!1),o.x+=a.x,o.y+=a.y}return n}}class Ti{constructor(){this.categoryBits=1,this.maskBits=65535,this.groupIndex=0}Clone(){return(new Ti).Copy(this)}Copy(t){return this.categoryBits=t.categoryBits,this.maskBits=t.maskBits,this.groupIndex=t.groupIndex||0,this}}Ti.DEFAULT=new Ti;class ki{constructor(){this.userData=null,this.friction=.2,this.restitution=0,this.restitutionThreshold=1*d,this.density=0,this.isSensor=!1,this.filter=new Ti}}class qi{constructor(t,e){this.aabb=new Me,this.childIndex=0,this.fixture=t,this.childIndex=e,this.fixture.m_shape.ComputeAABB(this.aabb,this.fixture.m_body.GetTransform(),e),this.treeNode=this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb,this)}Reset(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode)}Touch(){this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode)}Synchronize(t,e){if(t===e)this.fixture.m_shape.ComputeAABB(this.aabb,t,this.childIndex),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,Mt.ZERO);else{const s=qi.Synchronize_s_aabb1,i=qi.Synchronize_s_aabb2;this.fixture.m_shape.ComputeAABB(s,t,this.childIndex),this.fixture.m_shape.ComputeAABB(i,e,this.childIndex),this.aabb.Combine2(s,i);const n=qi.Synchronize_s_displacement;n.Copy(i.GetCenter()).SelfSub(s.GetCenter()),this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode,this.aabb,n)}}}qi.Synchronize_s_aabb1=new Me,qi.Synchronize_s_aabb2=new Me,qi.Synchronize_s_displacement=new Mt;class zi{constructor(t,e){this.m_density=0,this.m_next=null,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=1*d,this.m_proxies=[],this.m_filter=new Ti,this.m_isSensor=!1,this.m_userData=null,this.m_body=t,this.m_shape=e.shape.Clone(),this.m_userData=l(e.userData,null),this.m_friction=l(e.friction,.2),this.m_restitution=l(e.restitution,0),this.m_restitutionThreshold=l(e.restitutionThreshold,0),this.m_filter.Copy(l(e.filter,Ti.DEFAULT)),this.m_isSensor=l(e.isSensor,!1),this.m_density=l(e.density,0)}get m_proxyCount(){return this.m_proxies.length}Reset(){}GetType(){return this.m_shape.GetType()}GetShape(){return this.m_shape}SetSensor(t){t!==this.m_isSensor&&(this.m_body.SetAwake(!0),this.m_isSensor=t)}IsSensor(){return this.m_isSensor}SetFilterData(t){this.m_filter.Copy(t),this.Refilter()}GetFilterData(){return this.m_filter}Refilter(){let t=this.m_body.GetContactList();for(;t;){const e=t.contact,s=e.GetFixtureA(),i=e.GetFixtureB();s!==this&&i!==this||e.FlagForFiltering(),t=t.next}this.TouchProxies()}GetBody(){return this.m_body}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}TestPoint(t){return this.m_shape.TestPoint(this.m_body.GetTransform(),t)}ComputeDistance(t,e,s){return this.m_shape.ComputeDistance(this.m_body.GetTransform(),t,e,s)}RayCast(t,e,s){return this.m_shape.RayCast(t,e,this.m_body.GetTransform(),s)}GetMassData(t=new Ee){return this.m_shape.ComputeMass(t,this.m_density),t}SetDensity(t){this.m_density=t}GetDensity(){return this.m_density}GetFriction(){return this.m_friction}SetFriction(t){this.m_friction=t}GetRestitution(){return this.m_restitution}SetRestitution(t){this.m_restitution=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetAABB(t){return this.m_proxies[t].aabb}Dump(t,e){t("    const fd: b2FixtureDef = new b2FixtureDef();\n"),t("    fd.friction = %.15f;\n",this.m_friction),t("    fd.restitution = %.15f;\n",this.m_restitution),t("    fd.restitutionThreshold = %.15f;\n",this.m_restitutionThreshold),t("    fd.density = %.15f;\n",this.m_density),t("    fd.isSensor = %s;\n",this.m_isSensor?"true":"false"),t("    fd.filter.categoryBits = %d;\n",this.m_filter.categoryBits),t("    fd.filter.maskBits = %d;\n",this.m_filter.maskBits),t("    fd.filter.groupIndex = %d;\n",this.m_filter.groupIndex),this.m_shape.Dump(t),t("\n"),t("    fd.shape = shape;\n"),t("\n"),t("    bodies[%d].CreateFixture(fd);\n",e)}CreateProxies(){if(0!==this.m_proxies.length)throw new Error;for(let t=0;t<this.m_shape.GetChildCount();++t)this.m_proxies[t]=new qi(this,t)}DestroyProxies(){for(const t of this.m_proxies)t.Reset();this.m_proxies.length=0}TouchProxies(){for(const t of this.m_proxies)t.Touch()}SynchronizeProxies(t,e){for(const s of this.m_proxies)s.Synchronize(t,e)}}!function(t){t[t.b2_unknown=-1]="b2_unknown",t[t.b2_staticBody=0]="b2_staticBody",t[t.b2_kinematicBody=1]="b2_kinematicBody",t[t.b2_dynamicBody=2]="b2_dynamicBody"}(wi||(wi={}));class Ei{constructor(){this.id="",this.type=wi.b2_staticBody,this.position=new Mt(0,0),this.angle=0,this.linearVelocity=new Mt(0,0),this.angularVelocity=0,this.linearDamping=0,this.angularDamping=0,this.allowSleep=!0,this.awake=!0,this.fixedRotation=!1,this.bullet=!1,this.enabled=!0,this.userData=null,this.gravityScale=1}}class Ni{constructor(t,e){this.m_type=wi.b2_staticBody,this.m_islandFlag=!1,this.m_awakeFlag=!1,this.m_autoSleepFlag=!1,this.m_bulletFlag=!1,this.m_fixedRotationFlag=!1,this.m_enabledFlag=!1,this.m_toiFlag=!1,this.m_islandIndex=0,this.m_xf=new Rt,this.m_xf0=new Rt,this.m_sweep=new Tt,this.m_linearVelocity=new Mt,this.m_angularVelocity=0,this.m_force=new Mt,this.m_torque=0,this.m_prev=null,this.m_next=null,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_jointList=null,this.m_contactList=null,this.m_mass=1,this.m_invMass=1,this.m_I=0,this.m_invI=0,this.m_linearDamping=0,this.m_angularDamping=0,this.m_gravityScale=1,this.m_sleepTime=0,this.m_userData=null,this.m_controllerList=null,this.m_controllerCount=0,this.m_id=t.id,this.m_bulletFlag=l(t.bullet,!1),this.m_fixedRotationFlag=l(t.fixedRotation,!1),this.m_autoSleepFlag=l(t.allowSleep,!0),l(t.awake,!1)&&l(t.type,wi.b2_staticBody)!==wi.b2_staticBody&&(this.m_awakeFlag=!0),this.m_enabledFlag=l(t.enabled,!0),this.m_world=e,this.m_xf.p.Copy(l(t.position,Mt.ZERO)),this.m_xf.q.SetAngle(l(t.angle,0)),this.m_xf0.Copy(this.m_xf),this.m_sweep.localCenter.SetZero(),this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),this.m_sweep.a0=this.m_sweep.a=this.m_xf.q.GetAngle(),this.m_sweep.alpha0=0,this.m_linearVelocity.Copy(l(t.linearVelocity,Mt.ZERO)),this.m_angularVelocity=l(t.angularVelocity,0),this.m_linearDamping=l(t.linearDamping,0),this.m_angularDamping=l(t.angularDamping,0),this.m_gravityScale=l(t.gravityScale,1),this.m_force.SetZero(),this.m_torque=0,this.m_sleepTime=0,this.m_type=l(t.type,wi.b2_staticBody),this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_userData=t.userData,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_controllerList=null,this.m_controllerCount=0}GetId(){return this.m_id}CreateFixture(t,e=0){return t instanceof je?this.CreateFixtureShapeDensity(t,e):this.CreateFixtureDef(t)}CreateFixtureDef(t){if(this.m_world.IsLocked())throw new Error;const e=new zi(this,t);return this.m_enabledFlag&&e.CreateProxies(),e.m_next=this.m_fixtureList,this.m_fixtureList=e,++this.m_fixtureCount,e.m_density>0&&this.ResetMassData(),this.m_world.m_newContacts=!0,e}CreateFixtureShapeDensity(t,e=0){const s=Ni.CreateFixtureShapeDensity_s_def;return s.shape=t,s.density=e,this.CreateFixtureDef(s)}DestroyFixture(t){if(this.m_world.IsLocked())throw new Error;let e=this.m_fixtureList,s=null;for(;null!==e;){if(e===t){s?s.m_next=t.m_next:this.m_fixtureList=t.m_next;break}s=e,e=e.m_next}let i=this.m_contactList;for(;i;){const e=i.contact;i=i.next;const s=e.GetFixtureA(),n=e.GetFixtureB();t!==s&&t!==n||this.m_world.m_contactManager.Destroy(e)}this.m_enabledFlag&&t.DestroyProxies(),t.m_next=null,t.Reset(),--this.m_fixtureCount,this.ResetMassData()}SetTransformVec(t,e){this.SetTransformXY(t.x,t.y,e)}SetTransformXY(t,e,s){if(this.m_world.IsLocked())throw new Error;this.m_xf.q.SetAngle(s),this.m_xf.p.Set(t,e),this.m_xf0.Copy(this.m_xf),Rt.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.a=s,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_sweep.a0=s;for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf);this.m_world.m_newContacts=!0}SetTransform(t){this.SetTransformVec(t.p,t.GetAngle())}GetTransform(){return this.m_xf}GetPosition(){return this.m_xf.p}SetPosition(t){this.SetTransformVec(t,this.GetAngle())}SetPositionXY(t,e){this.SetTransformXY(t,e,this.GetAngle())}GetAngle(){return this.m_sweep.a}SetAngle(t){this.SetTransformVec(this.GetPosition(),t)}GetWorldCenter(){return this.m_sweep.c}GetLocalCenter(){return this.m_sweep.localCenter}SetLinearVelocity(t){this.m_type!==wi.b2_staticBody&&(Mt.DotVV(t,t)>0&&this.SetAwake(!0),this.m_linearVelocity.Copy(t))}GetLinearVelocity(){return this.m_linearVelocity}SetAngularVelocity(t){this.m_type!==wi.b2_staticBody&&(t*t>0&&this.SetAwake(!0),this.m_angularVelocity=t)}GetAngularVelocity(){return this.m_angularVelocity}GetDefinition(t){return t.type=this.GetType(),t.allowSleep=this.m_autoSleepFlag,t.angle=this.GetAngle(),t.angularDamping=this.m_angularDamping,t.gravityScale=this.m_gravityScale,t.angularVelocity=this.m_angularVelocity,t.fixedRotation=this.m_fixedRotationFlag,t.bullet=this.m_bulletFlag,t.awake=this.m_awakeFlag,t.linearDamping=this.m_linearDamping,t.linearVelocity.Copy(this.GetLinearVelocity()),t.position.Copy(this.GetPosition()),t.userData=this.GetUserData(),t}ApplyForce(t,e,s=!0){this.m_type===wi.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y,this.m_torque+=(e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x))}ApplyForceToCenter(t,e=!0){this.m_type===wi.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y))}ApplyTorque(t,e=!0){this.m_type===wi.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_torque+=t))}ApplyLinearImpulse(t,e,s=!0){this.m_type===wi.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y,this.m_angularVelocity+=this.m_invI*((e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x)))}ApplyLinearImpulseToCenter(t,e=!0){this.m_type===wi.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y))}ApplyAngularImpulse(t,e=!0){this.m_type===wi.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_angularVelocity+=this.m_invI*t))}GetMass(){return this.m_mass}GetInertia(){return this.m_I+this.m_mass*Mt.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter)}GetMassData(t){return t.mass=this.m_mass,t.I=this.m_I+this.m_mass*Mt.DotVV(this.m_sweep.localCenter,this.m_sweep.localCenter),t.center.Copy(this.m_sweep.localCenter),t}SetMassData(t){if(this.m_world.IsLocked())throw new Error;if(this.m_type!==wi.b2_dynamicBody)return;this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_mass=t.mass,this.m_mass<=0&&(this.m_mass=1),this.m_invMass=1/this.m_mass,t.I>0&&!this.m_fixedRotationFlag&&(this.m_I=t.I-this.m_mass*Mt.DotVV(t.center,t.center),this.m_invI=1/this.m_I);const e=Ni.SetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t.center),Rt.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),Mt.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Mt.SubVV(this.m_sweep.c,e,Mt.s_t0),this.m_linearVelocity)}ResetMassData(){if(this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_sweep.localCenter.SetZero(),this.m_type===wi.b2_staticBody||this.m_type===wi.b2_kinematicBody)return this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),void(this.m_sweep.a0=this.m_sweep.a);const t=Ni.ResetMassData_s_localCenter.SetZero();for(let e=this.m_fixtureList;e;e=e.m_next){if(0===e.m_density)continue;const s=e.GetMassData(Ni.ResetMassData_s_massData);this.m_mass+=s.mass,t.x+=s.center.x*s.mass,t.y+=s.center.y*s.mass,this.m_I+=s.I}this.m_mass>0&&(this.m_invMass=1/this.m_mass,t.x*=this.m_invMass,t.y*=this.m_invMass),this.m_I>0&&!this.m_fixedRotationFlag?(this.m_I-=this.m_mass*Mt.DotVV(t,t),this.m_invI=1/this.m_I):(this.m_I=0,this.m_invI=0);const e=Ni.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t),Rt.MulXV(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),Mt.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Mt.SubVV(this.m_sweep.c,e,Mt.s_t0),this.m_linearVelocity)}GetWorldPoint(t,e){return Rt.MulXV(this.m_xf,t,e)}GetWorldVector(t,e){return Lt.MulRV(this.m_xf.q,t,e)}GetLocalPoint(t,e){return Rt.MulTXV(this.m_xf,t,e)}GetLocalVector(t,e){return Lt.MulTRV(this.m_xf.q,t,e)}GetLinearVelocityFromWorldPoint(t,e){return Mt.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Mt.SubVV(t,this.m_sweep.c,Mt.s_t0),e)}GetLinearVelocityFromLocalPoint(t,e){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t,e),e)}GetLinearDamping(){return this.m_linearDamping}SetLinearDamping(t){this.m_linearDamping=t}GetAngularDamping(){return this.m_angularDamping}SetAngularDamping(t){this.m_angularDamping=t}GetGravityScale(){return this.m_gravityScale}SetGravityScale(t){this.m_gravityScale=t}SetType(t){if(this.m_world.IsLocked())throw new Error;if(this.m_type===t)return;this.m_type=t,this.ResetMassData(),this.m_type===wi.b2_staticBody&&(this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_sweep.a0=this.m_sweep.a,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_awakeFlag=!1,this.SynchronizeFixtures()),this.SetAwake(!0),this.m_force.SetZero(),this.m_torque=0;let e=this.m_contactList;for(;e;){const t=e;e=e.next,this.m_world.m_contactManager.Destroy(t.contact)}this.m_contactList=null;for(let t=this.m_fixtureList;t;t=t.m_next)t.TouchProxies()}GetType(){return this.m_type}SetBullet(t){this.m_bulletFlag=t}IsBullet(){return this.m_bulletFlag}SetSleepingAllowed(t){this.m_autoSleepFlag=t,t||this.SetAwake(!0)}IsSleepingAllowed(){return this.m_autoSleepFlag}SetAwake(t){this.m_type!==wi.b2_staticBody&&(t?(this.m_awakeFlag=!0,this.m_sleepTime=0):(this.m_awakeFlag=!1,this.m_sleepTime=0,this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_force.SetZero(),this.m_torque=0))}IsAwake(){return this.m_awakeFlag}SetEnabled(t){if(this.m_world.IsLocked())throw new Error;if(t!==this.IsEnabled())if(this.m_enabledFlag=t,t){for(let t=this.m_fixtureList;t;t=t.m_next)t.CreateProxies();this.m_world.m_newContacts=!0}else{for(let t=this.m_fixtureList;t;t=t.m_next)t.DestroyProxies();let t=this.m_contactList;for(;t;){const e=t;t=t.next,this.m_world.m_contactManager.Destroy(e.contact)}this.m_contactList=null}}IsEnabled(){return this.m_enabledFlag}SetFixedRotation(t){this.m_fixedRotationFlag!==t&&(this.m_fixedRotationFlag=t,this.m_angularVelocity=0,this.ResetMassData())}IsFixedRotation(){return this.m_fixedRotationFlag}GetFixtureList(){return this.m_fixtureList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactList}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}GetWorld(){return this.m_world}Dump(t){const e=this.m_islandIndex;t("{\n"),t("  const bd: b2BodyDef = new b2BodyDef();\n");let s="";switch(this.m_type){case wi.b2_staticBody:s="b2BodyType.b2_staticBody";break;case wi.b2_kinematicBody:s="b2BodyType.b2_kinematicBody";break;case wi.b2_dynamicBody:s="b2BodyType.b2_dynamicBody"}t("  bd.type = %s;\n",s),t("  bd.position.Set(%.15f, %.15f);\n",this.m_xf.p.x,this.m_xf.p.y),t("  bd.angle = %.15f;\n",this.m_sweep.a),t("  bd.linearVelocity.Set(%.15f, %.15f);\n",this.m_linearVelocity.x,this.m_linearVelocity.y),t("  bd.angularVelocity = %.15f;\n",this.m_angularVelocity),t("  bd.linearDamping = %.15f;\n",this.m_linearDamping),t("  bd.angularDamping = %.15f;\n",this.m_angularDamping),t("  bd.allowSleep = %s;\n",this.m_autoSleepFlag?"true":"false"),t("  bd.awake = %s;\n",this.m_awakeFlag?"true":"false"),t("  bd.fixedRotation = %s;\n",this.m_fixedRotationFlag?"true":"false"),t("  bd.bullet = %s;\n",this.m_bulletFlag?"true":"false"),t("  bd.active = %s;\n",this.m_enabledFlag?"true":"false"),t("  bd.gravityScale = %.15f;\n",this.m_gravityScale),t("\n"),t("  bodies[%d] = this.m_world.CreateBody(bd);\n",this.m_islandIndex),t("\n");for(let s=this.m_fixtureList;s;s=s.m_next)t("  {\n"),s.Dump(t,e),t("  }\n");t("}\n")}SynchronizeFixtures(){if(this.m_awakeFlag){const t=Ni.SynchronizeFixtures_s_xf1;t.q.SetAngle(this.m_sweep.a0),Lt.MulRV(t.q,this.m_sweep.localCenter,t.p),Mt.SubVV(this.m_sweep.c0,t.p,t.p);for(let e=this.m_fixtureList;e;e=e.m_next)e.SynchronizeProxies(t,this.m_xf)}else for(let t=this.m_fixtureList;t;t=t.m_next)t.SynchronizeProxies(this.m_xf,this.m_xf)}SynchronizeTransform(){this.m_xf.q.SetAngle(this.m_sweep.a),Lt.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),Mt.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}ShouldCollide(t){return(this.m_type!==wi.b2_staticBody||t.m_type!==wi.b2_staticBody)&&this.ShouldCollideConnected(t)}ShouldCollideConnected(t){for(let e=this.m_jointList;e;e=e.next)if(e.other===t&&!e.joint.m_collideConnected)return!1;return!0}Advance(t){this.m_sweep.Advance(t),this.m_sweep.c.Copy(this.m_sweep.c0),this.m_sweep.a=this.m_sweep.a0,this.m_xf.q.SetAngle(this.m_sweep.a),Lt.MulRV(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),Mt.SubVV(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}GetControllerList(){return this.m_controllerList}GetControllerCount(){return this.m_controllerCount}}function ji(t,e){return ft(t*e)}function Ji(t,e){return t>e?t:e}function Xi(t,e){return t<e?t:e}Ni.CreateFixtureShapeDensity_s_def=new ki,Ni.SetMassData_s_oldCenter=new Mt,Ni.ResetMassData_s_localCenter=new Mt,Ni.ResetMassData_s_oldCenter=new Mt,Ni.ResetMassData_s_massData=new Ee,Ni.SynchronizeFixtures_s_xf1=new Rt;class Oi{constructor(t){this._other=null,this.prev=null,this.next=null,this.contact=t}get other(){if(null===this._other)throw new Error;return this._other}set other(t){if(null!==this._other)throw new Error;this._other=t}Reset(){this._other=null,this.prev=null,this.next=null}}class Zi{constructor(){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_prev=null,this.m_next=null,this.m_nodeA=new Oi(this),this.m_nodeB=new Oi(this),this.m_indexA=0,this.m_indexB=0,this.m_manifold=new Ce,this.m_toiCount=0,this.m_toi=0,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=0,this.m_tangentSpeed=0,this.m_oldManifold=new Ce}GetManifold(){return this.m_manifold}GetWorldManifold(t){const e=this.m_fixtureA.GetBody(),s=this.m_fixtureB.GetBody(),i=this.GetShapeA(),n=this.GetShapeB();t.Initialize(this.m_manifold,e.GetTransform(),i.m_radius,s.GetTransform(),n.m_radius)}IsTouching(){return this.m_touchingFlag}SetEnabled(t){this.m_enabledFlag=t}IsEnabled(){return this.m_enabledFlag}GetNext(){return this.m_next}GetFixtureA(){return this.m_fixtureA}GetChildIndexA(){return this.m_indexA}GetShapeA(){return this.m_fixtureA.GetShape()}GetFixtureB(){return this.m_fixtureB}GetChildIndexB(){return this.m_indexB}GetShapeB(){return this.m_fixtureB.GetShape()}FlagForFiltering(){this.m_filterFlag=!0}SetFriction(t){this.m_friction=t}GetFriction(){return this.m_friction}ResetFriction(){this.m_friction=ji(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction)}SetRestitution(t){this.m_restitution=t}GetRestitution(){return this.m_restitution}ResetRestitution(){this.m_restitution=Ji(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution)}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}ResetRestitutionThreshold(){this.m_restitutionThreshold=Xi(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}SetTangentSpeed(t){this.m_tangentSpeed=t}GetTangentSpeed(){return this.m_tangentSpeed}Reset(t,e,s,i){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!0,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_fixtureA=t,this.m_fixtureB=s,this.m_indexA=e,this.m_indexB=i,this.m_manifold.pointCount=0,this.m_prev=null,this.m_next=null,this.m_nodeA.Reset(),this.m_nodeB.Reset(),this.m_toiCount=0,this.m_friction=ji(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction),this.m_restitution=Ji(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution),this.m_restitutionThreshold=Xi(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}Update(t){const e=this.m_oldManifold;this.m_oldManifold=this.m_manifold,this.m_manifold=e,this.m_enabledFlag=!0;let s=!1;const i=this.m_touchingFlag,n=this.m_fixtureA.IsSensor(),o=this.m_fixtureB.IsSensor(),r=n||o,a=this.m_fixtureA.GetBody(),h=this.m_fixtureB.GetBody(),l=a.GetTransform(),_=h.GetTransform();if(r){const t=this.GetShapeA(),e=this.GetShapeB();s=Le(t,this.m_indexA,e,this.m_indexB,l,_),this.m_manifold.pointCount=0}else{this.Evaluate(this.m_manifold,l,_),s=this.m_manifold.pointCount>0;for(let t=0;t<this.m_manifold.pointCount;++t){const e=this.m_manifold.points[t];e.normalImpulse=0,e.tangentImpulse=0;const s=e.id;for(let t=0;t<this.m_oldManifold.pointCount;++t){const i=this.m_oldManifold.points[t];if(i.id.key===s.key){e.normalImpulse=i.normalImpulse,e.tangentImpulse=i.tangentImpulse;break}}}s!==i&&(a.SetAwake(!0),h.SetAwake(!0))}this.m_touchingFlag=s,!i&&s&&t&&t.BeginContact(this),i&&!s&&t&&t.EndContact(this),!r&&s&&t&&t.PreSolve(this,this.m_oldManifold)}ComputeTOI(t,e){const s=Zi.ComputeTOI_s_input;s.proxyA.SetShape(this.GetShapeA(),this.m_indexA),s.proxyB.SetShape(this.GetShapeB(),this.m_indexB),s.sweepA.Copy(t),s.sweepB.Copy(e),s.tMax=B;const i=Zi.ComputeTOI_s_output;return Vi(i,s),i.t}}Zi.ComputeTOI_s_input=new li,Zi.ComputeTOI_s_output=new ci;class Ui extends Zi{static Create(){return new Ui}static Destroy(t){}Evaluate(t,e,s){const i=Ui.Evaluate_s_edge;this.GetShapeA().GetChildEdge(i,this.m_indexA),as(t,i,e,this.GetShapeB(),s)}}Ui.Evaluate_s_edge=new Je;class Wi extends Zi{static Create(){return new Wi}static Destroy(t){}Evaluate(t,e,s){const i=Wi.Evaluate_s_edge;this.GetShapeA().GetChildEdge(i,this.m_indexA),bs(t,i,e,this.GetShapeB(),s)}}Wi.Evaluate_s_edge=new Je;class Qi extends Zi{static Create(){return new Qi}static Destroy(t){}Evaluate(t,e,s){We(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class Yi extends Zi{static Create(){return new Yi}static Destroy(t){}Evaluate(t,e,s){Zs(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class Ki extends Zi{static Create(){return new Ki}static Destroy(t){}Evaluate(t,e,s){He(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class Hi extends Zi{static Create(){return new Hi}static Destroy(t){}Evaluate(t,e,s){as(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class $i extends Zi{static Create(){return new $i}static Destroy(t){}Evaluate(t,e,s){bs(t,this.GetShapeA(),e,this.GetShapeB(),s)}}class tn{constructor(){this.pool=[],this.createFcn=null,this.destroyFcn=null,this.primary=!1}}class en{constructor(){this.m_registers=[],this.InitializeRegisters()}AddType(t,e,s,i){const n=[];function o(){return n.pop()||t()}function r(t){n.push(t)}this.m_registers[s][i].pool=n,this.m_registers[s][i].createFcn=o,this.m_registers[s][i].destroyFcn=r,this.m_registers[s][i].primary=!0,s!==i&&(this.m_registers[i][s].pool=n,this.m_registers[i][s].createFcn=o,this.m_registers[i][s].destroyFcn=r,this.m_registers[i][s].primary=!1)}InitializeRegisters(){for(let t=0;t<Ne.e_shapeTypeCount;t++){this.m_registers[t]=[];for(let e=0;e<Ne.e_shapeTypeCount;e++)this.m_registers[t][e]=new tn}this.AddType(Qi.Create,Qi.Destroy,Ne.e_circleShape,Ne.e_circleShape),this.AddType(Ki.Create,Ki.Destroy,Ne.e_polygonShape,Ne.e_circleShape),this.AddType(Yi.Create,Yi.Destroy,Ne.e_polygonShape,Ne.e_polygonShape),this.AddType(Hi.Create,Hi.Destroy,Ne.e_edgeShape,Ne.e_circleShape),this.AddType($i.Create,$i.Destroy,Ne.e_edgeShape,Ne.e_polygonShape),this.AddType(Ui.Create,Ui.Destroy,Ne.e_chainShape,Ne.e_circleShape),this.AddType(Wi.Create,Wi.Destroy,Ne.e_chainShape,Ne.e_polygonShape)}Create(t,e,s,i){const n=t.GetType(),o=s.GetType(),r=this.m_registers[n][o];if(r.createFcn){const n=r.createFcn();return r.primary?n.Reset(t,e,s,i):n.Reset(s,i,t,e),n}return null}Destroy(t){const e=t.m_fixtureA.GetType(),s=t.m_fixtureB.GetType(),i=this.m_registers[e][s];i.destroyFcn&&i.destroyFcn(t)}}class sn{SayGoodbyeJoint(t){}SayGoodbyeFixture(t){}SayGoodbyeParticleGroup(t){}SayGoodbyeParticle(t,e){}}class nn{ShouldCollide(t,e){const s=t.GetBody(),i=e.GetBody();if(i.GetType()===wi.b2_staticBody&&s.GetType()===wi.b2_staticBody)return!1;if(!i.ShouldCollideConnected(s))return!1;const n=t.GetFilterData(),o=e.GetFilterData();if(n.groupIndex===o.groupIndex&&0!==n.groupIndex)return n.groupIndex>0;return 0!=(n.maskBits&o.categoryBits)&&0!=(n.categoryBits&o.maskBits)}ShouldCollideFixtureParticle(t,e,s){return!0}ShouldCollideParticleParticle(t,e,s){return!0}}nn.b2_defaultFilter=new nn;class on{constructor(){this.normalImpulses=$(p),this.tangentImpulses=$(p),this.count=0}}class rn{BeginContact(t){}EndContact(t){}BeginContactFixtureParticle(t,e){}EndContactFixtureParticle(t,e){}BeginContactBodyParticleGroup(t,e){}EndContactBodyParticleGroup(t,e){}BeginContactParticleParticle(t,e){}EndContactParticleParticle(t,e){}BeginContactParticleGroupParticleGroup(t,e){}EndContactParticleGroupParticleGroup(t,e){}PreSolve(t,e){}PostSolve(t,e){}}rn.b2_defaultListener=new rn;class an{ReportFixture(t){return!0}ReportParticle(t,e){return!1}ShouldQueryParticleSystem(t){return!0}}class hn{ReportFixture(t,e,s,i){return i}ReportParticle(t,e,s,i,n){return 0}ShouldQueryParticleSystem(t){return!0}}class ln{constructor(){this.m_broadPhase=new ze,this.m_contactList=null,this.m_contactCount=0,this.m_contactFilter=nn.b2_defaultFilter,this.m_contactListener=rn.b2_defaultListener,this.m_contactFactory=new en}AddPair(t,e){let s=t.fixture,i=e.fixture,n=t.childIndex,o=e.childIndex,r=s.GetBody(),a=i.GetBody();if(r===a)return;let h=a.GetContactList();for(;h;){if(h.other===r){const t=h.contact.GetFixtureA(),e=h.contact.GetFixtureB(),r=h.contact.GetChildIndexA(),a=h.contact.GetChildIndexB();if(t===s&&e===i&&r===n&&a===o)return;if(t===i&&e===s&&r===o&&a===n)return}h=h.next}if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(s,i))return;const l=this.m_contactFactory.Create(s,n,i,o);null!==l&&(s=l.GetFixtureA(),i=l.GetFixtureB(),n=l.GetChildIndexA(),o=l.GetChildIndexB(),r=s.m_body,a=i.m_body,l.m_prev=null,l.m_next=this.m_contactList,null!==this.m_contactList&&(this.m_contactList.m_prev=l),this.m_contactList=l,l.m_nodeA.other=a,l.m_nodeA.prev=null,l.m_nodeA.next=r.m_contactList,null!==r.m_contactList&&(r.m_contactList.prev=l.m_nodeA),r.m_contactList=l.m_nodeA,l.m_nodeB.other=r,l.m_nodeB.prev=null,l.m_nodeB.next=a.m_contactList,null!==a.m_contactList&&(a.m_contactList.prev=l.m_nodeB),a.m_contactList=l.m_nodeB,++this.m_contactCount)}FindNewContacts(){this.m_broadPhase.UpdatePairs((t,e)=>{this.AddPair(t,e)})}Destroy(t){const e=t.GetFixtureA(),s=t.GetFixtureB(),i=e.GetBody(),n=s.GetBody();this.m_contactListener&&t.IsTouching()&&this.m_contactListener.EndContact(t),t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_contactList&&(this.m_contactList=t.m_next),t.m_nodeA.prev&&(t.m_nodeA.prev.next=t.m_nodeA.next),t.m_nodeA.next&&(t.m_nodeA.next.prev=t.m_nodeA.prev),t.m_nodeA===i.m_contactList&&(i.m_contactList=t.m_nodeA.next),t.m_nodeB.prev&&(t.m_nodeB.prev.next=t.m_nodeB.next),t.m_nodeB.next&&(t.m_nodeB.next.prev=t.m_nodeB.prev),t.m_nodeB===n.m_contactList&&(n.m_contactList=t.m_nodeB.next),t.m_manifold.pointCount>0&&!e.IsSensor()&&!s.IsSensor()&&(e.GetBody().SetAwake(!0),s.GetBody().SetAwake(!0)),this.m_contactFactory.Destroy(t),--this.m_contactCount}Collide(){let t=this.m_contactList;for(;t;){const e=t.GetFixtureA(),s=t.GetFixtureB(),i=t.GetChildIndexA(),n=t.GetChildIndexB(),o=e.GetBody(),r=s.GetBody();if(t.m_filterFlag){if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(e,s)){const e=t;t=e.m_next,this.Destroy(e);continue}t.m_filterFlag=!1}const a=o.IsAwake()&&o.m_type!==wi.b2_staticBody,h=r.IsAwake()&&r.m_type!==wi.b2_staticBody;if(!a&&!h){t=t.m_next;continue}const l=e.m_proxies[i].treeNode,_=s.m_proxies[n].treeNode;if(Pe(l.aabb,_.aabb))t.Update(this.m_contactListener),t=t.m_next;else{const e=t;t=e.m_next,this.Destroy(e)}}}}class _n{constructor(){this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0}Reset(){return this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0,this}}class mn{constructor(){this.dt=0,this.inv_dt=0,this.dtRatio=0,this.velocityIterations=0,this.positionIterations=0,this.particleIterations=0,this.warmStarting=!1}Copy(t){return this.dt=t.dt,this.inv_dt=t.inv_dt,this.dtRatio=t.dtRatio,this.positionIterations=t.positionIterations,this.velocityIterations=t.velocityIterations,this.particleIterations=t.particleIterations,this.warmStarting=t.warmStarting,this}}class cn{constructor(){this.c=new Mt,this.a=0}static MakeArray(t){return K(t,t=>new cn)}}class un{constructor(){this.v=new Mt,this.w=0}static MakeArray(t){return K(t,t=>new un)}}class dn{constructor(){this.step=new mn}}let fn=!1;function pn(){return fn}function yn(t){fn=t}class xn{constructor(){this.rA=new Mt,this.rB=new Mt,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}static MakeArray(t){return K(t,t=>new xn)}}class Bn{constructor(){this.points=xn.MakeArray(p),this.normal=new Mt,this.tangent=new Mt,this.normalMass=new Dt,this.K=new Dt,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.invIA=0,this.invIB=0,this.friction=0,this.restitution=0,this.threshold=0,this.tangentSpeed=0,this.pointCount=0,this.contactIndex=0}static MakeArray(t){return K(t,t=>new Bn)}}class Sn{constructor(){this.localPoints=Mt.MakeArray(p),this.localNormal=new Mt,this.localPoint=new Mt,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.localCenterA=new Mt,this.localCenterB=new Mt,this.invIA=0,this.invIB=0,this.type=ye.e_unknown,this.radiusA=0,this.radiusB=0,this.pointCount=0}static MakeArray(t){return K(t,t=>new Sn)}}class An{constructor(){this.step=new mn,this.count=0}}class Cn{constructor(){this.normal=new Mt,this.point=new Mt,this.separation=0}Initialize(t,e,s,i){const n=Cn.Initialize_s_pointA,o=Cn.Initialize_s_pointB,r=Cn.Initialize_s_planePoint,a=Cn.Initialize_s_clipPoint;switch(t.type){case ye.e_circles:Rt.MulXV(e,t.localPoint,n),Rt.MulXV(s,t.localPoints[0],o),Mt.SubVV(o,n,this.normal).SelfNormalize(),Mt.MidVV(n,o,this.point),this.separation=Mt.DotVV(Mt.SubVV(o,n,Mt.s_t0),this.normal)-t.radiusA-t.radiusB;break;case ye.e_faceA:Lt.MulRV(e.q,t.localNormal,this.normal),Rt.MulXV(e,t.localPoint,r),Rt.MulXV(s,t.localPoints[i],a),this.separation=Mt.DotVV(Mt.SubVV(a,r,Mt.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a);break;case ye.e_faceB:Lt.MulRV(s.q,t.localNormal,this.normal),Rt.MulXV(s,t.localPoint,r),Rt.MulXV(e,t.localPoints[i],a),this.separation=Mt.DotVV(Mt.SubVV(a,r,Mt.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a),this.normal.SelfNeg()}}}Cn.Initialize_s_pointA=new Mt,Cn.Initialize_s_pointB=new Mt,Cn.Initialize_s_planePoint=new Mt,Cn.Initialize_s_clipPoint=new Mt;class Vn{constructor(){this.m_step=new mn,this.m_positionConstraints=Sn.MakeArray(1024),this.m_velocityConstraints=Bn.MakeArray(1024),this.m_count=0}Initialize(t){if(this.m_step.Copy(t.step),this.m_count=t.count,this.m_positionConstraints.length<this.m_count){const t=lt(2*this.m_positionConstraints.length,this.m_count);for(;this.m_positionConstraints.length<t;)this.m_positionConstraints[this.m_positionConstraints.length]=new Sn}if(this.m_velocityConstraints.length<this.m_count){const t=lt(2*this.m_velocityConstraints.length,this.m_count);for(;this.m_velocityConstraints.length<t;)this.m_velocityConstraints[this.m_velocityConstraints.length]=new Bn}this.m_positions=t.positions,this.m_velocities=t.velocities,this.m_contacts=t.contacts;for(let t=0;t<this.m_count;++t){const e=this.m_contacts[t],s=e.m_fixtureA,i=e.m_fixtureB,n=s.GetShape(),o=i.GetShape(),r=n.m_radius,a=o.m_radius,h=s.GetBody(),l=i.GetBody(),_=e.GetManifold(),m=_.pointCount,c=this.m_velocityConstraints[t];c.friction=e.m_friction,c.restitution=e.m_restitution,c.threshold=e.m_restitutionThreshold,c.tangentSpeed=e.m_tangentSpeed,c.indexA=h.m_islandIndex,c.indexB=l.m_islandIndex,c.invMassA=h.m_invMass,c.invMassB=l.m_invMass,c.invIA=h.m_invI,c.invIB=l.m_invI,c.contactIndex=t,c.pointCount=m,c.K.SetZero(),c.normalMass.SetZero();const u=this.m_positionConstraints[t];u.indexA=h.m_islandIndex,u.indexB=l.m_islandIndex,u.invMassA=h.m_invMass,u.invMassB=l.m_invMass,u.localCenterA.Copy(h.m_sweep.localCenter),u.localCenterB.Copy(l.m_sweep.localCenter),u.invIA=h.m_invI,u.invIB=l.m_invI,u.localNormal.Copy(_.localNormal),u.localPoint.Copy(_.localPoint),u.pointCount=m,u.radiusA=r,u.radiusB=a,u.type=_.type;for(let t=0;t<m;++t){const e=_.points[t],s=c.points[t];this.m_step.warmStarting?(s.normalImpulse=this.m_step.dtRatio*e.normalImpulse,s.tangentImpulse=this.m_step.dtRatio*e.tangentImpulse):(s.normalImpulse=0,s.tangentImpulse=0),s.rA.SetZero(),s.rB.SetZero(),s.normalMass=0,s.tangentMass=0,s.velocityBias=0,u.localPoints[t].Copy(e.localPoint)}}return this}InitializeVelocityConstraints(){const t=Vn.InitializeVelocityConstraints_s_xfA,e=Vn.InitializeVelocityConstraints_s_xfB,s=Vn.InitializeVelocityConstraints_s_worldManifold;for(let i=0;i<this.m_count;++i){const n=this.m_velocityConstraints[i],o=this.m_positionConstraints[i],r=o.radiusA,a=o.radiusB,h=this.m_contacts[n.contactIndex].GetManifold(),l=n.indexA,_=n.indexB,m=n.invMassA,c=n.invMassB,u=n.invIA,d=n.invIB,f=o.localCenterA,p=o.localCenterB,y=this.m_positions[l].c,x=this.m_positions[l].a,B=this.m_velocities[l].v,S=this.m_velocities[l].w,A=this.m_positions[_].c,C=this.m_positions[_].a,V=this.m_velocities[_].v,g=this.m_velocities[_].w;t.q.SetAngle(x),e.q.SetAngle(C),Mt.SubVV(y,Lt.MulRV(t.q,f,Mt.s_t0),t.p),Mt.SubVV(A,Lt.MulRV(e.q,p,Mt.s_t0),e.p),s.Initialize(h,t,r,e,a),n.normal.Copy(s.normal),Mt.CrossVOne(n.normal,n.tangent);const w=n.pointCount;for(let t=0;t<w;++t){const e=n.points[t];Mt.SubVV(s.points[t],y,e.rA),Mt.SubVV(s.points[t],A,e.rB);const i=Mt.CrossVV(e.rA,n.normal),o=Mt.CrossVV(e.rB,n.normal),r=m+c+u*i*i+d*o*o;e.normalMass=r>0?1/r:0;const a=n.tangent,h=Mt.CrossVV(e.rA,a),l=Mt.CrossVV(e.rB,a),_=m+c+u*h*h+d*l*l;e.tangentMass=_>0?1/_:0,e.velocityBias=0;const f=Mt.DotVV(n.normal,Mt.SubVV(Mt.AddVCrossSV(V,g,e.rB,Mt.s_t0),Mt.AddVCrossSV(B,S,e.rA,Mt.s_t1),Mt.s_t0));f<-n.threshold&&(e.velocityBias+=-n.restitution*f)}if(2===n.pointCount&&fn){const t=n.points[0],e=n.points[1],s=Mt.CrossVV(t.rA,n.normal),i=Mt.CrossVV(t.rB,n.normal),o=Mt.CrossVV(e.rA,n.normal),r=Mt.CrossVV(e.rB,n.normal),a=m+c+u*s*s+d*i*i,h=m+c+u*o*o+d*r*r,l=m+c+u*s*o+d*i*r;a*a<1e3*(a*h-l*l)?(n.K.ex.Set(a,l),n.K.ey.Set(l,h),n.K.GetInverse(n.normalMass)):n.pointCount=1}}}WarmStart(){const t=Vn.WarmStart_s_P;for(let e=0;e<this.m_count;++e){const s=this.m_velocityConstraints[e],i=s.indexA,n=s.indexB,o=s.invMassA,r=s.invIA,a=s.invMassB,h=s.invIB,l=s.pointCount,_=this.m_velocities[i].v;let m=this.m_velocities[i].w;const c=this.m_velocities[n].v;let u=this.m_velocities[n].w;const d=s.normal,f=s.tangent;for(let e=0;e<l;++e){const i=s.points[e];Mt.AddVV(Mt.MulSV(i.normalImpulse,d,Mt.s_t0),Mt.MulSV(i.tangentImpulse,f,Mt.s_t1),t),m-=r*Mt.CrossVV(i.rA,t),_.SelfMulSub(o,t),u+=h*Mt.CrossVV(i.rB,t),c.SelfMulAdd(a,t)}this.m_velocities[i].w=m,this.m_velocities[n].w=u}}SolveVelocityConstraints(){const t=Vn.SolveVelocityConstraints_s_dv,e=Vn.SolveVelocityConstraints_s_dv1,s=Vn.SolveVelocityConstraints_s_dv2,i=Vn.SolveVelocityConstraints_s_P,n=Vn.SolveVelocityConstraints_s_a,o=Vn.SolveVelocityConstraints_s_b,r=Vn.SolveVelocityConstraints_s_x,a=Vn.SolveVelocityConstraints_s_d,h=Vn.SolveVelocityConstraints_s_P1,l=Vn.SolveVelocityConstraints_s_P2,_=Vn.SolveVelocityConstraints_s_P1P2;for(let m=0;m<this.m_count;++m){const c=this.m_velocityConstraints[m],u=c.indexA,d=c.indexB,f=c.invMassA,p=c.invIA,y=c.invMassB,x=c.invIB,B=c.pointCount,S=this.m_velocities[u].v;let A=this.m_velocities[u].w;const C=this.m_velocities[d].v;let V=this.m_velocities[d].w;const g=c.normal,w=c.tangent,v=c.friction;for(let e=0;e<B;++e){const s=c.points[e];Mt.SubVV(Mt.AddVCrossSV(C,V,s.rB,Mt.s_t0),Mt.AddVCrossSV(S,A,s.rA,Mt.s_t1),t);const n=Mt.DotVV(t,w)-c.tangentSpeed;let o=s.tangentMass*-n;const r=v*s.normalImpulse,a=_t(s.tangentImpulse+o,-r,r);o=a-s.tangentImpulse,s.tangentImpulse=a,Mt.MulSV(o,w,i),S.SelfMulSub(f,i),A-=p*Mt.CrossVV(s.rA,i),C.SelfMulAdd(y,i),V+=x*Mt.CrossVV(s.rB,i)}if(1===c.pointCount||!1===fn)for(let e=0;e<B;++e){const s=c.points[e];Mt.SubVV(Mt.AddVCrossSV(C,V,s.rB,Mt.s_t0),Mt.AddVCrossSV(S,A,s.rA,Mt.s_t1),t);const n=Mt.DotVV(t,g);let o=-s.normalMass*(n-s.velocityBias);const r=lt(s.normalImpulse+o,0);o=r-s.normalImpulse,s.normalImpulse=r,Mt.MulSV(o,g,i),S.SelfMulSub(f,i),A-=p*Mt.CrossVV(s.rA,i),C.SelfMulAdd(y,i),V+=x*Mt.CrossVV(s.rB,i)}else{const t=c.points[0],i=c.points[1];n.Set(t.normalImpulse,i.normalImpulse),Mt.SubVV(Mt.AddVCrossSV(C,V,t.rB,Mt.s_t0),Mt.AddVCrossSV(S,A,t.rA,Mt.s_t1),e),Mt.SubVV(Mt.AddVCrossSV(C,V,i.rB,Mt.s_t0),Mt.AddVCrossSV(S,A,i.rA,Mt.s_t1),s);let m=Mt.DotVV(e,g),u=Mt.DotVV(s,g);for(o.x=m-t.velocityBias,o.y=u-i.velocityBias,o.SelfSub(Dt.MulMV(c.K,n,Mt.s_t0));;){if(Dt.MulMV(c.normalMass,o,r).SelfNeg(),r.x>=0&&r.y>=0){Mt.SubVV(r,n,a),Mt.MulSV(a.x,g,h),Mt.MulSV(a.y,g,l),Mt.AddVV(h,l,_),S.SelfMulSub(f,_),A-=p*(Mt.CrossVV(t.rA,h)+Mt.CrossVV(i.rA,l)),C.SelfMulAdd(y,_),V+=x*(Mt.CrossVV(t.rB,h)+Mt.CrossVV(i.rB,l)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}if(r.x=-t.normalMass*o.x,r.y=0,m=0,u=c.K.ex.y*r.x+o.y,r.x>=0&&u>=0){Mt.SubVV(r,n,a),Mt.MulSV(a.x,g,h),Mt.MulSV(a.y,g,l),Mt.AddVV(h,l,_),S.SelfMulSub(f,_),A-=p*(Mt.CrossVV(t.rA,h)+Mt.CrossVV(i.rA,l)),C.SelfMulAdd(y,_),V+=x*(Mt.CrossVV(t.rB,h)+Mt.CrossVV(i.rB,l)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}if(r.x=0,r.y=-i.normalMass*o.y,m=c.K.ey.x*r.y+o.x,u=0,r.y>=0&&m>=0){Mt.SubVV(r,n,a),Mt.MulSV(a.x,g,h),Mt.MulSV(a.y,g,l),Mt.AddVV(h,l,_),S.SelfMulSub(f,_),A-=p*(Mt.CrossVV(t.rA,h)+Mt.CrossVV(i.rA,l)),C.SelfMulAdd(y,_),V+=x*(Mt.CrossVV(t.rB,h)+Mt.CrossVV(i.rB,l)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}if(r.x=0,r.y=0,m=o.x,u=o.y,m>=0&&u>=0){Mt.SubVV(r,n,a),Mt.MulSV(a.x,g,h),Mt.MulSV(a.y,g,l),Mt.AddVV(h,l,_),S.SelfMulSub(f,_),A-=p*(Mt.CrossVV(t.rA,h)+Mt.CrossVV(i.rA,l)),C.SelfMulAdd(y,_),V+=x*(Mt.CrossVV(t.rB,h)+Mt.CrossVV(i.rB,l)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}break}}this.m_velocities[u].w=A,this.m_velocities[d].w=V}}StoreImpulses(){for(let t=0;t<this.m_count;++t){const e=this.m_velocityConstraints[t],s=this.m_contacts[e.contactIndex].GetManifold();for(let t=0;t<e.pointCount;++t)s.points[t].normalImpulse=e.points[t].normalImpulse,s.points[t].tangentImpulse=e.points[t].tangentImpulse}}SolvePositionConstraints(){const t=Vn.SolvePositionConstraints_s_xfA,e=Vn.SolvePositionConstraints_s_xfB,s=Vn.SolvePositionConstraints_s_psm,i=Vn.SolvePositionConstraints_s_rA,n=Vn.SolvePositionConstraints_s_rB,o=Vn.SolvePositionConstraints_s_P;let r=0;for(let a=0;a<this.m_count;++a){const h=this.m_positionConstraints[a],l=h.indexA,_=h.indexB,m=h.localCenterA,c=h.invMassA,u=h.invIA,d=h.localCenterB,f=h.invMassB,p=h.invIB,y=h.pointCount,x=this.m_positions[l].c;let S=this.m_positions[l].a;const A=this.m_positions[_].c;let C=this.m_positions[_].a;for(let a=0;a<y;++a){t.q.SetAngle(S),e.q.SetAngle(C),Mt.SubVV(x,Lt.MulRV(t.q,m,Mt.s_t0),t.p),Mt.SubVV(A,Lt.MulRV(e.q,d,Mt.s_t0),e.p),s.Initialize(h,t,e,a);const l=s.normal,_=s.point,y=s.separation;Mt.SubVV(_,x,i),Mt.SubVV(_,A,n),r=ht(r,y);const V=_t(I*(y+B),-g,0),w=Mt.CrossVV(i,l),v=Mt.CrossVV(n,l),b=c+f+u*w*w+p*v*v,M=b>0?-V/b:0;Mt.MulSV(M,l,o),x.SelfMulSub(c,o),S-=u*Mt.CrossVV(i,o),A.SelfMulAdd(f,o),C+=p*Mt.CrossVV(n,o)}this.m_positions[l].a=S,this.m_positions[_].a=C}return r>-3*B}SolveTOIPositionConstraints(t,e){const s=Vn.SolveTOIPositionConstraints_s_xfA,i=Vn.SolveTOIPositionConstraints_s_xfB,n=Vn.SolveTOIPositionConstraints_s_psm,o=Vn.SolveTOIPositionConstraints_s_rA,r=Vn.SolveTOIPositionConstraints_s_rB,a=Vn.SolveTOIPositionConstraints_s_P;let h=0;for(let l=0;l<this.m_count;++l){const _=this.m_positionConstraints[l],m=_.indexA,c=_.indexB,u=_.localCenterA,d=_.localCenterB,f=_.pointCount;let p=0,y=0;m!==t&&m!==e||(p=_.invMassA,y=_.invIA);let x=0,S=0;c!==t&&c!==e||(x=_.invMassB,S=_.invIB);const A=this.m_positions[m].c;let C=this.m_positions[m].a;const V=this.m_positions[c].c;let w=this.m_positions[c].a;for(let t=0;t<f;++t){s.q.SetAngle(C),i.q.SetAngle(w),Mt.SubVV(A,Lt.MulRV(s.q,u,Mt.s_t0),s.p),Mt.SubVV(V,Lt.MulRV(i.q,d,Mt.s_t0),i.p),n.Initialize(_,s,i,t);const e=n.normal,l=n.point,m=n.separation;Mt.SubVV(l,A,o),Mt.SubVV(l,V,r),h=ht(h,m);const c=_t(G*(m+B),-g,0),f=Mt.CrossVV(o,e),v=Mt.CrossVV(r,e),b=p+x+y*f*f+S*v*v,M=b>0?-c/b:0;Mt.MulSV(M,e,a),A.SelfMulSub(p,a),C-=y*Mt.CrossVV(o,a),V.SelfMulAdd(x,a),w+=S*Mt.CrossVV(r,a)}this.m_positions[m].a=C,this.m_positions[c].a=w}return h>=-1.5*B}}Vn.InitializeVelocityConstraints_s_xfA=new Rt,Vn.InitializeVelocityConstraints_s_xfB=new Rt,Vn.InitializeVelocityConstraints_s_worldManifold=new Ve,Vn.WarmStart_s_P=new Mt,Vn.SolveVelocityConstraints_s_dv=new Mt,Vn.SolveVelocityConstraints_s_dv1=new Mt,Vn.SolveVelocityConstraints_s_dv2=new Mt,Vn.SolveVelocityConstraints_s_P=new Mt,Vn.SolveVelocityConstraints_s_a=new Mt,Vn.SolveVelocityConstraints_s_b=new Mt,Vn.SolveVelocityConstraints_s_x=new Mt,Vn.SolveVelocityConstraints_s_d=new Mt,Vn.SolveVelocityConstraints_s_P1=new Mt,Vn.SolveVelocityConstraints_s_P2=new Mt,Vn.SolveVelocityConstraints_s_P1P2=new Mt,Vn.SolvePositionConstraints_s_xfA=new Rt,Vn.SolvePositionConstraints_s_xfB=new Rt,Vn.SolvePositionConstraints_s_psm=new Cn,Vn.SolvePositionConstraints_s_rA=new Mt,Vn.SolvePositionConstraints_s_rB=new Mt,Vn.SolvePositionConstraints_s_P=new Mt,Vn.SolveTOIPositionConstraints_s_xfA=new Rt,Vn.SolveTOIPositionConstraints_s_xfB=new Rt,Vn.SolveTOIPositionConstraints_s_psm=new Cn,Vn.SolveTOIPositionConstraints_s_rA=new Mt,Vn.SolveTOIPositionConstraints_s_rB=new Mt,Vn.SolveTOIPositionConstraints_s_P=new Mt;class gn extends Mi{constructor(){super(gi.e_frictionJoint),this.localAnchorA=new Mt,this.localAnchorB=new Mt,this.maxForce=0,this.maxTorque=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB)}}class wn extends Gi{constructor(t){super(t),this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_linearImpulse=new Mt,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new Dt,this.m_angularMass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_K=new Dt,this.m_localAnchorA.Copy(l(t.localAnchorA,Mt.ZERO)),this.m_localAnchorB.Copy(l(t.localAnchorB,Mt.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=l(t.maxForce,0),this.m_maxTorque=l(t.maxTorque,0),this.m_linearMass.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),h=this.m_qB.SetAngle(n);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const l=Lt.MulRV(a,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const _=Lt.MulRV(h,this.m_lalcB,this.m_rB),m=this.m_invMassA,c=this.m_invMassB,u=this.m_invIA,d=this.m_invIB,f=this.m_K;if(f.ex.x=m+c+u*l.y*l.y+d*_.y*_.y,f.ex.y=-u*l.x*l.y-d*_.x*_.y,f.ey.x=f.ex.y,f.ey.y=m+c+u*l.x*l.x+d*_.x*_.x,f.GetInverse(this.m_linearMass),this.m_angularMass=u+d,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;s.SelfMulSub(m,e),i-=u*(Mt.CrossVV(this.m_rA,e)+this.m_angularImpulse),o.SelfMulAdd(c,e),r+=d*(Mt.CrossVV(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,h=this.m_invIB,l=t.step.dt;{const t=n-s;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,o=l*this.m_maxTorque;this.m_angularImpulse=_t(this.m_angularImpulse+e,-o,o),e=this.m_angularImpulse-i,s-=a*e,n+=h*e}{const t=Mt.SubVV(Mt.AddVCrossSV(i,n,this.m_rB,Mt.s_t0),Mt.AddVCrossSV(e,s,this.m_rA,Mt.s_t1),wn.SolveVelocityConstraints_s_Cdot_v2),_=Dt.MulMV(this.m_linearMass,t,wn.SolveVelocityConstraints_s_impulseV).SelfNeg(),m=wn.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(_);const c=l*this.m_maxForce;this.m_linearImpulse.LengthSquared()>c*c&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(c)),Mt.SubVV(this.m_linearImpulse,m,_),e.SelfMulSub(o,_),s-=a*Mt.CrossVV(this.m_rA,_),i.SelfMulAdd(r,_),n+=h*Mt.CrossVV(this.m_rB,_)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_linearImpulse.x,e.y=t*this.m_linearImpulse.y,e}GetReactionTorque(t){return t*this.m_angularImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}wn.SolveVelocityConstraints_s_Cdot_v2=new Mt,wn.SolveVelocityConstraints_s_impulseV=new Mt,wn.SolveVelocityConstraints_s_oldImpulseV=new Mt;class vn extends Mi{constructor(){super(gi.e_gearJoint),this.ratio=1}}class bn extends Gi{constructor(t){let e,s;super(t),this.m_typeA=gi.e_unknownJoint,this.m_typeB=gi.e_unknownJoint,this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_localAnchorC=new Mt,this.m_localAnchorD=new Mt,this.m_localAxisC=new Mt,this.m_localAxisD=new Mt,this.m_referenceAngleA=0,this.m_referenceAngleB=0,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_indexC=0,this.m_indexD=0,this.m_lcA=new Mt,this.m_lcB=new Mt,this.m_lcC=new Mt,this.m_lcD=new Mt,this.m_mA=0,this.m_mB=0,this.m_mC=0,this.m_mD=0,this.m_iA=0,this.m_iB=0,this.m_iC=0,this.m_iD=0,this.m_JvAC=new Mt,this.m_JvBD=new Mt,this.m_JwA=0,this.m_JwB=0,this.m_JwC=0,this.m_JwD=0,this.m_mass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_qC=new Lt,this.m_qD=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_lalcC=new Mt,this.m_lalcD=new Mt,this.m_joint1=t.joint1,this.m_joint2=t.joint2,this.m_typeA=this.m_joint1.GetType(),this.m_typeB=this.m_joint2.GetType(),this.m_bodyC=this.m_joint1.GetBodyA(),this.m_bodyA=this.m_joint1.GetBodyB();const i=this.m_bodyA.m_xf,n=this.m_bodyA.m_sweep.a,o=this.m_bodyC.m_xf,r=this.m_bodyC.m_sweep.a;if(this.m_typeA===gi.e_revoluteJoint){const s=t.joint1;this.m_localAnchorC.Copy(s.m_localAnchorA),this.m_localAnchorA.Copy(s.m_localAnchorB),this.m_referenceAngleA=s.m_referenceAngle,this.m_localAxisC.SetZero(),e=n-r-this.m_referenceAngleA}else{const s=t.joint1;this.m_localAnchorC.Copy(s.m_localAnchorA),this.m_localAnchorA.Copy(s.m_localAnchorB),this.m_referenceAngleA=s.m_referenceAngle,this.m_localAxisC.Copy(s.m_localXAxisA);const n=this.m_localAnchorC,r=Lt.MulTRV(o.q,Mt.AddVV(Lt.MulRV(i.q,this.m_localAnchorA,Mt.s_t0),Mt.SubVV(i.p,o.p,Mt.s_t1),Mt.s_t0),Mt.s_t0);e=Mt.DotVV(Mt.SubVV(r,n,Mt.s_t0),this.m_localAxisC)}this.m_bodyD=this.m_joint2.GetBodyA(),this.m_bodyB=this.m_joint2.GetBodyB();const a=this.m_bodyB.m_xf,h=this.m_bodyB.m_sweep.a,_=this.m_bodyD.m_xf,m=this.m_bodyD.m_sweep.a;if(this.m_typeB===gi.e_revoluteJoint){const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.SetZero(),s=h-m-this.m_referenceAngleB}else{const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.Copy(e.m_localXAxisA);const i=this.m_localAnchorD,n=Lt.MulTRV(_.q,Mt.AddVV(Lt.MulRV(a.q,this.m_localAnchorB,Mt.s_t0),Mt.SubVV(a.p,_.p,Mt.s_t1),Mt.s_t0),Mt.s_t0);s=Mt.DotVV(Mt.SubVV(n,i,Mt.s_t0),this.m_localAxisD)}this.m_ratio=l(t.ratio,1),this.m_constant=e+this.m_ratio*s,this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_indexC=this.m_bodyC.m_islandIndex,this.m_indexD=this.m_bodyD.m_islandIndex,this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter),this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter),this.m_mA=this.m_bodyA.m_invMass,this.m_mB=this.m_bodyB.m_invMass,this.m_mC=this.m_bodyC.m_invMass,this.m_mD=this.m_bodyD.m_invMass,this.m_iA=this.m_bodyA.m_invI,this.m_iB=this.m_bodyB.m_invI,this.m_iC=this.m_bodyC.m_invI,this.m_iD=this.m_bodyD.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const a=t.positions[this.m_indexC].a,h=t.velocities[this.m_indexC].v;let l=t.velocities[this.m_indexC].w;const _=t.positions[this.m_indexD].a,m=t.velocities[this.m_indexD].v;let c=t.velocities[this.m_indexD].w;const u=this.m_qA.SetAngle(e),d=this.m_qB.SetAngle(n),f=this.m_qC.SetAngle(a),p=this.m_qD.SetAngle(_);if(this.m_mass=0,this.m_typeA===gi.e_revoluteJoint)this.m_JvAC.SetZero(),this.m_JwA=1,this.m_JwC=1,this.m_mass+=this.m_iA+this.m_iC;else{const t=Lt.MulRV(f,this.m_localAxisC,bn.InitVelocityConstraints_s_u);Mt.SubVV(this.m_localAnchorC,this.m_lcC,this.m_lalcC);const e=Lt.MulRV(f,this.m_lalcC,bn.InitVelocityConstraints_s_rC);Mt.SubVV(this.m_localAnchorA,this.m_lcA,this.m_lalcA);const s=Lt.MulRV(u,this.m_lalcA,bn.InitVelocityConstraints_s_rA);this.m_JvAC.Copy(t),this.m_JwC=Mt.CrossVV(e,t),this.m_JwA=Mt.CrossVV(s,t),this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA}if(this.m_typeB===gi.e_revoluteJoint)this.m_JvBD.SetZero(),this.m_JwB=this.m_ratio,this.m_JwD=this.m_ratio,this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);else{const t=Lt.MulRV(p,this.m_localAxisD,bn.InitVelocityConstraints_s_u);Mt.SubVV(this.m_localAnchorD,this.m_lcD,this.m_lalcD);const e=Lt.MulRV(p,this.m_lalcD,bn.InitVelocityConstraints_s_rD);Mt.SubVV(this.m_localAnchorB,this.m_lcB,this.m_lalcB);const s=Lt.MulRV(d,this.m_lalcB,bn.InitVelocityConstraints_s_rB);Mt.MulSV(this.m_ratio,t,this.m_JvBD),this.m_JwD=this.m_ratio*Mt.CrossVV(e,t),this.m_JwB=this.m_ratio*Mt.CrossVV(s,t),this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB}this.m_mass=this.m_mass>0?1/this.m_mass:0,t.step.warmStarting?(s.SelfMulAdd(this.m_mA*this.m_impulse,this.m_JvAC),i+=this.m_iA*this.m_impulse*this.m_JwA,o.SelfMulAdd(this.m_mB*this.m_impulse,this.m_JvBD),r+=this.m_iB*this.m_impulse*this.m_JwB,h.SelfMulSub(this.m_mC*this.m_impulse,this.m_JvAC),l-=this.m_iC*this.m_impulse*this.m_JwC,m.SelfMulSub(this.m_mD*this.m_impulse,this.m_JvBD),c-=this.m_iD*this.m_impulse*this.m_JwD):this.m_impulse=0,t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r,t.velocities[this.m_indexC].w=l,t.velocities[this.m_indexD].w=c}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=t.velocities[this.m_indexC].v;let r=t.velocities[this.m_indexC].w;const a=t.velocities[this.m_indexD].v;let h=t.velocities[this.m_indexD].w,l=Mt.DotVV(this.m_JvAC,Mt.SubVV(e,o,Mt.s_t0))+Mt.DotVV(this.m_JvBD,Mt.SubVV(i,a,Mt.s_t0));l+=this.m_JwA*s-this.m_JwC*r+(this.m_JwB*n-this.m_JwD*h);const _=-this.m_mass*l;this.m_impulse+=_,e.SelfMulAdd(this.m_mA*_,this.m_JvAC),s+=this.m_iA*_*this.m_JwA,i.SelfMulAdd(this.m_mB*_,this.m_JvBD),n+=this.m_iB*_*this.m_JwB,o.SelfMulSub(this.m_mC*_,this.m_JvAC),r-=this.m_iC*_*this.m_JwC,a.SelfMulSub(this.m_mD*_,this.m_JvBD),h-=this.m_iD*_*this.m_JwD,t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n,t.velocities[this.m_indexC].w=r,t.velocities[this.m_indexD].w=h}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=t.positions[this.m_indexC].c;let r=t.positions[this.m_indexC].a;const a=t.positions[this.m_indexD].c;let h=t.positions[this.m_indexD].a;const l=this.m_qA.SetAngle(s),_=this.m_qB.SetAngle(n),m=this.m_qC.SetAngle(r),c=this.m_qD.SetAngle(h);let u,d;const f=this.m_JvAC,p=this.m_JvBD;let y,x,S,A,C=0;if(this.m_typeA===gi.e_revoluteJoint)f.SetZero(),y=1,S=1,C+=this.m_iA+this.m_iC,u=s-r-this.m_referenceAngleA;else{const t=Lt.MulRV(m,this.m_localAxisC,bn.SolvePositionConstraints_s_u),s=Lt.MulRV(m,this.m_lalcC,bn.SolvePositionConstraints_s_rC),i=Lt.MulRV(l,this.m_lalcA,bn.SolvePositionConstraints_s_rA);f.Copy(t),S=Mt.CrossVV(s,t),y=Mt.CrossVV(i,t),C+=this.m_mC+this.m_mA+this.m_iC*S*S+this.m_iA*y*y;const n=this.m_lalcC,r=Lt.MulTRV(m,Mt.AddVV(i,Mt.SubVV(e,o,Mt.s_t0),Mt.s_t0),Mt.s_t0);u=Mt.DotVV(Mt.SubVV(r,n,Mt.s_t0),this.m_localAxisC)}if(this.m_typeB===gi.e_revoluteJoint)p.SetZero(),x=this.m_ratio,A=this.m_ratio,C+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD),d=n-h-this.m_referenceAngleB;else{const t=Lt.MulRV(c,this.m_localAxisD,bn.SolvePositionConstraints_s_u),e=Lt.MulRV(c,this.m_lalcD,bn.SolvePositionConstraints_s_rD),s=Lt.MulRV(_,this.m_lalcB,bn.SolvePositionConstraints_s_rB);Mt.MulSV(this.m_ratio,t,p),A=this.m_ratio*Mt.CrossVV(e,t),x=this.m_ratio*Mt.CrossVV(s,t),C+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*A*A+this.m_iB*x*x;const n=this.m_lalcD,o=Lt.MulTRV(c,Mt.AddVV(s,Mt.SubVV(i,a,Mt.s_t0),Mt.s_t0),Mt.s_t0);d=Mt.DotVV(Mt.SubVV(o,n,Mt.s_t0),this.m_localAxisD)}const V=u+this.m_ratio*d-this.m_constant;let g=0;return C>0&&(g=-V/C),e.SelfMulAdd(this.m_mA*g,f),s+=this.m_iA*g*y,i.SelfMulAdd(this.m_mB*g,p),n+=this.m_iB*g*x,o.SelfMulSub(this.m_mC*g,f),r-=this.m_iC*g*S,a.SelfMulSub(this.m_mD*g,p),h-=this.m_iD*g*A,t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,t.positions[this.m_indexC].a=r,t.positions[this.m_indexD].a=h,0<B}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return Mt.MulSV(t*this.m_impulse,this.m_JvAC,e)}GetReactionTorque(t){return t*this.m_impulse*this.m_JwA}GetJoint1(){return this.m_joint1}GetJoint2(){return this.m_joint2}GetRatio(){return this.m_ratio}SetRatio(t){this.m_ratio=t}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex,i=this.m_joint1.m_index,n=this.m_joint2.m_index;t("  const jd: b2GearJointDef = new b2GearJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.joint1 = joints[%d];\n",i),t("  jd.joint2 = joints[%d];\n",n),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}bn.InitVelocityConstraints_s_u=new Mt,bn.InitVelocityConstraints_s_rA=new Mt,bn.InitVelocityConstraints_s_rB=new Mt,bn.InitVelocityConstraints_s_rC=new Mt,bn.InitVelocityConstraints_s_rD=new Mt,bn.SolvePositionConstraints_s_u=new Mt,bn.SolvePositionConstraints_s_rA=new Mt,bn.SolvePositionConstraints_s_rB=new Mt,bn.SolvePositionConstraints_s_rC=new Mt,bn.SolvePositionConstraints_s_rD=new Mt;class Mn{constructor(){this.m_bodies=[],this.m_contacts=[],this.m_joints=[],this.m_positions=cn.MakeArray(1024),this.m_velocities=un.MakeArray(1024),this.m_bodyCount=0,this.m_jointCount=0,this.m_contactCount=0,this.m_bodyCapacity=0,this.m_contactCapacity=0,this.m_jointCapacity=0}Initialize(t,e,s,i){if(this.m_bodyCapacity=t,this.m_contactCapacity=e,this.m_jointCapacity=s,this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0,this.m_listener=i,this.m_positions.length<t){const e=lt(2*this.m_positions.length,t);for(;this.m_positions.length<e;)this.m_positions[this.m_positions.length]=new cn}if(this.m_velocities.length<t){const e=lt(2*this.m_velocities.length,t);for(;this.m_velocities.length<e;)this.m_velocities[this.m_velocities.length]=new un}}Clear(){this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0}AddBody(t){t.m_islandIndex=this.m_bodyCount,this.m_bodies[this.m_bodyCount++]=t}AddContact(t){this.m_contacts[this.m_contactCount++]=t}AddJoint(t){this.m_joints[this.m_jointCount++]=t}Solve(t,e,s,i){const n=Mn.s_timer.Reset(),o=e.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c);const i=e.m_sweep.a,n=this.m_velocities[t].v.Copy(e.m_linearVelocity);let r=e.m_angularVelocity;e.m_sweep.c0.Copy(e.m_sweep.c),e.m_sweep.a0=e.m_sweep.a,e.m_type===wi.b2_dynamicBody&&(n.x+=o*e.m_invMass*(e.m_gravityScale*e.m_mass*s.x+e.m_force.x),n.y+=o*e.m_invMass*(e.m_gravityScale*e.m_mass*s.y+e.m_force.y),r+=o*e.m_invI*e.m_torque,n.SelfMul(1/(1+o*e.m_linearDamping)),r*=1/(1+o*e.m_angularDamping)),this.m_positions[t].a=i,this.m_velocities[t].w=r}n.Reset();const r=Mn.s_solverData;r.step.Copy(e),r.positions=this.m_positions,r.velocities=this.m_velocities;const a=Mn.s_contactSolverDef;a.step.Copy(e),a.contacts=this.m_contacts,a.count=this.m_contactCount,a.positions=this.m_positions,a.velocities=this.m_velocities;const h=Mn.s_contactSolver.Initialize(a);h.InitializeVelocityConstraints(),e.warmStarting&&h.WarmStart();for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].InitVelocityConstraints(r);t.solveInit=n.GetMilliseconds(),n.Reset();for(let t=0;t<e.velocityIterations;++t){for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].SolveVelocityConstraints(r);h.SolveVelocityConstraints()}h.StoreImpulses(),t.solveVelocity=n.GetMilliseconds();for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let s=this.m_positions[t].a;const i=this.m_velocities[t].v;let n=this.m_velocities[t].w;const r=Mt.MulSV(o,i,Mn.s_translation);if(Mt.DotVV(r,r)>b){const t=v/r.Length();i.SelfMul(t)}const a=o*n;if(a*a>P){n*=M/at(a)}e.x+=o*i.x,e.y+=o*i.y,s+=o*n,this.m_positions[t].a=s,this.m_velocities[t].w=n}n.Reset();let l=!1;for(let t=0;t<e.positionIterations;++t){const t=h.SolvePositionConstraints();let e=!0;for(let t=0;t<this.m_jointCount;++t){const s=this.m_joints[t].SolvePositionConstraints(r);e=e&&s}if(t&&e){l=!0;break}}for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];e.m_sweep.c.Copy(this.m_positions[t].c),e.m_sweep.a=this.m_positions[t].a,e.m_linearVelocity.Copy(this.m_velocities[t].v),e.m_angularVelocity=this.m_velocities[t].w,e.SynchronizeTransform()}if(t.solvePosition=n.GetMilliseconds(),this.Report(h.m_velocityConstraints),i){let t=_;const e=J*J,s=X*X;for(let i=0;i<this.m_bodyCount;++i){const n=this.m_bodies[i];n.GetType()!==wi.b2_staticBody&&(!n.m_autoSleepFlag||n.m_angularVelocity*n.m_angularVelocity>s||Mt.DotVV(n.m_linearVelocity,n.m_linearVelocity)>e?(n.m_sleepTime=0,t=0):(n.m_sleepTime+=o,t=ht(t,n.m_sleepTime)))}if(t>=j&&l)for(let t=0;t<this.m_bodyCount;++t){this.m_bodies[t].SetAwake(!1)}}}SolveTOI(t,e,s){for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c),this.m_positions[t].a=e.m_sweep.a,this.m_velocities[t].v.Copy(e.m_linearVelocity),this.m_velocities[t].w=e.m_angularVelocity}const i=Mn.s_contactSolverDef;i.contacts=this.m_contacts,i.count=this.m_contactCount,i.step.Copy(t),i.positions=this.m_positions,i.velocities=this.m_velocities;const n=Mn.s_contactSolver.Initialize(i);for(let i=0;i<t.positionIterations;++i){if(n.SolveTOIPositionConstraints(e,s))break}this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c),this.m_bodies[e].m_sweep.a0=this.m_positions[e].a,this.m_bodies[s].m_sweep.c0.Copy(this.m_positions[s].c),this.m_bodies[s].m_sweep.a0=this.m_positions[s].a,n.InitializeVelocityConstraints();for(let e=0;e<t.velocityIterations;++e)n.SolveVelocityConstraints();const o=t.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_positions[t].c;let s=this.m_positions[t].a;const i=this.m_velocities[t].v;let n=this.m_velocities[t].w;const r=Mt.MulSV(o,i,Mn.s_translation);if(Mt.DotVV(r,r)>b){const t=v/r.Length();i.SelfMul(t)}const a=o*n;if(a*a>P){n*=M/at(a)}e.SelfMulAdd(o,i),s+=o*n,this.m_positions[t].a=s,this.m_velocities[t].w=n;const h=this.m_bodies[t];h.m_sweep.c.Copy(e),h.m_sweep.a=s,h.m_linearVelocity.Copy(i),h.m_angularVelocity=n,h.SynchronizeTransform()}this.Report(n.m_velocityConstraints)}Report(t){if(null!==this.m_listener)for(let e=0;e<this.m_contactCount;++e){const s=this.m_contacts[e];if(!s)continue;const i=t[e],n=Mn.s_impulse;n.count=i.pointCount;for(let t=0;t<i.pointCount;++t)n.normalImpulses[t]=i.points[t].normalImpulse,n.tangentImpulses[t]=i.points[t].tangentImpulse;this.m_listener.PostSolve(s,n)}}}Mn.s_timer=new qt,Mn.s_solverData=new dn,Mn.s_contactSolverDef=new An,Mn.s_contactSolver=new Vn,Mn.s_translation=new Mt,Mn.s_impulse=new on;class Pn extends Mi{constructor(){super(gi.e_motorJoint),this.linearOffset=new Mt(0,0),this.angularOffset=0,this.maxForce=1,this.maxTorque=1,this.correctionFactor=.3}Initialize(t,e){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(this.bodyB.GetPosition(),this.linearOffset);const s=this.bodyA.GetAngle(),i=this.bodyB.GetAngle();this.angularOffset=i-s}}class In extends Gi{constructor(t){super(t),this.m_linearOffset=new Mt,this.m_angularOffset=0,this.m_linearImpulse=new Mt,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_correctionFactor=.3,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_linearError=new Mt,this.m_angularError=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new Dt,this.m_angularMass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_K=new Dt,this.m_linearOffset.Copy(l(t.linearOffset,Mt.ZERO)),this.m_linearImpulse.SetZero(),this.m_maxForce=l(t.maxForce,0),this.m_maxTorque=l(t.maxTorque,0),this.m_correctionFactor=l(t.correctionFactor,.3)}GetAnchorA(t){const e=this.m_bodyA.GetPosition();return t.x=e.x,t.y=e.y,t}GetAnchorB(t){const e=this.m_bodyB.GetPosition();return t.x=e.x,t.y=e.y,t}GetReactionForce(t,e){return Mt.MulSV(t,this.m_linearImpulse,e)}GetReactionTorque(t){return t*this.m_angularImpulse}SetLinearOffset(t){Mt.IsEqualToV(t,this.m_linearOffset)||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_linearOffset.Copy(t))}GetLinearOffset(){return this.m_linearOffset}SetAngularOffset(t){t!==this.m_angularOffset&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_angularOffset=t)}GetAngularOffset(){return this.m_angularOffset}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const l=this.m_qA.SetAngle(s),_=this.m_qB.SetAngle(r),m=Lt.MulRV(l,Mt.SubVV(this.m_linearOffset,this.m_localCenterA,Mt.s_t0),this.m_rA),c=Lt.MulRV(_,Mt.NegV(this.m_localCenterB,Mt.s_t0),this.m_rB),u=this.m_invMassA,d=this.m_invMassB,f=this.m_invIA,p=this.m_invIB,y=this.m_K;if(y.ex.x=u+d+f*m.y*m.y+p*c.y*c.y,y.ex.y=-f*m.x*m.y-p*c.x*c.y,y.ey.x=y.ex.y,y.ey.y=u+d+f*m.x*m.x+p*c.x*c.x,y.GetInverse(this.m_linearMass),this.m_angularMass=f+p,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),Mt.SubVV(Mt.AddVV(o,c,Mt.s_t0),Mt.AddVV(e,m,Mt.s_t1),this.m_linearError),this.m_angularError=r-s-this.m_angularOffset,t.step.warmStarting){this.m_linearImpulse.SelfMul(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;i.SelfMulSub(u,e),n-=f*(Mt.CrossVV(m,e)+this.m_angularImpulse),a.SelfMulAdd(d,e),h+=p*(Mt.CrossVV(c,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,h=this.m_invIB,l=t.step.dt,_=t.step.inv_dt;{const t=n-s+_*this.m_correctionFactor*this.m_angularError;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,o=l*this.m_maxTorque;this.m_angularImpulse=_t(this.m_angularImpulse+e,-o,o),e=this.m_angularImpulse-i,s-=a*e,n+=h*e}{const t=this.m_rA,m=this.m_rB,c=Mt.AddVV(Mt.SubVV(Mt.AddVV(i,Mt.CrossSV(n,m,Mt.s_t0),Mt.s_t0),Mt.AddVV(e,Mt.CrossSV(s,t,Mt.s_t1),Mt.s_t1),Mt.s_t2),Mt.MulSV(_*this.m_correctionFactor,this.m_linearError,Mt.s_t3),In.SolveVelocityConstraints_s_Cdot_v2),u=Dt.MulMV(this.m_linearMass,c,In.SolveVelocityConstraints_s_impulse_v2).SelfNeg(),d=In.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);this.m_linearImpulse.SelfAdd(u);const f=l*this.m_maxForce;this.m_linearImpulse.LengthSquared()>f*f&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.SelfMul(f)),Mt.SubVV(this.m_linearImpulse,d,u),e.SelfMulSub(o,u),s-=a*Mt.CrossVV(t,u),i.SelfMulAdd(r,u),n+=h*Mt.CrossVV(m,u)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){return!0}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2MotorJointDef = new b2MotorJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.linearOffset.Set(%.15f, %.15f);\n",this.m_linearOffset.x,this.m_linearOffset.y),t("  jd.angularOffset = %.15f;\n",this.m_angularOffset),t("  jd.maxForce = %.15f;\n",this.m_maxForce),t("  jd.maxTorque = %.15f;\n",this.m_maxTorque),t("  jd.correctionFactor = %.15f;\n",this.m_correctionFactor),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}In.SolveVelocityConstraints_s_Cdot_v2=new Mt,In.SolveVelocityConstraints_s_impulse_v2=new Mt,In.SolveVelocityConstraints_s_oldImpulse_v2=new Mt;class Gn extends Mi{constructor(){super(gi.e_mouseJoint),this.target=new Mt,this.maxForce=0,this.stiffness=5,this.damping=.7}}class Dn extends Gi{constructor(t){super(t),this.m_localAnchorB=new Mt,this.m_targetA=new Mt,this.m_stiffness=0,this.m_damping=0,this.m_beta=0,this.m_impulse=new Mt,this.m_maxForce=0,this.m_gamma=0,this.m_indexA=0,this.m_indexB=0,this.m_rB=new Mt,this.m_localCenterB=new Mt,this.m_invMassB=0,this.m_invIB=0,this.m_mass=new Dt,this.m_C=new Mt,this.m_qB=new Lt,this.m_lalcB=new Mt,this.m_K=new Dt,this.m_targetA.Copy(l(t.target,Mt.ZERO)),Rt.MulTXV(this.m_bodyB.GetTransform(),this.m_targetA,this.m_localAnchorB),this.m_maxForce=l(t.maxForce,0),this.m_impulse.SetZero(),this.m_stiffness=l(t.stiffness,0),this.m_damping=l(t.damping,0),this.m_beta=0,this.m_gamma=0}SetTarget(t){this.m_bodyB.IsAwake()||this.m_bodyB.SetAwake(!0),this.m_targetA.Copy(t)}GetTarget(){return this.m_targetA}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexB].c,s=t.positions[this.m_indexB].a,i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_qB.SetAngle(s),r=this.m_bodyB.GetMass(),a=2*u*this.m_stiffness,h=2*r*this.m_damping*a,l=r*(a*a),_=t.step.dt;this.m_gamma=_*(h+_*l),0!==this.m_gamma&&(this.m_gamma=1/this.m_gamma),this.m_beta=_*l*this.m_gamma,Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),Lt.MulRV(o,this.m_lalcB,this.m_rB);const m=this.m_K;m.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma,m.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y,m.ey.x=m.ex.y,m.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma,m.GetInverse(this.m_mass),this.m_C.x=e.x+this.m_rB.x-this.m_targetA.x,this.m_C.y=e.y+this.m_rB.y-this.m_targetA.y,this.m_C.SelfMul(this.m_beta),n*=.98,t.step.warmStarting?(this.m_impulse.SelfMul(t.step.dtRatio),i.x+=this.m_invMassB*this.m_impulse.x,i.y+=this.m_invMassB*this.m_impulse.y,n+=this.m_invIB*Mt.CrossVV(this.m_rB,this.m_impulse)):this.m_impulse.SetZero(),t.velocities[this.m_indexB].w=n}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexB].v;let s=t.velocities[this.m_indexB].w;const i=Mt.AddVCrossSV(e,s,this.m_rB,Dn.SolveVelocityConstraints_s_Cdot),n=Dt.MulMV(this.m_mass,Mt.AddVV(i,Mt.AddVV(this.m_C,Mt.MulSV(this.m_gamma,this.m_impulse,Mt.s_t0),Mt.s_t0),Mt.s_t0).SelfNeg(),Dn.SolveVelocityConstraints_s_impulse),o=Dn.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);this.m_impulse.SelfAdd(n);const r=t.step.dt*this.m_maxForce;this.m_impulse.LengthSquared()>r*r&&this.m_impulse.SelfMul(r/this.m_impulse.Length()),Mt.SubVV(this.m_impulse,o,n),e.SelfMulAdd(this.m_invMassB,n),s+=this.m_invIB*Mt.CrossVV(this.m_rB,n),t.velocities[this.m_indexB].w=s}SolvePositionConstraints(t){return!0}GetAnchorA(t){return t.x=this.m_targetA.x,t.y=this.m_targetA.y,t}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return Mt.MulSV(t,this.m_impulse,e)}GetReactionTorque(t){return 0}Dump(t){t("Mouse joint dumping is not supported.\n")}ShiftOrigin(t){this.m_targetA.SelfSub(t)}}Dn.SolveVelocityConstraints_s_Cdot=new Mt,Dn.SolveVelocityConstraints_s_impulse=new Mt,Dn.SolveVelocityConstraints_s_oldImpulse=new Mt;class Fn extends Mi{constructor(){super(gi.e_prismaticJoint),this.localAnchorA=new Mt,this.localAnchorB=new Mt,this.localAxisA=new Mt(1,0),this.referenceAngle=0,this.enableLimit=!1,this.lowerTranslation=0,this.upperTranslation=0,this.enableMotor=!1,this.maxMotorForce=0,this.motorSpeed=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.bodyA.GetLocalVector(i,this.localAxisA),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}}class Ln extends Gi{constructor(t){super(t),this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_localXAxisA=new Mt,this.m_localYAxisA=new Mt,this.m_referenceAngle=0,this.m_impulse=new Mt(0,0),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorForce=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_axis=new Mt(0,0),this.m_perp=new Mt(0,0),this.m_s1=0,this.m_s2=0,this.m_a1=0,this.m_a2=0,this.m_K=new Dt,this.m_K3=new Ft,this.m_K2=new Dt,this.m_translation=0,this.m_axialMass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localAnchorA.Copy(l(t.localAnchorA,Mt.ZERO)),this.m_localAnchorB.Copy(l(t.localAnchorB,Mt.ZERO)),this.m_localXAxisA.Copy(l(t.localAxisA,new Mt(1,0))).SelfNormalize(),Mt.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_referenceAngle=l(t.referenceAngle,0),this.m_lowerTranslation=l(t.lowerTranslation,0),this.m_upperTranslation=l(t.upperTranslation,0),this.m_maxMotorForce=l(t.maxMotorForce,0),this.m_motorSpeed=l(t.motorSpeed,0),this.m_enableLimit=l(t.enableLimit,!1),this.m_enableMotor=l(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const l=this.m_qA.SetAngle(s),_=this.m_qB.SetAngle(r);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=Lt.MulRV(l,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const c=Lt.MulRV(_,this.m_lalcB,this.m_rB),u=Mt.AddVV(Mt.SubVV(o,e,Mt.s_t0),Mt.SubVV(c,m,Mt.s_t1),Ln.InitVelocityConstraints_s_d),d=this.m_invMassA,f=this.m_invMassB,p=this.m_invIA,y=this.m_invIB;if(Lt.MulRV(l,this.m_localXAxisA,this.m_axis),this.m_a1=Mt.CrossVV(Mt.AddVV(u,m,Mt.s_t0),this.m_axis),this.m_a2=Mt.CrossVV(c,this.m_axis),this.m_axialMass=d+f+p*this.m_a1*this.m_a1+y*this.m_a2*this.m_a2,this.m_axialMass>0&&(this.m_axialMass=1/this.m_axialMass),Lt.MulRV(l,this.m_localYAxisA,this.m_perp),this.m_s1=Mt.CrossVV(Mt.AddVV(u,m,Mt.s_t0),this.m_perp),this.m_s2=Mt.CrossVV(c,this.m_perp),this.m_K.ex.x=d+f+p*this.m_s1*this.m_s1+y*this.m_s2*this.m_s2,this.m_K.ex.y=p*this.m_s1+y*this.m_s2,this.m_K.ey.x=this.m_K.ex.y,this.m_K.ey.y=p+y,0===this.m_K.ey.y&&(this.m_K.ey.y=1),this.m_enableLimit?this.m_translation=Mt.DotVV(this.m_axis,u):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor||(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,s=Mt.AddVV(Mt.MulSV(this.m_impulse.x,this.m_perp,Mt.s_t0),Mt.MulSV(e,this.m_axis,Mt.s_t1),Ln.InitVelocityConstraints_s_P),o=this.m_impulse.x*this.m_s1+this.m_impulse.y+e*this.m_a1,r=this.m_impulse.x*this.m_s2+this.m_impulse.y+e*this.m_a2;i.SelfMulSub(d,s),n-=p*o,a.SelfMulAdd(f,s),h+=y*r}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,h=this.m_invIB;if(this.m_enableMotor){const l=Mt.DotVV(this.m_axis,Mt.SubVV(i,e,Mt.s_t0))+this.m_a2*n-this.m_a1*s;let _=this.m_axialMass*(this.m_motorSpeed-l);const m=this.m_motorImpulse,c=t.step.dt*this.m_maxMotorForce;this.m_motorImpulse=_t(this.m_motorImpulse+_,-c,c),_=this.m_motorImpulse-m;const u=Mt.MulSV(_,this.m_axis,Ln.SolveVelocityConstraints_s_P),d=_*this.m_a1,f=_*this.m_a2;e.SelfMulSub(o,u),s-=a*d,i.SelfMulAdd(r,u),n+=h*f}if(this.m_enableLimit){{const l=this.m_translation-this.m_lowerTranslation,_=Mt.DotVV(this.m_axis,Mt.SubVV(i,e,Mt.s_t0))+this.m_a2*n-this.m_a1*s;let m=-this.m_axialMass*(_+lt(l,0)*t.step.inv_dt);const c=this.m_lowerImpulse;this.m_lowerImpulse=lt(this.m_lowerImpulse+m,0),m=this.m_lowerImpulse-c;const u=Mt.MulSV(m,this.m_axis,Ln.SolveVelocityConstraints_s_P),d=m*this.m_a1,f=m*this.m_a2;e.SelfMulSub(o,u),s-=a*d,i.SelfMulAdd(r,u),n+=h*f}{const l=this.m_upperTranslation-this.m_translation,_=Mt.DotVV(this.m_axis,Mt.SubVV(e,i,Mt.s_t0))+this.m_a1*s-this.m_a2*n;let m=-this.m_axialMass*(_+lt(l,0)*t.step.inv_dt);const c=this.m_upperImpulse;this.m_upperImpulse=lt(this.m_upperImpulse+m,0),m=this.m_upperImpulse-c;const u=Mt.MulSV(m,this.m_axis,Ln.SolveVelocityConstraints_s_P),d=m*this.m_a1,f=m*this.m_a2;e.SelfMulAdd(o,u),s+=a*d,i.SelfMulSub(r,u),n-=h*f}}{const t=Mt.DotVV(this.m_perp,Mt.SubVV(i,e,Mt.s_t0))+this.m_s2*n-this.m_s1*s,l=n-s,_=this.m_K.Solve(-t,-l,Ln.SolveVelocityConstraints_s_df);this.m_impulse.SelfAdd(_);const m=Mt.MulSV(_.x,this.m_perp,Ln.SolveVelocityConstraints_s_P),c=_.x*this.m_s1+_.y,u=_.x*this.m_s2+_.y;e.SelfMulSub(o,m),s-=a*c,i.SelfMulAdd(r,m),n+=h*u}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n),a=this.m_invMassA,h=this.m_invMassB,l=this.m_invIA,_=this.m_invIB,m=Lt.MulRV(o,this.m_lalcA,this.m_rA),c=Lt.MulRV(r,this.m_lalcB,this.m_rB),u=Mt.SubVV(Mt.AddVV(i,c,Mt.s_t0),Mt.AddVV(e,m,Mt.s_t1),Ln.SolvePositionConstraints_s_d),d=Lt.MulRV(o,this.m_localXAxisA,this.m_axis),f=Mt.CrossVV(Mt.AddVV(u,m,Mt.s_t0),d),p=Mt.CrossVV(c,d),y=Lt.MulRV(o,this.m_localYAxisA,this.m_perp),x=Mt.CrossVV(Mt.AddVV(u,m,Mt.s_t0),y),A=Mt.CrossVV(c,y);let C=Ln.SolvePositionConstraints_s_impulse;const V=Mt.DotVV(y,u),g=n-s-this.m_referenceAngle;let w=at(V);const v=at(g);let b=!1,M=0;if(this.m_enableLimit){const t=Mt.DotVV(d,u);at(this.m_upperTranslation-this.m_lowerTranslation)<2*B?(M=t,w=lt(w,at(t)),b=!0):t<=this.m_lowerTranslation?(M=ht(t-this.m_lowerTranslation,0),w=lt(w,this.m_lowerTranslation-t),b=!0):t>=this.m_upperTranslation&&(M=lt(t-this.m_upperTranslation,0),w=lt(w,t-this.m_upperTranslation),b=!0)}if(b){const t=a+h+l*x*x+_*A*A,e=l*x+_*A,s=l*x*f+_*A*p;let i=l+_;0===i&&(i=1);const n=l*f+_*p,o=a+h+l*f*f+_*p*p,r=this.m_K3;r.ex.SetXYZ(t,e,s),r.ey.SetXYZ(e,i,n),r.ez.SetXYZ(s,n,o),C=r.Solve33(-V,-g,-M,C)}else{const t=a+h+l*x*x+_*A*A,e=l*x+_*A;let s=l+_;0===s&&(s=1);const i=this.m_K2;i.ex.Set(t,e),i.ey.Set(e,s);const n=i.Solve(-V,-g,Ln.SolvePositionConstraints_s_impulse1);C.x=n.x,C.y=n.y,C.z=0}const P=Mt.AddVV(Mt.MulSV(C.x,y,Mt.s_t0),Mt.MulSV(C.z,d,Mt.s_t1),Ln.SolvePositionConstraints_s_P),I=C.x*x+C.y+C.z*f,G=C.x*A+C.y+C.z*p;return e.SelfMulSub(a,P),s-=l*I,i.SelfMulAdd(h,P),n+=_*G,t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,w<=B&&v<=S}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse.x*this.m_perp.x+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.x),e.y=t*(this.m_impulse.y*this.m_perp.y+(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_axis.y),e}GetReactionTorque(t){return t*this.m_impulse.y}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetReferenceAngle(){return this.m_referenceAngle}GetJointTranslation(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,Ln.GetJointTranslation_s_pA),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,Ln.GetJointTranslation_s_pB),s=Mt.SubVV(e,t,Ln.GetJointTranslation_s_d),i=this.m_bodyA.GetWorldVector(this.m_localXAxisA,Ln.GetJointTranslation_s_axis);return Mt.DotVV(s,i)}GetJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;Mt.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const s=Lt.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const i=Lt.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=Mt.AddVV(t.m_sweep.c,s,Mt.s_t0),o=Mt.AddVV(e.m_sweep.c,i,Mt.s_t1),r=Mt.SubVV(o,n,Mt.s_t2),a=t.GetWorldVector(this.m_localXAxisA,this.m_axis),h=t.m_linearVelocity,l=e.m_linearVelocity,_=t.m_angularVelocity,m=e.m_angularVelocity;return Mt.DotVV(r,Mt.CrossSV(_,a,Mt.s_t0))+Mt.DotVV(a,Mt.SubVV(Mt.AddVCrossSV(l,m,i,Mt.s_t0),Mt.AddVCrossSV(h,_,s,Mt.s_t1),Mt.s_t0))}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorForce(t){t!==this.m_maxMotorForce&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorForce=t)}GetMaxMotorForce(){return this.m_maxMotorForce}GetMotorForce(t){return t*this.m_motorImpulse}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerTranslation = %.15f;\n",this.m_lowerTranslation),t("  jd.upperTranslation = %.15f;\n",this.m_upperTranslation),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorForce = %.15f;\n",this.m_maxMotorForce),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=Rt.MulXV(e,this.m_localAnchorA,Ln.Draw_s_pA),n=Rt.MulXV(s,this.m_localAnchorB,Ln.Draw_s_pB),o=Lt.MulRV(e.q,this.m_localXAxisA,Ln.Draw_s_axis),r=Ln.Draw_s_c1,a=Ln.Draw_s_c2,h=Ln.Draw_s_c3,l=Ln.Draw_s_c4,_=Ln.Draw_s_c5;if(t.DrawSegment(i,n,_),this.m_enableLimit){const s=Mt.AddVMulSV(i,this.m_lowerTranslation,o,Ln.Draw_s_lower),n=Mt.AddVMulSV(i,this.m_upperTranslation,o,Ln.Draw_s_upper),l=Lt.MulRV(e.q,this.m_localYAxisA,Ln.Draw_s_perp);t.DrawSegment(s,n,r),t.DrawSegment(Mt.AddVMulSV(s,-.5,l,Mt.s_t0),Mt.AddVMulSV(s,.5,l,Mt.s_t1),a),t.DrawSegment(Mt.AddVMulSV(n,-.5,l,Mt.s_t0),Mt.AddVMulSV(n,.5,l,Mt.s_t1),h)}else t.DrawSegment(Mt.AddVMulSV(i,-1,o,Mt.s_t0),Mt.AddVMulSV(i,1,o,Mt.s_t1),r);t.DrawPoint(i,5,r),t.DrawPoint(n,5,l)}}Ln.InitVelocityConstraints_s_d=new Mt,Ln.InitVelocityConstraints_s_P=new Mt,Ln.SolveVelocityConstraints_s_P=new Mt,Ln.SolveVelocityConstraints_s_df=new Mt,Ln.SolvePositionConstraints_s_d=new Mt,Ln.SolvePositionConstraints_s_impulse=new Gt,Ln.SolvePositionConstraints_s_impulse1=new Mt,Ln.SolvePositionConstraints_s_P=new Mt,Ln.GetJointTranslation_s_pA=new Mt,Ln.GetJointTranslation_s_pB=new Mt,Ln.GetJointTranslation_s_d=new Mt,Ln.GetJointTranslation_s_axis=new Mt,Ln.Draw_s_pA=new Mt,Ln.Draw_s_pB=new Mt,Ln.Draw_s_axis=new Mt,Ln.Draw_s_c1=new n(.7,.7,.7),Ln.Draw_s_c2=new n(.3,.9,.3),Ln.Draw_s_c3=new n(.9,.3,.3),Ln.Draw_s_c4=new n(.3,.3,.9),Ln.Draw_s_c5=new n(.4,.4,.4),Ln.Draw_s_lower=new Mt,Ln.Draw_s_upper=new Mt,Ln.Draw_s_perp=new Mt;const Rn=2;class Tn extends Mi{constructor(){super(gi.e_pulleyJoint),this.groundAnchorA=new Mt(-1,1),this.groundAnchorB=new Mt(1,1),this.localAnchorA=new Mt(-1,0),this.localAnchorB=new Mt(1,0),this.lengthA=0,this.lengthB=0,this.ratio=1,this.collideConnected=!0}Initialize(t,e,s,i,n,o,r){this.bodyA=t,this.bodyB=e,this.groundAnchorA.Copy(s),this.groundAnchorB.Copy(i),this.bodyA.GetLocalPoint(n,this.localAnchorA),this.bodyB.GetLocalPoint(o,this.localAnchorB),this.lengthA=Mt.DistanceVV(n,s),this.lengthB=Mt.DistanceVV(o,i),this.ratio=r}}class kn extends Gi{constructor(t){super(t),this.m_groundAnchorA=new Mt,this.m_groundAnchorB=new Mt,this.m_lengthA=0,this.m_lengthB=0,this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_uA=new Mt,this.m_uB=new Mt,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_groundAnchorA.Copy(l(t.groundAnchorA,new Mt(-1,1))),this.m_groundAnchorB.Copy(l(t.groundAnchorB,new Mt(1,0))),this.m_localAnchorA.Copy(l(t.localAnchorA,new Mt(-1,0))),this.m_localAnchorB.Copy(l(t.localAnchorB,new Mt(1,0))),this.m_lengthA=l(t.lengthA,0),this.m_lengthB=l(t.lengthB,0),this.m_ratio=l(t.ratio,1),this.m_constant=l(t.lengthA,0)+this.m_ratio*l(t.lengthB,0),this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let n=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;const l=this.m_qA.SetAngle(s),_=this.m_qB.SetAngle(r);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),Lt.MulRV(l,this.m_lalcA,this.m_rA),Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),Lt.MulRV(_,this.m_lalcB,this.m_rB),this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA),this.m_uB.Copy(o).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);const m=this.m_uA.Length(),c=this.m_uB.Length();m>10*B?this.m_uA.SelfMul(1/m):this.m_uA.SetZero(),c>10*B?this.m_uB.SelfMul(1/c):this.m_uB.SetZero();const u=Mt.CrossVV(this.m_rA,this.m_uA),d=Mt.CrossVV(this.m_rB,this.m_uB),f=this.m_invMassA+this.m_invIA*u*u,p=this.m_invMassB+this.m_invIB*d*d;if(this.m_mass=f+this.m_ratio*this.m_ratio*p,this.m_mass>0&&(this.m_mass=1/this.m_mass),t.step.warmStarting){this.m_impulse*=t.step.dtRatio;const e=Mt.MulSV(-this.m_impulse,this.m_uA,kn.InitVelocityConstraints_s_PA),s=Mt.MulSV(-this.m_ratio*this.m_impulse,this.m_uB,kn.InitVelocityConstraints_s_PB);i.SelfMulAdd(this.m_invMassA,e),n+=this.m_invIA*Mt.CrossVV(this.m_rA,e),a.SelfMulAdd(this.m_invMassB,s),h+=this.m_invIB*Mt.CrossVV(this.m_rB,s)}else this.m_impulse=0;t.velocities[this.m_indexA].w=n,t.velocities[this.m_indexB].w=h}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=Mt.AddVCrossSV(e,s,this.m_rA,kn.SolveVelocityConstraints_s_vpA),r=Mt.AddVCrossSV(i,n,this.m_rB,kn.SolveVelocityConstraints_s_vpB),a=-Mt.DotVV(this.m_uA,o)-this.m_ratio*Mt.DotVV(this.m_uB,r),h=-this.m_mass*a;this.m_impulse+=h;const l=Mt.MulSV(-h,this.m_uA,kn.SolveVelocityConstraints_s_PA),_=Mt.MulSV(-this.m_ratio*h,this.m_uB,kn.SolveVelocityConstraints_s_PB);e.SelfMulAdd(this.m_invMassA,l),s+=this.m_invIA*Mt.CrossVV(this.m_rA,l),i.SelfMulAdd(this.m_invMassB,_),n+=this.m_invIB*Mt.CrossVV(this.m_rB,_),t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=Lt.MulRV(o,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const h=Lt.MulRV(r,this.m_lalcB,this.m_rB),l=this.m_uA.Copy(e).SelfAdd(a).SelfSub(this.m_groundAnchorA),_=this.m_uB.Copy(i).SelfAdd(h).SelfSub(this.m_groundAnchorB),m=l.Length(),c=_.Length();m>10*B?l.SelfMul(1/m):l.SetZero(),c>10*B?_.SelfMul(1/c):_.SetZero();const u=Mt.CrossVV(a,l),d=Mt.CrossVV(h,_),f=this.m_invMassA+this.m_invIA*u*u,p=this.m_invMassB+this.m_invIB*d*d;let y=f+this.m_ratio*this.m_ratio*p;y>0&&(y=1/y);const x=this.m_constant-m-this.m_ratio*c,S=at(x),A=-y*x,C=Mt.MulSV(-A,l,kn.SolvePositionConstraints_s_PA),V=Mt.MulSV(-this.m_ratio*A,_,kn.SolvePositionConstraints_s_PB);return e.SelfMulAdd(this.m_invMassA,C),s+=this.m_invIA*Mt.CrossVV(a,C),i.SelfMulAdd(this.m_invMassB,V),n+=this.m_invIB*Mt.CrossVV(h,V),t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,S<B}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse*this.m_uB.x,e.y=t*this.m_impulse*this.m_uB.y,e}GetReactionTorque(t){return 0}GetGroundAnchorA(){return this.m_groundAnchorA}GetGroundAnchorB(){return this.m_groundAnchorB}GetLengthA(){return this.m_lengthA}GetLengthB(){return this.m_lengthB}GetRatio(){return this.m_ratio}GetCurrentLengthA(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,kn.GetCurrentLengthA_s_p),e=this.m_groundAnchorA;return Mt.DistanceVV(t,e)}GetCurrentLengthB(){const t=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,kn.GetCurrentLengthB_s_p),e=this.m_groundAnchorB;return Mt.DistanceVV(t,e)}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.groundAnchorA.Set(%.15f, %.15f);\n",this.m_groundAnchorA.x,this.m_groundAnchorA.y),t("  jd.groundAnchorB.Set(%.15f, %.15f);\n",this.m_groundAnchorB.x,this.m_groundAnchorB.y),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.lengthA = %.15f;\n",this.m_lengthA),t("  jd.lengthB = %.15f;\n",this.m_lengthB),t("  jd.ratio = %.15f;\n",this.m_ratio),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}ShiftOrigin(t){this.m_groundAnchorA.SelfSub(t),this.m_groundAnchorB.SelfSub(t)}}kn.InitVelocityConstraints_s_PA=new Mt,kn.InitVelocityConstraints_s_PB=new Mt,kn.SolveVelocityConstraints_s_vpA=new Mt,kn.SolveVelocityConstraints_s_vpB=new Mt,kn.SolveVelocityConstraints_s_PA=new Mt,kn.SolveVelocityConstraints_s_PB=new Mt,kn.SolvePositionConstraints_s_PA=new Mt,kn.SolvePositionConstraints_s_PB=new Mt,kn.GetCurrentLengthA_s_p=new Mt,kn.GetCurrentLengthB_s_p=new Mt;class qn extends Mi{constructor(){super(gi.e_revoluteJoint),this.localAnchorA=new Mt(0,0),this.localAnchorB=new Mt(0,0),this.referenceAngle=0,this.enableLimit=!1,this.lowerAngle=0,this.upperAngle=0,this.enableMotor=!1,this.motorSpeed=0,this.maxMotorTorque=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}}class zn extends Gi{constructor(t){super(t),this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_impulse=new Mt,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_enableMotor=!1,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_referenceAngle=0,this.m_lowerAngle=0,this.m_upperAngle=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_K=new Dt,this.m_angle=0,this.m_axialMass=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_localAnchorA.Copy(l(t.localAnchorA,Mt.ZERO)),this.m_localAnchorB.Copy(l(t.localAnchorB,Mt.ZERO)),this.m_referenceAngle=l(t.referenceAngle,0),this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerAngle=l(t.lowerAngle,0),this.m_upperAngle=l(t.upperAngle,0),this.m_maxMotorTorque=l(t.maxMotorTorque,0),this.m_motorSpeed=l(t.motorSpeed,0),this.m_enableLimit=l(t.enableLimit,!1),this.m_enableMotor=l(t.enableMotor,!1)}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),h=this.m_qB.SetAngle(n);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),Lt.MulRV(a,this.m_lalcA,this.m_rA),Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),Lt.MulRV(h,this.m_lalcB,this.m_rB);const l=this.m_invMassA,_=this.m_invMassB,m=this.m_invIA,c=this.m_invIB;let u;if(this.m_K.ex.x=l+_+this.m_rA.y*this.m_rA.y*m+this.m_rB.y*this.m_rB.y*c,this.m_K.ey.x=-this.m_rA.y*this.m_rA.x*m-this.m_rB.y*this.m_rB.x*c,this.m_K.ex.y=this.m_K.ey.x,this.m_K.ey.y=l+_+this.m_rA.x*this.m_rA.x*m+this.m_rB.x*this.m_rB.x*c,this.m_axialMass=m+c,this.m_axialMass>0?(this.m_axialMass=1/this.m_axialMass,u=!1):u=!0,this.m_angle=n-e-this.m_referenceAngle,(!1===this.m_enableLimit||u)&&(this.m_lowerImpulse=0,this.m_upperImpulse=0),(!1===this.m_enableMotor||u)&&(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,n=zn.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);s.SelfMulSub(l,n),i-=m*(Mt.CrossVV(this.m_rA,n)+e),o.SelfMulAdd(_,n),r+=c*(Mt.CrossVV(this.m_rB,n)+e)}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,h=this.m_invIB,l=a+h===0;if(this.m_enableMotor&&!l){const e=n-s-this.m_motorSpeed;let i=-this.m_axialMass*e;const o=this.m_motorImpulse,r=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=_t(this.m_motorImpulse+i,-r,r),i=this.m_motorImpulse-o,s-=a*i,n+=h*i}if(this.m_enableLimit&&!l){{const e=this.m_angle-this.m_lowerAngle,i=n-s;let o=-this.m_axialMass*(i+lt(e,0)*t.step.inv_dt);const r=this.m_lowerImpulse;this.m_lowerImpulse=lt(this.m_lowerImpulse+o,0),o=this.m_lowerImpulse-r,s-=a*o,n+=h*o}{const e=this.m_upperAngle-this.m_angle,i=s-n;let o=-this.m_axialMass*(i+lt(e,0)*t.step.inv_dt);const r=this.m_upperImpulse;this.m_upperImpulse=lt(this.m_upperImpulse+o,0),o=this.m_upperImpulse-r,s+=a*o,n-=h*o}}{const t=Mt.SubVV(Mt.AddVCrossSV(i,n,this.m_rB,Mt.s_t0),Mt.AddVCrossSV(e,s,this.m_rA,Mt.s_t1),zn.SolveVelocityConstraints_s_Cdot_v2),l=this.m_K.Solve(-t.x,-t.y,zn.SolveVelocityConstraints_s_impulse_v2);this.m_impulse.x+=l.x,this.m_impulse.y+=l.y,e.SelfMulSub(o,l),s-=a*Mt.CrossVV(this.m_rA,l),i.SelfMulAdd(r,l),n+=h*Mt.CrossVV(this.m_rB,l)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);let a=0,h=0;const l=this.m_invIA+this.m_invIB===0;if(this.m_enableLimit&&!l){const t=n-s-this.m_referenceAngle;let e=0;at(this.m_upperAngle-this.m_lowerAngle)<2*S?e=_t(t-this.m_lowerAngle,-w,w):t<=this.m_lowerAngle?e=_t(t-this.m_lowerAngle+S,-w,0):t>=this.m_upperAngle&&(e=_t(t-this.m_upperAngle-S,0,w));const i=-this.m_axialMass*e;s-=this.m_invIA*i,n+=this.m_invIB*i,a=at(e)}{o.SetAngle(s),r.SetAngle(n),Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const t=Lt.MulRV(o,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const a=Lt.MulRV(r,this.m_lalcB,this.m_rB),l=Mt.SubVV(Mt.AddVV(i,a,Mt.s_t0),Mt.AddVV(e,t,Mt.s_t1),zn.SolvePositionConstraints_s_C_v2);h=l.Length();const _=this.m_invMassA,m=this.m_invMassB,c=this.m_invIA,u=this.m_invIB,d=this.m_K;d.ex.x=_+m+c*t.y*t.y+u*a.y*a.y,d.ex.y=-c*t.x*t.y-u*a.x*a.y,d.ey.x=d.ex.y,d.ey.y=_+m+c*t.x*t.x+u*a.x*a.x;const f=d.Solve(l.x,l.y,zn.SolvePositionConstraints_s_impulse).SelfNeg();e.SelfMulSub(_,f),s-=c*Mt.CrossVV(t,f),i.SelfMulAdd(m,f),n+=u*Mt.CrossVV(a,f)}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,h<=B&&a<=S}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*(this.m_lowerImpulse-this.m_upperImpulse)}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle}GetJointSpeed(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}GetMotorTorque(t){return t*this.m_motorImpulse}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMaxMotorTorque(){return this.m_maxMotorTorque}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerAngle}GetUpperLimit(){return this.m_upperAngle}SetLimits(t,e){t===this.m_lowerAngle&&e===this.m_upperAngle||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerAngle=t,this.m_upperAngle=e)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.enableLimit = %s;\n",this.m_enableLimit?"true":"false"),t("  jd.lowerAngle = %.15f;\n",this.m_lowerAngle),t("  jd.upperAngle = %.15f;\n",this.m_upperAngle),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=Rt.MulXV(e,this.m_localAnchorA,zn.Draw_s_pA),n=Rt.MulXV(s,this.m_localAnchorB,zn.Draw_s_pB),o=zn.Draw_s_c1,r=zn.Draw_s_c2,a=zn.Draw_s_c3,h=zn.Draw_s_c4,l=zn.Draw_s_c5;t.DrawPoint(i,5,h),t.DrawPoint(n,5,l);const _=this.m_bodyA.GetAngle(),m=this.m_bodyB.GetAngle()-_-this.m_referenceAngle,c=.5,u=zn.Draw_s_r.Set(c*Math.cos(m),c*Math.sin(m));if(t.DrawSegment(n,Mt.AddVV(n,u,Mt.s_t0),o),t.DrawCircle(n,c,o),this.m_enableLimit){const e=zn.Draw_s_rlo.Set(c*Math.cos(this.m_lowerAngle),c*Math.sin(this.m_lowerAngle)),s=zn.Draw_s_rhi.Set(c*Math.cos(this.m_upperAngle),c*Math.sin(this.m_upperAngle));t.DrawSegment(n,Mt.AddVV(n,e,Mt.s_t0),r),t.DrawSegment(n,Mt.AddVV(n,s,Mt.s_t0),a)}const d=zn.Draw_s_color_;t.DrawSegment(e.p,i,d),t.DrawSegment(i,n,d),t.DrawSegment(s.p,n,d)}}zn.InitVelocityConstraints_s_P=new Mt,zn.SolveVelocityConstraints_s_Cdot_v2=new Mt,zn.SolveVelocityConstraints_s_impulse_v2=new Mt,zn.SolvePositionConstraints_s_C_v2=new Mt,zn.SolvePositionConstraints_s_impulse=new Mt,zn.Draw_s_pA=new Mt,zn.Draw_s_pB=new Mt,zn.Draw_s_c1=new n(.7,.7,.7),zn.Draw_s_c2=new n(.3,.9,.3),zn.Draw_s_c3=new n(.9,.3,.3),zn.Draw_s_c4=new n(.3,.3,.9),zn.Draw_s_c5=new n(.4,.4,.4),zn.Draw_s_color_=new n(.5,.8,.8),zn.Draw_s_r=new Mt,zn.Draw_s_rlo=new Mt,zn.Draw_s_rhi=new Mt;class En extends Mi{constructor(){super(gi.e_weldJoint),this.localAnchorA=new Mt,this.localAnchorB=new Mt,this.referenceAngle=0,this.stiffness=0,this.damping=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}}class Nn extends Gi{constructor(t){super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_referenceAngle=0,this.m_gamma=0,this.m_impulse=new Gt(0,0,0),this.m_indexA=0,this.m_indexB=0,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=new Ft,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_K=new Ft,this.m_stiffness=l(t.stiffness,0),this.m_damping=l(t.damping,0),this.m_localAnchorA.Copy(l(t.localAnchorA,Mt.ZERO)),this.m_localAnchorB.Copy(l(t.localAnchorB,Mt.ZERO)),this.m_referenceAngle=l(t.referenceAngle,0),this.m_impulse.SetZero()}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].a,o=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const a=this.m_qA.SetAngle(e),h=this.m_qB.SetAngle(n);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA),Lt.MulRV(a,this.m_lalcA,this.m_rA),Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB),Lt.MulRV(h,this.m_lalcB,this.m_rB);const l=this.m_invMassA,_=this.m_invMassB,m=this.m_invIA,c=this.m_invIB,u=this.m_K;if(u.ex.x=l+_+this.m_rA.y*this.m_rA.y*m+this.m_rB.y*this.m_rB.y*c,u.ey.x=-this.m_rA.y*this.m_rA.x*m-this.m_rB.y*this.m_rB.x*c,u.ez.x=-this.m_rA.y*m-this.m_rB.y*c,u.ex.y=u.ey.x,u.ey.y=l+_+this.m_rA.x*this.m_rA.x*m+this.m_rB.x*this.m_rB.x*c,u.ez.y=this.m_rA.x*m+this.m_rB.x*c,u.ex.z=u.ez.x,u.ey.z=u.ez.y,u.ez.z=m+c,this.m_stiffness>0){u.GetInverse22(this.m_mass);let s=m+c;const i=n-e-this.m_referenceAngle,o=this.m_damping,r=this.m_stiffness,a=t.step.dt;this.m_gamma=a*(o+a*r),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=i*a*r*this.m_gamma,s+=this.m_gamma,this.m_mass.ez.z=0!==s?1/s:0}else u.GetSymInverse33(this.m_mass),this.m_gamma=0,this.m_bias=0;if(t.step.warmStarting){this.m_impulse.SelfMul(t.step.dtRatio);const e=Nn.InitVelocityConstraints_s_P.Set(this.m_impulse.x,this.m_impulse.y);s.SelfMulSub(l,e),i-=m*(Mt.CrossVV(this.m_rA,e)+this.m_impulse.z),o.SelfMulAdd(_,e),r+=c*(Mt.CrossVV(this.m_rB,e)+this.m_impulse.z)}else this.m_impulse.SetZero();t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let n=t.velocities[this.m_indexB].w;const o=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,h=this.m_invIB;if(this.m_stiffness>0){const t=n-s,l=-this.m_mass.ez.z*(t+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=l,s-=a*l,n+=h*l;const _=Mt.SubVV(Mt.AddVCrossSV(i,n,this.m_rB,Mt.s_t0),Mt.AddVCrossSV(e,s,this.m_rA,Mt.s_t1),Nn.SolveVelocityConstraints_s_Cdot1),m=Ft.MulM33XY(this.m_mass,_.x,_.y,Nn.SolveVelocityConstraints_s_impulse1).SelfNeg();this.m_impulse.x+=m.x,this.m_impulse.y+=m.y;const c=m;e.SelfMulSub(o,c),s-=a*Mt.CrossVV(this.m_rA,c),i.SelfMulAdd(r,c),n+=h*Mt.CrossVV(this.m_rB,c)}else{const t=Mt.SubVV(Mt.AddVCrossSV(i,n,this.m_rB,Mt.s_t0),Mt.AddVCrossSV(e,s,this.m_rA,Mt.s_t1),Nn.SolveVelocityConstraints_s_Cdot1),l=n-s,_=Ft.MulM33XYZ(this.m_mass,t.x,t.y,l,Nn.SolveVelocityConstraints_s_impulse).SelfNeg();this.m_impulse.SelfAdd(_);const m=Nn.SolveVelocityConstraints_s_P.Set(_.x,_.y);e.SelfMulSub(o,m),s-=a*(Mt.CrossVV(this.m_rA,m)+_.z),i.SelfMulAdd(r,m),n+=h*(Mt.CrossVV(this.m_rB,m)+_.z)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=n}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a;const o=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n),a=this.m_invMassA,h=this.m_invMassB,l=this.m_invIA,_=this.m_invIB;Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const m=Lt.MulRV(o,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const c=Lt.MulRV(r,this.m_lalcB,this.m_rB);let u,d;const f=this.m_K;if(f.ex.x=a+h+m.y*m.y*l+c.y*c.y*_,f.ey.x=-m.y*m.x*l-c.y*c.x*_,f.ez.x=-m.y*l-c.y*_,f.ex.y=f.ey.x,f.ey.y=a+h+m.x*m.x*l+c.x*c.x*_,f.ez.y=m.x*l+c.x*_,f.ex.z=f.ez.x,f.ey.z=f.ez.y,f.ez.z=l+_,this.m_stiffness>0){const t=Mt.SubVV(Mt.AddVV(i,c,Mt.s_t0),Mt.AddVV(e,m,Mt.s_t1),Nn.SolvePositionConstraints_s_C1);u=t.Length(),d=0;const o=f.Solve22(t.x,t.y,Nn.SolvePositionConstraints_s_P).SelfNeg();e.SelfMulSub(a,o),s-=l*Mt.CrossVV(m,o),i.SelfMulAdd(h,o),n+=_*Mt.CrossVV(c,o)}else{const t=Mt.SubVV(Mt.AddVV(i,c,Mt.s_t0),Mt.AddVV(e,m,Mt.s_t1),Nn.SolvePositionConstraints_s_C1),o=n-s-this.m_referenceAngle;u=t.Length(),d=at(o);const r=f.Solve33(t.x,t.y,o,Nn.SolvePositionConstraints_s_impulse).SelfNeg(),p=Nn.SolvePositionConstraints_s_P.Set(r.x,r.y);e.SelfMulSub(a,p),s-=l*(Mt.CrossVV(this.m_rA,p)+r.z),i.SelfMulAdd(h,p),n+=_*(Mt.CrossVV(this.m_rB,p)+r.z)}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,u<=B&&d<=S}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*this.m_impulse.z}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2WeldJointDef = new b2WeldJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.referenceAngle = %.15f;\n",this.m_referenceAngle),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}}Nn.InitVelocityConstraints_s_P=new Mt,Nn.SolveVelocityConstraints_s_Cdot1=new Mt,Nn.SolveVelocityConstraints_s_impulse1=new Mt,Nn.SolveVelocityConstraints_s_impulse=new Gt,Nn.SolveVelocityConstraints_s_P=new Mt,Nn.SolvePositionConstraints_s_C1=new Mt,Nn.SolvePositionConstraints_s_P=new Mt,Nn.SolvePositionConstraints_s_impulse=new Gt;class jn extends Mi{constructor(){super(gi.e_wheelJoint),this.localAnchorA=new Mt(0,0),this.localAnchorB=new Mt(0,0),this.localAxisA=new Mt(1,0),this.enableLimit=!1,this.lowerTranslation=0,this.upperTranslation=0,this.enableMotor=!1,this.maxMotorTorque=0,this.motorSpeed=0,this.stiffness=0,this.damping=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.bodyA.GetLocalVector(i,this.localAxisA)}}class Jn extends Gi{constructor(t){super(t),this.m_localAnchorA=new Mt,this.m_localAnchorB=new Mt,this.m_localXAxisA=new Mt,this.m_localYAxisA=new Mt,this.m_impulse=0,this.m_motorImpulse=0,this.m_springImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_translation=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_stiffness=0,this.m_damping=0,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new Mt,this.m_localCenterB=new Mt,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_ax=new Mt,this.m_ay=new Mt,this.m_sAx=0,this.m_sBx=0,this.m_sAy=0,this.m_sBy=0,this.m_mass=0,this.m_motorMass=0,this.m_axialMass=0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_qA=new Lt,this.m_qB=new Lt,this.m_lalcA=new Mt,this.m_lalcB=new Mt,this.m_rA=new Mt,this.m_rB=new Mt,this.m_localAnchorA.Copy(l(t.localAnchorA,Mt.ZERO)),this.m_localAnchorB.Copy(l(t.localAnchorB,Mt.ZERO)),this.m_localXAxisA.Copy(l(t.localAxisA,Mt.UNITX)),Mt.CrossOneV(this.m_localXAxisA,this.m_localYAxisA),this.m_lowerTranslation=l(t.lowerTranslation,0),this.m_upperTranslation=l(t.upperTranslation,0),this.m_enableLimit=l(t.enableLimit,!1),this.m_maxMotorTorque=l(t.maxMotorTorque,0),this.m_motorSpeed=l(t.motorSpeed,0),this.m_enableMotor=l(t.enableMotor,!1),this.m_ax.SetZero(),this.m_ay.SetZero(),this.m_stiffness=l(t.stiffness,0),this.m_damping=l(t.damping,0)}GetMotorSpeed(){return this.m_motorSpeed}GetMaxMotorTorque(){return this.m_maxMotorTorque}SetSpringFrequencyHz(t){this.m_stiffness=t}GetSpringFrequencyHz(){return this.m_stiffness}SetSpringDampingRatio(t){this.m_damping=t}GetSpringDampingRatio(){return this.m_damping}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_invMassA,s=this.m_invMassB,i=this.m_invIA,n=this.m_invIB,o=t.positions[this.m_indexA].c,r=t.positions[this.m_indexA].a,a=t.velocities[this.m_indexA].v;let h=t.velocities[this.m_indexA].w;const l=t.positions[this.m_indexB].c,_=t.positions[this.m_indexB].a,m=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const u=this.m_qA.SetAngle(r),d=this.m_qB.SetAngle(_);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const f=Lt.MulRV(u,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const p=Lt.MulRV(d,this.m_lalcB,this.m_rB),y=Mt.SubVV(Mt.AddVV(l,p,Mt.s_t0),Mt.AddVV(o,f,Mt.s_t1),Jn.InitVelocityConstraints_s_d);Lt.MulRV(u,this.m_localYAxisA,this.m_ay),this.m_sAy=Mt.CrossVV(Mt.AddVV(y,f,Mt.s_t0),this.m_ay),this.m_sBy=Mt.CrossVV(p,this.m_ay),this.m_mass=e+s+i*this.m_sAy*this.m_sAy+n*this.m_sBy*this.m_sBy,this.m_mass>0&&(this.m_mass=1/this.m_mass),Lt.MulRV(u,this.m_localXAxisA,this.m_ax),this.m_sAx=Mt.CrossVV(Mt.AddVV(y,f,Mt.s_t0),this.m_ax),this.m_sBx=Mt.CrossVV(p,this.m_ax);const x=e+s+i*this.m_sAx*this.m_sAx+n*this.m_sBx*this.m_sBx;if(this.m_axialMass=x>0?1/x:0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_stiffness>0&&x>0){this.m_springMass=1/x;const e=Mt.DotVV(y,this.m_ax),s=t.step.dt;this.m_gamma=s*(this.m_damping+s*this.m_stiffness),this.m_gamma>0&&(this.m_gamma=1/this.m_gamma),this.m_bias=e*s*this.m_stiffness*this.m_gamma,this.m_springMass=x+this.m_gamma,this.m_springMass>0&&(this.m_springMass=1/this.m_springMass)}else this.m_springImpulse=0;if(this.m_enableLimit?this.m_translation=Mt.DotVV(this.m_ax,y):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor?(this.m_motorMass=i+n,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass)):(this.m_motorMass=0,this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_springImpulse*=t.step.dtRatio,this.m_motorImpulse*=t.step.dtRatio;const e=this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse,s=Mt.AddVV(Mt.MulSV(this.m_impulse,this.m_ay,Mt.s_t0),Mt.MulSV(e,this.m_ax,Mt.s_t1),Jn.InitVelocityConstraints_s_P),i=this.m_impulse*this.m_sAy+e*this.m_sAx+this.m_motorImpulse,n=this.m_impulse*this.m_sBy+e*this.m_sBx+this.m_motorImpulse;a.SelfMulSub(this.m_invMassA,s),h-=this.m_invIA*i,m.SelfMulAdd(this.m_invMassB,s),c+=this.m_invIB*n}else this.m_impulse=0,this.m_springImpulse=0,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=h,t.velocities[this.m_indexB].w=c}SolveVelocityConstraints(t){const e=this.m_invMassA,s=this.m_invMassB,i=this.m_invIA,n=this.m_invIB,o=t.velocities[this.m_indexA].v;let r=t.velocities[this.m_indexA].w;const a=t.velocities[this.m_indexB].v;let h=t.velocities[this.m_indexB].w;{const t=Mt.DotVV(this.m_ax,Mt.SubVV(a,o,Mt.s_t0))+this.m_sBx*h-this.m_sAx*r,l=-this.m_springMass*(t+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=l;const _=Mt.MulSV(l,this.m_ax,Jn.SolveVelocityConstraints_s_P),m=l*this.m_sAx,c=l*this.m_sBx;o.SelfMulSub(e,_),r-=i*m,a.SelfMulAdd(s,_),h+=n*c}{const e=h-r-this.m_motorSpeed;let s=-this.m_motorMass*e;const o=this.m_motorImpulse,a=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=_t(this.m_motorImpulse+s,-a,a),s=this.m_motorImpulse-o,r-=i*s,h+=n*s}if(this.m_enableLimit){{const l=this.m_translation-this.m_lowerTranslation,_=Mt.DotVV(this.m_ax,Mt.SubVV(a,o,Mt.s_t0))+this.m_sBx*h-this.m_sAx*r;let m=-this.m_axialMass*(_+lt(l,0)*t.step.inv_dt);const c=this.m_lowerImpulse;this.m_lowerImpulse=lt(this.m_lowerImpulse+m,0),m=this.m_lowerImpulse-c;const u=Mt.MulSV(m,this.m_ax,Jn.SolveVelocityConstraints_s_P),d=m*this.m_sAx,f=m*this.m_sBx;o.SelfMulSub(e,u),r-=i*d,a.SelfMulAdd(s,u),h+=n*f}{const l=this.m_upperTranslation-this.m_translation,_=Mt.DotVV(this.m_ax,Mt.SubVV(o,a,Mt.s_t0))+this.m_sAx*r-this.m_sBx*h;let m=-this.m_axialMass*(_+lt(l,0)*t.step.inv_dt);const c=this.m_upperImpulse;this.m_upperImpulse=lt(this.m_upperImpulse+m,0),m=this.m_upperImpulse-c;const u=Mt.MulSV(m,this.m_ax,Jn.SolveVelocityConstraints_s_P),d=m*this.m_sAx,f=m*this.m_sBx;o.SelfMulAdd(e,u),r+=i*d,a.SelfMulSub(s,u),h-=n*f}}{const t=Mt.DotVV(this.m_ay,Mt.SubVV(a,o,Mt.s_t0))+this.m_sBy*h-this.m_sAy*r,l=-this.m_mass*t;this.m_impulse+=l;const _=Mt.MulSV(l,this.m_ay,Jn.SolveVelocityConstraints_s_P),m=l*this.m_sAy,c=l*this.m_sBy;o.SelfMulSub(e,_),r-=i*m,a.SelfMulAdd(s,_),h+=n*c}t.velocities[this.m_indexA].w=r,t.velocities[this.m_indexB].w=h}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let n=t.positions[this.m_indexB].a,o=0;if(this.m_enableLimit){const t=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=Lt.MulRV(t,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const h=Lt.MulRV(r,this.m_lalcB,this.m_rB),l=Mt.AddVV(Mt.SubVV(i,e,Mt.s_t0),Mt.SubVV(h,a,Mt.s_t1),Jn.SolvePositionConstraints_s_d),_=Lt.MulRV(t,this.m_localXAxisA,this.m_ax),m=Mt.CrossVV(Mt.AddVV(l,a,Mt.s_t0),this.m_ax),c=Mt.CrossVV(h,this.m_ax);let u=0;const d=Mt.DotVV(_,l);if(at(this.m_upperTranslation-this.m_lowerTranslation)<2*B?u=d:d<=this.m_lowerTranslation?u=ht(d-this.m_lowerTranslation,0):d>=this.m_upperTranslation&&(u=lt(d-this.m_upperTranslation,0)),0!==u){const t=this.m_invMassA+this.m_invMassB+this.m_invIA*m*m+this.m_invIB*c*c;let r=0;0!==t&&(r=-u/t);const a=Mt.MulSV(r,_,Jn.SolvePositionConstraints_s_P),h=r*m,l=r*c;e.SelfMulSub(this.m_invMassA,a),s-=this.m_invIA*h,i.SelfMulAdd(this.m_invMassB,a),n+=this.m_invIB*l,o=at(u)}}{const t=this.m_qA.SetAngle(s),r=this.m_qB.SetAngle(n);Mt.SubVV(this.m_localAnchorA,this.m_localCenterA,this.m_lalcA);const a=Lt.MulRV(t,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,this.m_localCenterB,this.m_lalcB);const h=Lt.MulRV(r,this.m_lalcB,this.m_rB),l=Mt.AddVV(Mt.SubVV(i,e,Mt.s_t0),Mt.SubVV(h,a,Mt.s_t1),Jn.SolvePositionConstraints_s_d),_=Lt.MulRV(t,this.m_localYAxisA,this.m_ay),m=Mt.CrossVV(Mt.AddVV(l,a,Mt.s_t0),_),c=Mt.CrossVV(h,_),u=Mt.DotVV(l,_),d=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let f=0;0!==d&&(f=-u/d);const p=Mt.MulSV(f,_,Jn.SolvePositionConstraints_s_P),y=f*m,x=f*c;e.SelfMulSub(this.m_invMassA,p),s-=this.m_invIA*y,i.SelfMulAdd(this.m_invMassB,p),n+=this.m_invIB*x,o=lt(o,at(u))}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=n,o<=B}GetDefinition(t){return t}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*(this.m_impulse*this.m_ay.x+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.x),e.y=t*(this.m_impulse*this.m_ay.y+(this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse)*this.m_ax.y),e}GetReactionTorque(t){return t*this.m_motorImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetJointTranslation(){return this.GetPrismaticJointTranslation()}GetJointLinearSpeed(){return this.GetPrismaticJointSpeed()}GetJointAngle(){return this.GetRevoluteJointAngle()}GetJointAngularSpeed(){return this.GetRevoluteJointSpeed()}GetPrismaticJointTranslation(){const t=this.m_bodyA,e=this.m_bodyB,s=t.GetWorldPoint(this.m_localAnchorA,new Mt),i=e.GetWorldPoint(this.m_localAnchorB,new Mt),n=Mt.SubVV(i,s,new Mt),o=t.GetWorldVector(this.m_localXAxisA,new Mt);return Mt.DotVV(n,o)}GetPrismaticJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB;Mt.SubVV(this.m_localAnchorA,t.m_sweep.localCenter,this.m_lalcA);const s=Lt.MulRV(t.m_xf.q,this.m_lalcA,this.m_rA);Mt.SubVV(this.m_localAnchorB,e.m_sweep.localCenter,this.m_lalcB);const i=Lt.MulRV(e.m_xf.q,this.m_lalcB,this.m_rB),n=Mt.AddVV(t.m_sweep.c,s,Mt.s_t0),o=Mt.AddVV(e.m_sweep.c,i,Mt.s_t1),r=Mt.SubVV(o,n,Mt.s_t2),a=t.GetWorldVector(this.m_localXAxisA,new Mt),h=t.m_linearVelocity,l=e.m_linearVelocity,_=t.m_angularVelocity,m=e.m_angularVelocity;return Mt.DotVV(r,Mt.CrossSV(_,a,Mt.s_t0))+Mt.DotVV(a,Mt.SubVV(Mt.AddVCrossSV(l,m,i,Mt.s_t0),Mt.AddVCrossSV(h,_,s,Mt.s_t1),Mt.s_t0))}GetRevoluteJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a}GetRevoluteJointSpeed(){const t=this.m_bodyA.m_angularVelocity;return this.m_bodyB.m_angularVelocity-t}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t)}SetMotorSpeed(t){t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t)}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMotorTorque(t){return t*this.m_motorImpulse}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0)}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}Dump(t){const e=this.m_bodyA.m_islandIndex,s=this.m_bodyB.m_islandIndex;t("  const jd: b2WheelJointDef = new b2WheelJointDef();\n"),t("  jd.bodyA = bodies[%d];\n",e),t("  jd.bodyB = bodies[%d];\n",s),t("  jd.collideConnected = %s;\n",this.m_collideConnected?"true":"false"),t("  jd.localAnchorA.Set(%.15f, %.15f);\n",this.m_localAnchorA.x,this.m_localAnchorA.y),t("  jd.localAnchorB.Set(%.15f, %.15f);\n",this.m_localAnchorB.x,this.m_localAnchorB.y),t("  jd.localAxisA.Set(%.15f, %.15f);\n",this.m_localXAxisA.x,this.m_localXAxisA.y),t("  jd.enableMotor = %s;\n",this.m_enableMotor?"true":"false"),t("  jd.motorSpeed = %.15f;\n",this.m_motorSpeed),t("  jd.maxMotorTorque = %.15f;\n",this.m_maxMotorTorque),t("  jd.stiffness = %.15f;\n",this.m_stiffness),t("  jd.damping = %.15f;\n",this.m_damping),t("  joints[%d] = this.m_world.CreateJoint(jd);\n",this.m_index)}Draw(t){const e=this.m_bodyA.GetTransform(),s=this.m_bodyB.GetTransform(),i=Rt.MulXV(e,this.m_localAnchorA,Jn.Draw_s_pA),n=Rt.MulXV(s,this.m_localAnchorB,Jn.Draw_s_pB),o=Lt.MulRV(e.q,this.m_localXAxisA,Jn.Draw_s_axis),r=Jn.Draw_s_c1,a=Jn.Draw_s_c2,h=Jn.Draw_s_c3,l=Jn.Draw_s_c4,_=Jn.Draw_s_c5;if(t.DrawSegment(i,n,_),this.m_enableLimit){const s=Mt.AddVMulSV(i,this.m_lowerTranslation,o,Jn.Draw_s_lower),n=Mt.AddVMulSV(i,this.m_upperTranslation,o,Jn.Draw_s_upper),l=Lt.MulRV(e.q,this.m_localYAxisA,Jn.Draw_s_perp);t.DrawSegment(s,n,r),t.DrawSegment(Mt.AddVMulSV(s,-.5,l,Mt.s_t0),Mt.AddVMulSV(s,.5,l,Mt.s_t1),a),t.DrawSegment(Mt.AddVMulSV(n,-.5,l,Mt.s_t0),Mt.AddVMulSV(n,.5,l,Mt.s_t1),h)}else t.DrawSegment(Mt.AddVMulSV(i,-1,o,Mt.s_t0),Mt.AddVMulSV(i,1,o,Mt.s_t1),r);t.DrawPoint(i,5,r),t.DrawPoint(n,5,l)}}var Xn,On,Zn,Un;Jn.InitVelocityConstraints_s_d=new Mt,Jn.InitVelocityConstraints_s_P=new Mt,Jn.SolveVelocityConstraints_s_P=new Mt,Jn.SolvePositionConstraints_s_d=new Mt,Jn.SolvePositionConstraints_s_P=new Mt,Jn.Draw_s_pA=new Mt,Jn.Draw_s_pB=new Mt,Jn.Draw_s_axis=new Mt,Jn.Draw_s_c1=new n(.7,.7,.7),Jn.Draw_s_c2=new n(.3,.9,.3),Jn.Draw_s_c3=new n(.9,.3,.3),Jn.Draw_s_c4=new n(.3,.3,.9),Jn.Draw_s_c5=new n(.4,.4,.4),Jn.Draw_s_lower=new Mt,Jn.Draw_s_upper=new Mt,Jn.Draw_s_perp=new Mt,function(t){t[t.b2_waterParticle=0]="b2_waterParticle",t[t.b2_zombieParticle=2]="b2_zombieParticle",t[t.b2_wallParticle=4]="b2_wallParticle",t[t.b2_springParticle=8]="b2_springParticle",t[t.b2_elasticParticle=16]="b2_elasticParticle",t[t.b2_viscousParticle=32]="b2_viscousParticle",t[t.b2_powderParticle=64]="b2_powderParticle",t[t.b2_tensileParticle=128]="b2_tensileParticle",t[t.b2_colorMixingParticle=256]="b2_colorMixingParticle",t[t.b2_destructionListenerParticle=512]="b2_destructionListenerParticle",t[t.b2_barrierParticle=1024]="b2_barrierParticle",t[t.b2_staticPressureParticle=2048]="b2_staticPressureParticle",t[t.b2_reactiveParticle=4096]="b2_reactiveParticle",t[t.b2_repulsiveParticle=8192]="b2_repulsiveParticle",t[t.b2_fixtureContactListenerParticle=16384]="b2_fixtureContactListenerParticle",t[t.b2_particleContactListenerParticle=32768]="b2_particleContactListenerParticle",t[t.b2_fixtureContactFilterParticle=65536]="b2_fixtureContactFilterParticle",t[t.b2_particleContactFilterParticle=131072]="b2_particleContactFilterParticle"}(Xn||(Xn={}));class Wn{constructor(){this.flags=0,this.position=new Mt,this.velocity=new Mt,this.color=new n(0,0,0,0),this.lifetime=0,this.userData=null,this.group=null}}function Qn(t,e,s){return _t(Math.ceil(Math.sqrt(t/(.01*e))*s),1,8)}class Yn{constructor(){this.m_index=D}GetIndex(){return this.m_index}SetIndex(t){this.m_index=t}}!function(t){t[t.b2_solidParticleGroup=1]="b2_solidParticleGroup",t[t.b2_rigidParticleGroup=2]="b2_rigidParticleGroup",t[t.b2_particleGroupCanBeEmpty=4]="b2_particleGroupCanBeEmpty",t[t.b2_particleGroupWillBeDestroyed=8]="b2_particleGroupWillBeDestroyed",t[t.b2_particleGroupNeedsUpdateDepth=16]="b2_particleGroupNeedsUpdateDepth",t[t.b2_particleGroupInternalMask=24]="b2_particleGroupInternalMask"}(On||(On={}));class Kn{constructor(){this.id="",this.flags=0,this.groupFlags=0,this.position=new Mt,this.angle=0,this.linearVelocity=new Mt,this.angularVelocity=0,this.color=new n,this.strength=1,this.userData=null,this.group=null}}class Hn{constructor(t,e){this.m_firstIndex=0,this.m_lastIndex=0,this.m_groupFlags=0,this.m_strength=1,this.m_prev=null,this.m_next=null,this.m_timestamp=-1,this.m_mass=0,this.m_inertia=0,this.m_center=new Mt,this.m_linearVelocity=new Mt,this.m_angularVelocity=0,this.m_transform=new Rt,this.m_userData=null,this.anchorOffset=0,this.relativePositions=[],this.m_system=t,this.id=e}get anchorIndex(){return this.m_firstIndex+this.anchorOffset}UpdateAnchor(){this.anchorOffset=Math.floor((this.m_lastIndex-this.m_firstIndex)/2);const t=this.m_system.m_positionBuffer.data[this.anchorIndex];this.relativePositions.length=0;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++){const s=this.m_system.m_positionBuffer.data[e],i=new Mt;Mt.SubVV(s,t,i),this.relativePositions.push(i)}}GetAnchorPosition(){return this.anchorIndex?this.m_system.m_positionBuffer.data[this.anchorIndex]:Mt.ZERO}GetOffsets(){if(!this.anchorIndex)return[];const t=this.m_system.m_positionBuffer.data[this.anchorIndex],e=[];for(let s=this.m_firstIndex;s<this.m_lastIndex;s++){const i=this.m_system.m_positionBuffer.data[s],n=new Mt;Mt.SubVV(i,t,n),n.SelfSub(this.relativePositions[s-this.m_firstIndex]),e.push(n)}return e}GetNext(){return this.m_next}GetParticleSystem(){return this.m_system}GetParticleCount(){return this.m_lastIndex-this.m_firstIndex}GetBufferIndex(){return this.m_firstIndex}ContainsParticle(t){return this.m_firstIndex<=t&&t<this.m_lastIndex}GetAllParticleFlags(){if(!this.m_system.m_flagsBuffer.data)throw new Error;let t=0;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)t|=this.m_system.m_flagsBuffer.data[e];return t}GetGroupFlags(){return this.m_groupFlags}SetGroupFlags(t){t|=this.m_groupFlags&On.b2_particleGroupInternalMask,this.m_system.SetGroupFlags(this,t)}GetMass(){return this.UpdateStatistics(),this.m_mass}GetInertia(){return this.UpdateStatistics(),this.m_inertia}GetCenter(){return this.UpdateStatistics(),this.m_center}GetLinearVelocity(){return this.UpdateStatistics(),this.m_linearVelocity}GetAngularVelocity(){return this.UpdateStatistics(),this.m_angularVelocity}GetTransform(){return this.m_transform}GetPosition(){return this.m_transform.p}GetAngle(){return this.m_transform.q.GetAngle()}GetLinearVelocityFromWorldPoint(t,e){const s=Hn.GetLinearVelocityFromWorldPoint_s_t0;return this.UpdateStatistics(),Mt.AddVCrossSV(this.m_linearVelocity,this.m_angularVelocity,Mt.SubVV(t,this.m_center,s),e)}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}ApplyForce(t){this.m_system.ApplyForce(this.m_firstIndex,this.m_lastIndex,t)}ApplyLinearImpulse(t){this.m_system.ApplyLinearImpulse(this.m_firstIndex,this.m_lastIndex,t)}DestroyParticles(t){if(this.m_system.m_world.IsLocked())throw new Error;for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)this.m_system.DestroyParticle(e,t)}UpdateStatistics(){if(!this.m_system.m_positionBuffer.data)throw new Error;if(!this.m_system.m_velocityBuffer.data)throw new Error;if(this.m_timestamp===this.m_system.m_timestamp)return;const t=this.m_system.GetParticleMass();this.m_mass=t*(this.m_lastIndex-this.m_firstIndex),this.m_center.SetZero(),this.m_linearVelocity.SetZero();for(let e=this.m_firstIndex;e<this.m_lastIndex;e++)this.m_center.SelfMulAdd(t,this.m_system.m_positionBuffer.data[e]),this.m_linearVelocity.SelfMulAdd(t,this.m_system.m_velocityBuffer.data[e]);if(this.m_mass>0){const t=1/this.m_mass;this.m_center.SelfMul(t),this.m_linearVelocity.SelfMul(t)}this.m_inertia=0,this.m_angularVelocity=0;const e=new Mt,s=new Mt;for(let i=this.m_firstIndex;i<this.m_lastIndex;i++)Mt.SubVV(this.m_system.m_positionBuffer.data[i],this.m_center,e),Mt.SubVV(this.m_system.m_velocityBuffer.data[i],this.m_linearVelocity,s),this.m_inertia+=t*Mt.DotVV(e,e),this.m_angularVelocity+=t*Mt.CrossVV(e,s);this.m_inertia>0&&(this.m_angularVelocity*=1/this.m_inertia),this.m_timestamp=this.m_system.m_timestamp}}Hn.GetLinearVelocityFromWorldPoint_s_t0=new Mt;class $n{constructor(t){this.m_buffer=[],this.m_front=0,this.m_back=0,this.m_buffer.fill(null,0,t)}get m_capacity(){return this.m_buffer.length}Push(t){if(this.m_back>=this.m_capacity){for(let t=this.m_front;t<this.m_back;t++)this.m_buffer[t-this.m_front]=this.m_buffer[t];this.m_back-=this.m_front,this.m_front=0}this.m_buffer[this.m_back]=t,this.m_back++}Pop(){this.m_buffer[this.m_front]=null,this.m_front++}Empty(){return this.m_front===this.m_back}Front(){const t=this.m_buffer[this.m_front];if(!t)throw new Error;return t}}class to{constructor(t){this.m_generatorCapacity=0,this.m_generatorCount=0,this.m_countX=0,this.m_countY=0,this.m_diagram=[],this.m_generatorBuffer=K(t,()=>new eo),this.m_generatorCapacity=t}AddGenerator(t,e,s){const i=this.m_generatorBuffer[this.m_generatorCount++];i.center.Copy(t),i.tag=e,i.necessary=s}Generate(t,e){const s=1/t,i=new Mt(+_,+_),n=new Mt(-_,-_);let o=0;for(let t=0;t<this.m_generatorCount;t++){const e=this.m_generatorBuffer[t];e.necessary&&(Mt.MinV(i,e.center,i),Mt.MaxV(n,e.center,n),++o)}if(0===o)return this.m_countX=0,void(this.m_countY=0);i.x-=e,i.y-=e,n.x+=e,n.y+=e,this.m_countX=1+Math.floor(s*(n.x-i.x)),this.m_countY=1+Math.floor(s*(n.y-i.y)),this.m_diagram=[];const r=new $n(4*this.m_countX*this.m_countY);for(let t=0;t<this.m_generatorCount;t++){const e=this.m_generatorBuffer[t];e.center.SelfSub(i).SelfMul(s);const n=Math.floor(e.center.x),o=Math.floor(e.center.y);n>=0&&o>=0&&n<this.m_countX&&o<this.m_countY&&r.Push(new so(n,o,n+o*this.m_countX,e))}for(;!r.Empty();){const t=r.Front(),e=t.m_x,s=t.m_y,i=t.m_i,n=t.m_generator;r.Pop(),this.m_diagram[i]||(this.m_diagram[i]=n,e>0&&r.Push(new so(e-1,s,i-1,n)),s>0&&r.Push(new so(e,s-1,i-this.m_countX,n)),e<this.m_countX-1&&r.Push(new so(e+1,s,i+1,n)),s<this.m_countY-1&&r.Push(new so(e,s+1,i+this.m_countX,n)))}for(let t=0;t<this.m_countY;t++)for(let e=0;e<this.m_countX-1;e++){const s=e+t*this.m_countX,i=this.m_diagram[s],n=this.m_diagram[s+1];i!==n&&(r.Push(new so(e,t,s,n)),r.Push(new so(e+1,t,s+1,i)))}for(let t=0;t<this.m_countY-1;t++)for(let e=0;e<this.m_countX;e++){const s=e+t*this.m_countX,i=this.m_diagram[s],n=this.m_diagram[s+this.m_countX];i!==n&&(r.Push(new so(e,t,s,n)),r.Push(new so(e,t+1,s+this.m_countX,i)))}for(;!r.Empty();){const t=r.Front(),e=t.m_x,s=t.m_y,i=t.m_i,n=t.m_generator;r.Pop();const o=this.m_diagram[i],a=n;if(o!==a){const t=o.center.x-e,n=o.center.y-s,h=a.center.x-e,l=a.center.y-s;t*t+n*n>h*h+l*l&&(this.m_diagram[i]=a,e>0&&r.Push(new so(e-1,s,i-1,a)),s>0&&r.Push(new so(e,s-1,i-this.m_countX,a)),e<this.m_countX-1&&r.Push(new so(e+1,s,i+1,a)),s<this.m_countY-1&&r.Push(new so(e,s+1,i+this.m_countX,a)))}}}GetNodes(t){for(let e=0;e<this.m_countY-1;e++)for(let s=0;s<this.m_countX-1;s++){const i=s+e*this.m_countX,n=this.m_diagram[i],o=this.m_diagram[i+1],r=this.m_diagram[i+this.m_countX],a=this.m_diagram[i+1+this.m_countX];o!==r&&(n!==o&&n!==r&&(n.necessary||o.necessary||r.necessary)&&t(n.tag,o.tag,r.tag),a!==o&&a!==r&&(n.necessary||o.necessary||r.necessary)&&t(o.tag,a.tag,r.tag))}}}class eo{constructor(){this.center=new Mt,this.tag=0,this.necessary=!1}}class so{constructor(t,e,s,i){this.m_x=t,this.m_y=e,this.m_i=s,this.m_generator=i}}function io(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function no(t,e){return t<e}function oo(t,e=0,s=t.length-e,i=no){let n=e;const o=[];let r=0;for(;;){for(;n+1<s;s++){const e=t[n+Math.floor(Math.random()*(s-n))];o[r++]=s;for(let o=n-1;;){for(;i(t[++o],e););for(;i(e,t[--s]););if(o>=s)break;io(t,o,s)}}if(0===r)break;n=s,s=o[--r]}return t}function ro(t,e=0,s=t.length-e,i=no){return oo(t,e,s,i)}function ao(t,e,s=t.length){let i=0;for(let n=0;n<s;++n)e(t[n])||(n!==i?io(t,i++,n):++i);return i}function ho(t,e,s,i,n){let o=s-e;for(;o>0;){const s=Math.floor(o/2);let r=e+s;n(t[r],i)?(e=++r,o-=s+1):o=s}return e}function lo(t,e,s,i,n){let o=s-e;for(;o>0;){const s=Math.floor(o/2);let r=e+s;n(i,t[r])?o=s:(e=++r,o-=s+1)}return e}function _o(t,e,s,i){let n=s;for(;e!==n;)io(t,e++,n++),n===i?n=s:e===s&&(s=n)}class mo{constructor(t){this.data=[],this.count=0,this.capacity=0,this.allocator=t}Append(){return this.count>=this.capacity&&this.Grow(),this.count++}Reserve(t){if(!(this.capacity>=t)){for(let e=this.capacity;e<t;++e)this.data[e]=this.allocator();this.capacity=t}}Grow(){const t=this.capacity?2*this.capacity:E;this.Reserve(t)}Free(){0!==this.data.length&&(this.data=[],this.capacity=0,this.count=0)}Shorten(t){}Data(){return this.data}GetCount(){return this.count}SetCount(t){this.count=t}GetCapacity(){return this.capacity}RemoveIf(t){this.count=ao(this.data,t,this.count)}Unique(t){this.count=function(t,e,s,i){if(e===s)return s;let n=e;for(;++e!==s;)i(t[n],t[e])||io(t,++n,e);return++n}(this.data,0,this.count,t)}}class co extends an{constructor(t){super(),this.m_system=t}ShouldQueryParticleSystem(t){return!1}ReportFixture(t){if(t.IsSensor())return!0;const e=t.GetShape().GetChildCount();for(let s=0;s<e;s++){const e=t.GetAABB(s),i=this.m_system.GetInsideBoundsEnumerator(e);let n;for(;(n=i.GetNext())>=0;)this.ReportFixtureAndParticle(t,s,n)}return!0}ReportParticle(t,e){return!1}ShouldCollideFixtureParticle(t,e){const s=this.m_system.GetFixtureContactFilter();if(s){if(this.m_system.GetFlagsBuffer()[e]&Xn.b2_fixtureContactFilterParticle)return s.ShouldCollideFixtureParticle(t,this.m_system,e)}return!0}}class uo{constructor(){this.indexA=0,this.indexB=0,this.weight=0,this.normal=new Mt,this.flags=0}Clone(){const t=new uo;return t.indexA=this.indexA,t.indexB=this.indexB,t.weight=this.weight,t.normal=this.normal,t.flags=this.flags,t}SetIndices(t,e){this.indexA=t,this.indexB=e}SetWeight(t){this.weight=t}SetNormal(t){this.normal.Copy(t)}SetFlags(t){this.flags=t}GetIndexA(){return this.indexA}GetIndexB(){return this.indexB}GetWeight(){return this.weight}GetNormal(){return this.normal}GetFlags(){return this.flags}IsEqual(t){return this.indexA===t.indexA&&this.indexB===t.indexB&&this.flags===t.flags&&this.weight===t.weight&&this.normal.x===t.normal.x&&this.normal.y===t.normal.y}IsNotEqual(t){return!this.IsEqual(t)}ApproximatelyEqual(t){return this.indexA===t.indexA&&this.indexB===t.indexB&&this.flags===t.flags&&at(this.weight-t.weight)<.01&&Mt.DistanceSquaredVV(this.normal,t.normal)<1e-4}}class fo{constructor(){this.index=0,this.weight=0,this.normal=new Mt,this.mass=0}Clone(){const t=new fo;return t.index=this.index,t.body=this.body,t.fixture=this.fixture,t.weight=this.weight,t.normal=this.normal,t.mass=this.mass,t}}class po{constructor(){this.indexA=0,this.indexB=0,this.flags=0,this.strength=0,this.distance=0}}class yo{constructor(){this.indexA=0,this.indexB=0,this.indexC=0,this.flags=0,this.strength=0,this.pa=new Mt(0,0),this.pb=new Mt(0,0),this.pc=new Mt(0,0),this.ka=0,this.kb=0,this.kc=0,this.s=0}}class xo{constructor(){this.strictContactCheck=!1,this.density=1,this.gravityScale=1,this.radius=1,this.maxCount=0,this.pressureStrength=.005,this.dampingStrength=1,this.elasticStrength=.25,this.springStrength=.25,this.viscousStrength=.25,this.surfaceTensionPressureStrength=.2,this.surfaceTensionNormalStrength=.2,this.repulsiveStrength=1,this.powderStrength=.5,this.ejectionStrength=.5,this.staticPressureStrength=.2,this.staticPressureRelaxation=.2,this.staticPressureIterations=8,this.colorMixingStrength=.5,this.destroyByAge=!0,this.lifetimeGranularity=1/60}Copy(t){return this.strictContactCheck=t.strictContactCheck,this.density=t.density,this.gravityScale=t.gravityScale,this.radius=t.radius,this.maxCount=t.maxCount,this.pressureStrength=t.pressureStrength,this.dampingStrength=t.dampingStrength,this.elasticStrength=t.elasticStrength,this.springStrength=t.springStrength,this.viscousStrength=t.viscousStrength,this.surfaceTensionPressureStrength=t.surfaceTensionPressureStrength,this.surfaceTensionNormalStrength=t.surfaceTensionNormalStrength,this.repulsiveStrength=t.repulsiveStrength,this.powderStrength=t.powderStrength,this.ejectionStrength=t.ejectionStrength,this.staticPressureStrength=t.staticPressureStrength,this.staticPressureRelaxation=t.staticPressureRelaxation,this.staticPressureIterations=t.staticPressureIterations,this.colorMixingStrength=t.colorMixingStrength,this.destroyByAge=t.destroyByAge,this.lifetimeGranularity=t.lifetimeGranularity,this}Clone(){return(new xo).Copy(this)}}class Bo{constructor(t,e){this.m_paused=!1,this.m_timestamp=0,this.m_allParticleFlags=0,this.m_needsUpdateAllParticleFlags=!1,this.m_allGroupFlags=0,this.m_needsUpdateAllGroupFlags=!1,this.m_hasForce=!1,this.m_iterationIndex=0,this.m_inverseDensity=0,this.m_particleDiameter=0,this.m_inverseDiameter=0,this.m_squaredDiameter=0,this.m_count=0,this.m_internalAllocatedCapacity=0,this.m_handleIndexBuffer=new So,this.m_flagsBuffer=new So,this.m_positionBuffer=new So,this.m_velocityBuffer=new So,this.m_positionConstraintBuffer=[],this.m_forceBuffer=[],this.m_weightBuffer=[],this.m_staticPressureBuffer=[],this.m_accumulationBuffer=[],this.m_accumulation2Buffer=[],this.m_depthBuffer=[],this.m_colorBuffer=new So,this.m_groupBuffer=[],this.m_userDataBuffer=new So,this.m_stuckThreshold=0,this.m_lastBodyContactStepBuffer=new So,this.m_bodyContactCountBuffer=new So,this.m_consecutiveContactStepsBuffer=new So,this.m_stuckParticleBuffer=new mo(()=>0),this.m_proxyBuffer=new mo(()=>new Ao),this.m_contactBuffer=new mo(()=>new uo),this.m_bodyContactBuffer=new mo(()=>new fo),this.m_pairBuffer=new mo(()=>new po),this.m_triadBuffer=new mo(()=>new yo),this.m_expirationTimeBuffer=new So,this.m_indexByExpirationTimeBuffer=new So,this.m_timeElapsed=0,this.m_expirationTimeBufferRequiresSorting=!1,this.m_groupCount=0,this.m_groupList=null,this.m_def=new xo,this.m_prev=null,this.m_next=null,this.UpdateBodyContacts_callback=null,this.SolveCollision_callback=null,this.SetStrictContactCheck(t.strictContactCheck),this.SetDensity(t.density),this.SetGravityScale(t.gravityScale),this.SetRadius(t.radius),this.SetMaxParticleCount(t.maxCount),this.m_def=t.Clone(),this.m_world=e,this.SetDestructionByAge(this.m_def.destroyByAge)}static computeTag(t,e){return(e+Bo.yOffset>>>0<<Bo.yShift)+(Bo.xScale*t+Bo.xOffset>>>0)>>>0}static computeRelativeTag(t,e,s){return t+(s<<Bo.yShift)+(e<<Bo.xShift)>>>0}Drop(){for(;this.m_groupList;)this.DestroyParticleGroup(this.m_groupList);this.FreeUserOverridableBuffer(this.m_handleIndexBuffer),this.FreeUserOverridableBuffer(this.m_flagsBuffer),this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer),this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer),this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer),this.FreeUserOverridableBuffer(this.m_positionBuffer),this.FreeUserOverridableBuffer(this.m_velocityBuffer),this.FreeUserOverridableBuffer(this.m_colorBuffer),this.FreeUserOverridableBuffer(this.m_userDataBuffer),this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer),this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer),this.FreeBuffer(this.m_forceBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_weightBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_staticPressureBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_accumulationBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_accumulation2Buffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_depthBuffer,this.m_internalAllocatedCapacity),this.FreeBuffer(this.m_groupBuffer,this.m_internalAllocatedCapacity)}CreateParticle(t){if(this.m_world.IsLocked())throw new Error;if(this.m_count>=this.m_internalAllocatedCapacity){const t=this.m_count?2*this.m_count:E;this.ReallocateInternalAllocatedBuffers(t)}if(this.m_count>=this.m_internalAllocatedCapacity){if(!this.m_def.destroyByAge)return D;this.DestroyOldestParticle(0,!1),this.SolveZombie()}const e=this.m_count++;this.m_flagsBuffer.data[e]=0,this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[e]=0),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[e]=0),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[e]=0),this.m_positionBuffer.data[e]=(this.m_positionBuffer.data[e]||new Mt).Copy(l(t.position,Mt.ZERO)),this.m_velocityBuffer.data[e]=(this.m_velocityBuffer.data[e]||new Mt).Copy(l(t.velocity,Mt.ZERO)),this.m_weightBuffer[e]=0,this.m_forceBuffer[e]=(this.m_forceBuffer[e]||new Mt).SetZero(),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[e]=0),this.m_depthBuffer&&(this.m_depthBuffer[e]=0);const s=(new n).Copy(l(t.color,n.ZERO));!this.m_colorBuffer.data&&s.IsZero()||(this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data),this.m_colorBuffer.data[e]=(this.m_colorBuffer.data[e]||new n).Copy(s)),(this.m_userDataBuffer.data||t.userData)&&(this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data),this.m_userDataBuffer.data[e]=t.userData),this.m_handleIndexBuffer.data&&(this.m_handleIndexBuffer.data[e]=null);const i=this.m_proxyBuffer.data[this.m_proxyBuffer.Append()],o=l(t.lifetime,0),r=o>0;(this.m_expirationTimeBuffer.data||r)&&(this.SetParticleLifetime(e,r?o:this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed())),this.m_indexByExpirationTimeBuffer.data[e]=e),i.index=e;const a=l(t.group,null);return this.m_groupBuffer[e]=a,a&&(a.m_firstIndex<a.m_lastIndex?(this.RotateBuffer(a.m_firstIndex,a.m_lastIndex,e),a.m_lastIndex=e+1):(a.m_firstIndex=e,a.m_lastIndex=e+1),a.UpdateAnchor()),this.SetParticleFlags(e,l(t.flags,0)),e}GetParticleHandleFromIndex(t){this.m_handleIndexBuffer.data=this.RequestBuffer(this.m_handleIndexBuffer.data);let e=this.m_handleIndexBuffer.data[t];return e||(e=new Yn,e.SetIndex(t),this.m_handleIndexBuffer.data[t]=e,e)}DestroyParticle(t,e=!1){let s=Xn.b2_zombieParticle;e&&(s|=Xn.b2_destructionListenerParticle),this.SetParticleFlags(t,this.m_flagsBuffer.data[t]|s)}DestroyOldestParticle(t,e=!1){const s=this.GetParticleCount(),i=this.m_indexByExpirationTimeBuffer.data[s-(t+1)],n=this.m_indexByExpirationTimeBuffer.data[t];this.DestroyParticle(this.m_expirationTimeBuffer.data[i]>0?i:n,e)}DestroyParticlesInShape(t,e,s=!1){const i=Bo.DestroyParticlesInShape_s_aabb;if(this.m_world.IsLocked())throw new Error;const n=new Io(this,t,e,s),o=i;return t.ComputeAABB(o,e,0),this.m_world.QueryAABB(n,o),n.Destroyed()}CreateParticleGroup(t){if(this.m_world.IsLocked())throw new Error;const e=Bo.CreateParticleGroup_s_transform;e.SetPositionAngle(l(t.position,Mt.ZERO),l(t.angle,0));const s=this.m_count;if(t.shape&&this.CreateParticlesWithShapeForGroup(t.shape,t,e),t.shapes&&this.CreateParticlesWithShapesForGroup(t.shapes,l(t.shapeCount,t.shapes.length),t,e),t.positionData){const s=l(t.particleCount,t.positionData.length);for(let i=0;i<s;i++){const s=t.positionData[i];this.CreateParticleForGroup(t,e,s)}}const i=this.m_count;let n=new Hn(this,t.id);n.m_firstIndex=s,n.m_lastIndex=i,n.m_strength=l(t.strength,1),n.m_userData=t.userData,n.m_transform.Copy(e),n.m_prev=null,n.m_next=this.m_groupList,this.m_groupList&&(this.m_groupList.m_prev=n),this.m_groupList=n,++this.m_groupCount;for(let t=s;t<i;t++)this.m_groupBuffer[t]=n;this.SetGroupFlags(n,l(t.groupFlags,0));const o=new Po;return this.UpdateContacts(!0),this.UpdatePairsAndTriads(s,i,o),t.group&&(this.JoinParticleGroups(t.group,n),n=t.group),n.UpdateAnchor(),n}JoinParticleGroups(t,e){if(this.m_world.IsLocked())throw new Error;this.RotateBuffer(e.m_firstIndex,e.m_lastIndex,this.m_count),this.RotateBuffer(t.m_firstIndex,t.m_lastIndex,e.m_firstIndex);const s=new Go(e.m_firstIndex);this.UpdateContacts(!0),this.UpdatePairsAndTriads(t.m_firstIndex,e.m_lastIndex,s);for(let s=e.m_firstIndex;s<e.m_lastIndex;s++)this.m_groupBuffer[s]=t;const i=t.m_groupFlags|e.m_groupFlags;this.SetGroupFlags(t,i),t.m_lastIndex=e.m_lastIndex,e.m_firstIndex=e.m_lastIndex,this.DestroyParticleGroup(e)}SplitParticleGroup(t){this.UpdateContacts(!0);const e=K(t.GetParticleCount(),t=>new Vo);Bo.InitializeParticleLists(t,e),this.MergeParticleListsInContact(t,e);const s=Bo.FindLongestParticleList(t,e);this.MergeZombieParticleListNodes(t,e,s),this.CreateParticleGroupsFromParticleList(t,e,s),this.UpdatePairsAndTriadsWithParticleList(t,e)}GetParticleGroupList(){return this.m_groupList}GetParticleGroupCount(){return this.m_groupCount}GetParticleCount(){return this.m_count}GetMaxParticleCount(){return this.m_def.maxCount}SetMaxParticleCount(t){this.m_def.maxCount=t}GetAllParticleFlags(){return this.m_allParticleFlags}GetAllGroupFlags(){return this.m_allGroupFlags}SetPaused(t){this.m_paused=t}GetPaused(){return this.m_paused}SetDensity(t){this.m_def.density=t,this.m_inverseDensity=1/this.m_def.density}GetDensity(){return this.m_def.density}SetGravityScale(t){this.m_def.gravityScale=t}GetGravityScale(){return this.m_def.gravityScale}SetDamping(t){this.m_def.dampingStrength=t}GetDamping(){return this.m_def.dampingStrength}SetStaticPressureIterations(t){this.m_def.staticPressureIterations=t}GetStaticPressureIterations(){return this.m_def.staticPressureIterations}SetRadius(t){this.m_particleDiameter=2*t,this.m_squaredDiameter=this.m_particleDiameter*this.m_particleDiameter,this.m_inverseDiameter=1/this.m_particleDiameter}GetRadius(){return this.m_particleDiameter/2}GetPositionBuffer(){return this.m_positionBuffer.data}GetVelocityBuffer(){return this.m_velocityBuffer.data}GetColorBuffer(){return this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data),this.m_colorBuffer.data}GetGroupBuffer(){return this.m_groupBuffer}GetWeightBuffer(){return this.m_weightBuffer}GetUserDataBuffer(){return this.m_userDataBuffer.data=this.RequestBuffer(this.m_userDataBuffer.data),this.m_userDataBuffer.data}GetFlagsBuffer(){return this.m_flagsBuffer.data}SetParticleFlags(t,e){this.m_flagsBuffer.data[t]&~e&&(this.m_needsUpdateAllParticleFlags=!0),~this.m_allParticleFlags&e&&(e&Xn.b2_tensileParticle&&(this.m_accumulation2Buffer=this.RequestBuffer(this.m_accumulation2Buffer)),e&Xn.b2_colorMixingParticle&&(this.m_colorBuffer.data=this.RequestBuffer(this.m_colorBuffer.data)),this.m_allParticleFlags|=e),this.m_flagsBuffer.data[t]=e}GetParticleFlags(t){return this.m_flagsBuffer.data[t]}SetFlagsBuffer(t){this.SetUserOverridableBuffer(this.m_flagsBuffer,t)}SetPositionBuffer(t){if(t instanceof Float32Array){if(t.length%2!=0)throw new Error;const e=t.length/2,s=new Array(e);for(let i=0;i<e;++i)s[i]=new It(t.subarray(2*i,2*i+2));t=s}this.SetUserOverridableBuffer(this.m_positionBuffer,t)}SetVelocityBuffer(t){if(t instanceof Float32Array){if(t.length%2!=0)throw new Error;const e=t.length/2,s=new Array(e);for(let i=0;i<e;++i)s[i]=new It(t.subarray(2*i,2*i+2));t=s}this.SetUserOverridableBuffer(this.m_velocityBuffer,t)}SetColorBuffer(t){if(t instanceof Float32Array){if(t.length%4!=0)throw new Error;const e=t.length/4,s=new Array(e);for(let i=0;i<e;++i)s[i]=new o(t.subarray(4*i,4*i+4));t=s}this.SetUserOverridableBuffer(this.m_colorBuffer,t)}SetUserDataBuffer(t){this.SetUserOverridableBuffer(this.m_userDataBuffer,t)}GetContacts(){return this.m_contactBuffer.data}GetContactCount(){return this.m_contactBuffer.count}GetBodyContacts(){return this.m_bodyContactBuffer.data}GetBodyContactCount(){return this.m_bodyContactBuffer.count}GetPairs(){return this.m_pairBuffer.data}GetPairCount(){return this.m_pairBuffer.count}GetTriads(){return this.m_triadBuffer.data}GetTriadCount(){return this.m_triadBuffer.count}SetStuckThreshold(t){this.m_stuckThreshold=t,t>0&&(this.m_lastBodyContactStepBuffer.data=this.RequestBuffer(this.m_lastBodyContactStepBuffer.data),this.m_bodyContactCountBuffer.data=this.RequestBuffer(this.m_bodyContactCountBuffer.data),this.m_consecutiveContactStepsBuffer.data=this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data))}GetStuckCandidates(){return this.m_stuckParticleBuffer.Data()}GetStuckCandidateCount(){return this.m_stuckParticleBuffer.GetCount()}ComputeCollisionEnergy(){const t=Bo.ComputeCollisionEnergy_s_v,e=this.m_velocityBuffer.data;let s=0;for(let i=0;i<this.m_contactBuffer.count;i++){const n=this.m_contactBuffer.data[i],o=n.indexA,r=n.indexB,a=n.normal,h=Mt.SubVV(e[r],e[o],t),l=Mt.DotVV(h,a);l<0&&(s+=l*l)}return.5*this.GetParticleMass()*s}SetStrictContactCheck(t){this.m_def.strictContactCheck=t}GetStrictContactCheck(){return this.m_def.strictContactCheck}SetParticleLifetime(t,e){const s=null===this.m_indexByExpirationTimeBuffer.data;if(this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data),this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data),s){const t=this.GetParticleCount();for(let e=0;e<t;++e)this.m_indexByExpirationTimeBuffer.data[e]=e}const i=e/this.m_def.lifetimeGranularity,n=i>0?this.GetQuantizedTimeElapsed()+i:i;n!==this.m_expirationTimeBuffer.data[t]&&(this.m_expirationTimeBuffer.data[t]=n,this.m_expirationTimeBufferRequiresSorting=!0)}GetParticleLifetime(t){return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[t])}SetDestructionByAge(t){t&&this.GetExpirationTimeBuffer(),this.m_def.destroyByAge=t}GetDestructionByAge(){return this.m_def.destroyByAge}GetExpirationTimeBuffer(){return this.m_expirationTimeBuffer.data=this.RequestBuffer(this.m_expirationTimeBuffer.data),this.m_expirationTimeBuffer.data}ExpirationTimeToLifetime(t){return(t>0?t-this.GetQuantizedTimeElapsed():t)*this.m_def.lifetimeGranularity}GetIndexByExpirationTimeBuffer(){return this.GetParticleCount()?this.SetParticleLifetime(0,this.GetParticleLifetime(0)):this.m_indexByExpirationTimeBuffer.data=this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data),this.m_indexByExpirationTimeBuffer.data}ParticleApplyLinearImpulse(t,e){this.ApplyLinearImpulse(t,t+1,e)}ApplyLinearImpulse(t,e,s){const i=this.m_velocityBuffer.data,n=(e-t)*this.GetParticleMass(),o=(new Mt).Copy(s).SelfMul(1/n);for(let s=t;s<e;s++)i[s].SelfAdd(o)}static IsSignificantForce(t){return 0!==t.x||0!==t.y}ParticleApplyForce(t,e){Bo.IsSignificantForce(e)&&this.ForceCanBeApplied(this.m_flagsBuffer.data[t])&&(this.PrepareForceBuffer(),this.m_forceBuffer[t].SelfAdd(e))}ApplyForce(t,e,s){const i=(new Mt).Copy(s).SelfMul(1/(e-t));if(Bo.IsSignificantForce(i)){this.PrepareForceBuffer();for(let s=t;s<e;s++)this.m_forceBuffer[s].SelfAdd(i)}}GetNext(){return this.m_next}QueryAABB(t,e){if(0===this.m_proxyBuffer.count)return;const s=this.m_proxyBuffer.count,i=ho(this.m_proxyBuffer.data,0,s,Bo.computeTag(this.m_inverseDiameter*e.lowerBound.x,this.m_inverseDiameter*e.lowerBound.y),Ao.CompareProxyTag),n=lo(this.m_proxyBuffer.data,i,s,Bo.computeTag(this.m_inverseDiameter*e.upperBound.x,this.m_inverseDiameter*e.upperBound.y),Ao.CompareTagProxy),o=this.m_positionBuffer.data;for(let s=i;s<n;++s){const i=this.m_proxyBuffer.data[s].index,n=o[i];if(e.lowerBound.x<n.x&&n.x<e.upperBound.x&&e.lowerBound.y<n.y&&n.y<e.upperBound.y&&!t.ReportParticle(this,i))break}}QueryShapeAABB(t,e,s,i=0){const n=Bo.QueryShapeAABB_s_aabb;e.ComputeAABB(n,s,i),this.QueryAABB(t,n)}QueryPointAABB(t,e,s=B){const i=Bo.QueryPointAABB_s_aabb;i.lowerBound.Set(e.x-s,e.y-s),i.upperBound.Set(e.x+s,e.y+s),this.QueryAABB(t,i)}RayCast(t,e,s){const i=Bo.RayCast_s_aabb,n=Bo.RayCast_s_p,o=Bo.RayCast_s_v,r=Bo.RayCast_s_n,a=Bo.RayCast_s_point;if(0===this.m_proxyBuffer.count)return;const h=this.m_positionBuffer.data,l=i;Mt.MinV(e,s,l.lowerBound),Mt.MaxV(e,s,l.upperBound);let _=1;const m=Mt.SubVV(s,e,o),c=Mt.DotVV(m,m),u=this.GetInsideBoundsEnumerator(l);let d;for(;(d=u.GetNext())>=0;){const s=Mt.SubVV(e,h[d],n),i=Mt.DotVV(s,m),o=i*i-c*(Mt.DotVV(s,s)-this.m_squaredDiameter);if(o>=0){const n=ft(o);let h=(-i-n)/c;if(h>_)continue;if(h<0&&(h=(-i+n)/c,h<0||h>_))continue;const l=Mt.AddVMulSV(s,h,m,r);l.Normalize();if(_=ht(_,t.ReportParticle(this,d,Mt.AddVMulSV(e,h,m,a),l,h)),_<=0)break}}}ComputeAABB(t){const e=this.GetParticleCount();t.lowerBound.x=+_,t.lowerBound.y=+_,t.upperBound.x=-_,t.upperBound.y=-_;const s=this.m_positionBuffer.data;for(let i=0;i<e;i++){const e=s[i];Mt.MinV(t.lowerBound,e,t.lowerBound),Mt.MaxV(t.upperBound,e,t.upperBound)}t.lowerBound.x-=this.m_particleDiameter,t.lowerBound.y-=this.m_particleDiameter,t.upperBound.x+=this.m_particleDiameter,t.upperBound.y+=this.m_particleDiameter}FreeBuffer(t,e){null!==t&&(t.length=0)}FreeUserOverridableBuffer(t){0===t.userSuppliedCapacity&&this.FreeBuffer(t.data,this.m_internalAllocatedCapacity)}ReallocateBuffer3(t,e,s){if(s<=e)throw new Error;const i=t?t.slice():[];return i.length=s,i}ReallocateBuffer5(t,e,s,i,n){if(i<=s)throw new Error;if(e&&!(i<=e))throw new Error;return n&&!t||e||(t=this.ReallocateBuffer3(t,s,i)),t}ReallocateBuffer4(t,e,s,i){return this.ReallocateBuffer5(t.data,t.userSuppliedCapacity,e,s,i)}RequestBuffer(t){return t||(0===this.m_internalAllocatedCapacity&&this.ReallocateInternalAllocatedBuffers(E),(t=[]).length=this.m_internalAllocatedCapacity),t}ReallocateHandleBuffers(t){this.m_handleIndexBuffer.data=this.ReallocateBuffer4(this.m_handleIndexBuffer,this.m_internalAllocatedCapacity,t,!0)}ReallocateInternalAllocatedBuffers(t){function e(t,e){return e&&t>e?e:t}if(t=e(t,this.m_def.maxCount),t=e(t,this.m_flagsBuffer.userSuppliedCapacity),t=e(t,this.m_positionBuffer.userSuppliedCapacity),t=e(t,this.m_velocityBuffer.userSuppliedCapacity),t=e(t,this.m_colorBuffer.userSuppliedCapacity),t=e(t,this.m_userDataBuffer.userSuppliedCapacity),this.m_internalAllocatedCapacity<t){this.ReallocateHandleBuffers(t),this.m_flagsBuffer.data=this.ReallocateBuffer4(this.m_flagsBuffer,this.m_internalAllocatedCapacity,t,!1);const e=this.m_stuckThreshold>0;this.m_lastBodyContactStepBuffer.data=this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer,this.m_internalAllocatedCapacity,t,e),this.m_bodyContactCountBuffer.data=this.ReallocateBuffer4(this.m_bodyContactCountBuffer,this.m_internalAllocatedCapacity,t,e),this.m_consecutiveContactStepsBuffer.data=this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer,this.m_internalAllocatedCapacity,t,e),this.m_positionBuffer.data=this.ReallocateBuffer4(this.m_positionBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_velocityBuffer.data=this.ReallocateBuffer4(this.m_velocityBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_forceBuffer=this.ReallocateBuffer5(this.m_forceBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_weightBuffer=this.ReallocateBuffer5(this.m_weightBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_staticPressureBuffer=this.ReallocateBuffer5(this.m_staticPressureBuffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_accumulationBuffer=this.ReallocateBuffer5(this.m_accumulationBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_accumulation2Buffer=this.ReallocateBuffer5(this.m_accumulation2Buffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_depthBuffer=this.ReallocateBuffer5(this.m_depthBuffer,0,this.m_internalAllocatedCapacity,t,!0),this.m_colorBuffer.data=this.ReallocateBuffer4(this.m_colorBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_groupBuffer=this.ReallocateBuffer5(this.m_groupBuffer,0,this.m_internalAllocatedCapacity,t,!1),this.m_userDataBuffer.data=this.ReallocateBuffer4(this.m_userDataBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_expirationTimeBuffer.data=this.ReallocateBuffer4(this.m_expirationTimeBuffer,this.m_internalAllocatedCapacity,t,!0),this.m_indexByExpirationTimeBuffer.data=this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer,this.m_internalAllocatedCapacity,t,!1),this.m_internalAllocatedCapacity=t}}CreateParticleForGroup(t,e,s){const i=new Wn;i.flags=l(t.flags,0),Rt.MulXV(e,s,i.position),Mt.AddVV(l(t.linearVelocity,Mt.ZERO),Mt.CrossSV(l(t.angularVelocity,0),Mt.SubVV(i.position,l(t.position,Mt.ZERO),Mt.s_t0),Mt.s_t0),i.velocity),i.color.Copy(l(t.color,n.ZERO)),i.lifetime=l(t.lifetime,0),i.userData=t.userData,this.CreateParticle(i)}CreateParticlesStrokeShapeForGroup(t,e,s){const i=Bo.CreateParticlesStrokeShapeForGroup_s_edge,n=Bo.CreateParticlesStrokeShapeForGroup_s_d,o=Bo.CreateParticlesStrokeShapeForGroup_s_p;let r=l(e.stride,0);0===r&&(r=this.GetParticleStride());let a=0;const h=t.GetChildCount();for(let l=0;l<h;l++){let h=null;t.GetType()===Ne.e_edgeShape?h=t:(h=i,t.GetChildEdge(h,l));const _=Mt.SubVV(h.m_vertex2,h.m_vertex1,n),m=_.Length();for(;a<m;){const t=Mt.AddVMulSV(h.m_vertex1,a/m,_,o);this.CreateParticleForGroup(e,s,t),a+=r}a-=m}}CreateParticlesFillShapeForGroup(t,e,s){const i=Bo.CreateParticlesFillShapeForGroup_s_aabb,n=Bo.CreateParticlesFillShapeForGroup_s_p;let o=l(e.stride,0);0===o&&(o=this.GetParticleStride());const r=Rt.IDENTITY,a=i;t.ComputeAABB(a,r,0);for(let i=Math.floor(a.lowerBound.y/o)*o;i<a.upperBound.y;i+=o)for(let h=Math.floor(a.lowerBound.x/o)*o;h<a.upperBound.x;h+=o){const o=n.Set(h,i);t.TestPoint(r,o)&&this.CreateParticleForGroup(e,s,o)}}CreateParticlesWithShapeForGroup(t,e,s){switch(t.GetType()){case Ne.e_edgeShape:case Ne.e_chainShape:this.CreateParticlesStrokeShapeForGroup(t,e,s);break;case Ne.e_polygonShape:case Ne.e_circleShape:this.CreateParticlesFillShapeForGroup(t,e,s)}}CreateParticlesWithShapesForGroup(t,e,s,i){const n=new Do(t,e);this.CreateParticlesFillShapeForGroup(n,s,i)}CloneParticle(t,e){const s=new Wn;s.flags=this.m_flagsBuffer.data[t],s.position.Copy(this.m_positionBuffer.data[t]),s.velocity.Copy(this.m_velocityBuffer.data[t]),this.m_colorBuffer.data&&s.color.Copy(this.m_colorBuffer.data[t]),this.m_userDataBuffer.data&&(s.userData=this.m_userDataBuffer.data[t]),s.group=e;const i=this.CreateParticle(s);if(this.m_handleIndexBuffer.data){const e=this.m_handleIndexBuffer.data[t];e&&e.SetIndex(i),this.m_handleIndexBuffer.data[i]=e,this.m_handleIndexBuffer.data[t]=null}return this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[i]=this.m_lastBodyContactStepBuffer.data[t]),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[i]=this.m_bodyContactCountBuffer.data[t]),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[i]=this.m_consecutiveContactStepsBuffer.data[t]),this.m_hasForce&&this.m_forceBuffer[i].Copy(this.m_forceBuffer[t]),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[i]=this.m_staticPressureBuffer[t]),this.m_depthBuffer&&(this.m_depthBuffer[i]=this.m_depthBuffer[t]),this.m_expirationTimeBuffer.data&&(this.m_expirationTimeBuffer.data[i]=this.m_expirationTimeBuffer.data[t]),i}DestroyParticlesInGroup(t,e=!1){for(let s=t.m_firstIndex;s<t.m_lastIndex;s++)this.DestroyParticle(s,e)}DestroyParticleGroup(t){this.m_world.m_destructionListener&&this.m_world.m_destructionListener.SayGoodbyeParticleGroup(t),this.SetGroupFlags(t,0);for(let e=t.m_firstIndex;e<t.m_lastIndex;e++)this.m_groupBuffer[e]=null;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_groupList&&(this.m_groupList=t.m_next),--this.m_groupCount}static ParticleCanBeConnected(t,e){return 0!=(t&(Xn.b2_wallParticle|Xn.b2_springParticle|Xn.b2_elasticParticle))||null!==e&&0!=(e.GetGroupFlags()&On.b2_rigidParticleGroup)}UpdatePairsAndTriads(t,e,s){const i=Bo.UpdatePairsAndTriads_s_dab,n=Bo.UpdatePairsAndTriads_s_dbc,o=Bo.UpdatePairsAndTriads_s_dca,r=this.m_positionBuffer.data;let a=0;for(let s=t;s<e;s++)a|=this.m_flagsBuffer.data[s];if(a&Bo.k_pairFlags)for(let i=0;i<this.m_contactBuffer.count;i++){const n=this.m_contactBuffer.data[i],o=n.indexA,a=n.indexB,h=this.m_flagsBuffer.data[o],l=this.m_flagsBuffer.data[a],_=this.m_groupBuffer[o],m=this.m_groupBuffer[a];if(o>=t&&o<e&&a>=t&&a<e&&!((h|l)&Xn.b2_zombieParticle)&&(h|l)&Bo.k_pairFlags&&(s.IsNecessary(o)||s.IsNecessary(a))&&Bo.ParticleCanBeConnected(h,_)&&Bo.ParticleCanBeConnected(l,m)&&s.ShouldCreatePair(o,a)){const t=this.m_pairBuffer.data[this.m_pairBuffer.Append()];t.indexA=o,t.indexB=a,t.flags=n.flags,t.strength=ht(_?_.m_strength:1,m?m.m_strength:1),t.distance=Mt.DistanceVV(r[o],r[a])}ro(this.m_pairBuffer.data,0,this.m_pairBuffer.count,Bo.ComparePairIndices),this.m_pairBuffer.Unique(Bo.MatchPairIndices)}if(a&Bo.k_triadFlags){const a=new to(e-t);for(let i=t;i<e;i++){const t=this.m_flagsBuffer.data[i],e=this.m_groupBuffer[i];t&Xn.b2_zombieParticle||!Bo.ParticleCanBeConnected(t,e)||a.AddGenerator(r[i],i,s.IsNecessary(i))}const h=this.GetParticleStride();a.Generate(h/2,2*h);const l=this;a.GetNodes((t,e,a)=>{const h=l.m_flagsBuffer.data[t],_=l.m_flagsBuffer.data[e],m=l.m_flagsBuffer.data[a];if((h|_|m)&Bo.k_triadFlags&&s.ShouldCreateTriad(t,e,a)){const s=r[t],c=r[e],u=r[a],d=Mt.SubVV(s,c,i),f=Mt.SubVV(c,u,n),p=Mt.SubVV(u,s,o),y=z*l.m_squaredDiameter;if(Mt.DotVV(d,d)>y||Mt.DotVV(f,f)>y||Mt.DotVV(p,p)>y)return;const x=l.m_groupBuffer[t],B=l.m_groupBuffer[e],S=l.m_groupBuffer[a],A=l.m_triadBuffer.data[l.m_triadBuffer.Append()];A.indexA=t,A.indexB=e,A.indexC=a,A.flags=h|_|m,A.strength=()=>ht(ht(x?x.m_strength:1,B?B.m_strength:1),S?S.m_strength:1);const C=(s.x+c.x+u.x)/3,V=(s.y+c.y+u.y)/3;A.pa.x=s.x-C,A.pa.y=s.y-V,A.pb.x=c.x-C,A.pb.y=c.y-V,A.pc.x=u.x-C,A.pc.y=u.y-V,A.ka=-Mt.DotVV(p,d),A.kb=-Mt.DotVV(d,f),A.kc=-Mt.DotVV(f,p),A.s=Mt.CrossVV(s,c)+Mt.CrossVV(c,u)+Mt.CrossVV(u,s)}}),ro(this.m_triadBuffer.data,0,this.m_triadBuffer.count,Bo.CompareTriadIndices),this.m_triadBuffer.Unique(Bo.MatchTriadIndices)}}UpdatePairsAndTriadsWithReactiveParticles(){const t=new Fo(this.m_flagsBuffer);this.UpdatePairsAndTriads(0,this.m_count,t);for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&=~Xn.b2_reactiveParticle;this.m_allParticleFlags&=~Xn.b2_reactiveParticle}static ComparePairIndices(t,e){const s=t.indexA-e.indexA;return 0!==s?s<0:t.indexB<e.indexB}static MatchPairIndices(t,e){return t.indexA===e.indexA&&t.indexB===e.indexB}static CompareTriadIndices(t,e){const s=t.indexA-e.indexA;if(0!==s)return s<0;const i=t.indexB-e.indexB;return 0!==i?i<0:t.indexC<e.indexC}static MatchTriadIndices(t,e){return t.indexA===e.indexA&&t.indexB===e.indexB&&t.indexC===e.indexC}static InitializeParticleLists(t,e){const s=t.GetBufferIndex(),i=t.GetParticleCount();for(let t=0;t<i;t++){const i=e[t];i.list=i,i.next=null,i.count=1,i.index=t+s}}MergeParticleListsInContact(t,e){const s=t.GetBufferIndex();for(let i=0;i<this.m_contactBuffer.count;i++){const n=this.m_contactBuffer.data[i],o=n.indexA,r=n.indexB;if(!t.ContainsParticle(o)||!t.ContainsParticle(r))continue;let a=e[o-s].list,h=e[r-s].list;if(a!==h){if(a.count<h.count){const t=a;a=h,h=t}Bo.MergeParticleLists(a,h)}}}static MergeParticleLists(t,e){for(let s=e;;){s.list=t;const e=s.next;if(!e){s.next=t.next;break}s=e}t.next=e,t.count+=e.count,e.count=0}static FindLongestParticleList(t,e){const s=t.GetParticleCount();let i=e[0];for(let t=0;t<s;t++){const s=e[t];i.count<s.count&&(i=s)}return i}MergeZombieParticleListNodes(t,e,s){const i=t.GetParticleCount();for(let t=0;t<i;t++){const i=e[t];i!==s&&this.m_flagsBuffer.data[i.index]&Xn.b2_zombieParticle&&Bo.MergeParticleListAndNode(s,i)}}static MergeParticleListAndNode(t,e){e.list=t,e.next=t.next,t.next=e,t.count++,e.count=0}CreateParticleGroupsFromParticleList(t,e,s){const i=t.GetParticleCount(),n=new Kn;n.groupFlags=t.GetGroupFlags(),n.userData=t.GetUserData();for(let t=0;t<i;t++){const i=e[t];if(!i.count||i===s)continue;const o=this.CreateParticleGroup(n);for(let t=i;t;t=t.next){const e=t.index,s=this.CloneParticle(e,o);this.m_flagsBuffer.data[e]|=Xn.b2_zombieParticle,t.index=s}}}UpdatePairsAndTriadsWithParticleList(t,e){const s=t.GetBufferIndex();for(let i=0;i<this.m_pairBuffer.count;i++){const n=this.m_pairBuffer.data[i],o=n.indexA,r=n.indexB;t.ContainsParticle(o)&&(n.indexA=e[o-s].index),t.ContainsParticle(r)&&(n.indexB=e[r-s].index)}for(let i=0;i<this.m_triadBuffer.count;i++){const n=this.m_triadBuffer.data[i],o=n.indexA,r=n.indexB,a=n.indexC;t.ContainsParticle(o)&&(n.indexA=e[o-s].index),t.ContainsParticle(r)&&(n.indexB=e[r-s].index),t.ContainsParticle(a)&&(n.indexC=e[a-s].index)}}ComputeDepth(){const t=[];let e=0;for(let s=0;s<this.m_contactBuffer.count;s++){const i=this.m_contactBuffer.data[s],n=i.indexA,o=i.indexB,r=this.m_groupBuffer[n],a=this.m_groupBuffer[o];r&&r===a&&r.m_groupFlags&On.b2_particleGroupNeedsUpdateDepth&&(t[e++]=i)}const s=[];let i=0;for(let t=this.m_groupList;t;t=t.GetNext())if(t.m_groupFlags&On.b2_particleGroupNeedsUpdateDepth){s[i++]=t,this.SetGroupFlags(t,t.m_groupFlags&~On.b2_particleGroupNeedsUpdateDepth);for(let e=t.m_firstIndex;e<t.m_lastIndex;e++)this.m_accumulationBuffer[e]=0}for(let s=0;s<e;s++){const e=t[s],i=e.indexA,n=e.indexB,o=e.weight;this.m_accumulationBuffer[i]+=o,this.m_accumulationBuffer[n]+=o}for(let t=0;t<i;t++){const e=s[t];for(let t=e.m_firstIndex;t<e.m_lastIndex;t++){const e=this.m_accumulationBuffer[t];this.m_depthBuffer[t]=e<.8?0:_}}const n=ft(this.m_count)>>0;for(let s=0;s<n;s++){let s=!1;for(let i=0;i<e;i++){const e=t[i],n=e.indexA,o=e.indexB,r=1-e.weight,a=this.m_depthBuffer[n],h=this.m_depthBuffer[o],l=h+r,_=a+r;a>l&&(this.m_depthBuffer[n]=l,s=!0),h>_&&(this.m_depthBuffer[o]=_,s=!0)}if(!s)break}for(let t=0;t<i;t++){const e=s[t];for(let t=e.m_firstIndex;t<e.m_lastIndex;t++)this.m_depthBuffer[t]<_?this.m_depthBuffer[t]*=this.m_particleDiameter:this.m_depthBuffer[t]=0}}GetInsideBoundsEnumerator(t){const e=Bo.computeTag(this.m_inverseDiameter*t.lowerBound.x-1,this.m_inverseDiameter*t.lowerBound.y-1),s=Bo.computeTag(this.m_inverseDiameter*t.upperBound.x+1,this.m_inverseDiameter*t.upperBound.y+1),i=this.m_proxyBuffer.count,n=ho(this.m_proxyBuffer.data,0,i,e,Ao.CompareProxyTag),o=lo(this.m_proxyBuffer.data,0,i,s,Ao.CompareTagProxy);return new Co(this,e,s,n,o)}UpdateAllParticleFlags(){this.m_allParticleFlags=0;for(let t=0;t<this.m_count;t++)this.m_allParticleFlags|=this.m_flagsBuffer.data[t];this.m_needsUpdateAllParticleFlags=!1}UpdateAllGroupFlags(){this.m_allGroupFlags=0;for(let t=this.m_groupList;t;t=t.GetNext())this.m_allGroupFlags|=t.m_groupFlags;this.m_needsUpdateAllGroupFlags=!1}AddContact(t,e,s){const i=this.m_flagsBuffer.data,n=this.m_positionBuffer.data,o=Mt.SubVV(n[e],n[t],Bo.AddContact_s_d),r=Mt.DotVV(o,o);if(0<r&&r<this.m_squaredDiameter){const s=dt(r),n=this.m_contactBuffer.data[this.m_contactBuffer.Append()];n.indexA=t,n.indexB=e,n.flags=i[t]|i[e],n.weight=1-r*s*this.m_inverseDiameter,n.normal.x=s*o.x,n.normal.y=s*o.y}}FindContacts(){const t=this.m_proxyBuffer.count;this.m_contactBuffer.count=0;for(let e=0,s=0;e<t;e++){const i=Bo.computeRelativeTag(this.m_proxyBuffer.data[e].tag,1,0);for(let s=e+1;s<t&&!(i<this.m_proxyBuffer.data[s].tag);s++)this.AddContact(this.m_proxyBuffer.data[e].index,this.m_proxyBuffer.data[s].index,this.m_contactBuffer);const n=Bo.computeRelativeTag(this.m_proxyBuffer.data[e].tag,-1,1);for(;s<t&&!(n<=this.m_proxyBuffer.data[s].tag);s++);const o=Bo.computeRelativeTag(this.m_proxyBuffer.data[e].tag,1,1);for(let i=s;i<t&&!(o<this.m_proxyBuffer.data[i].tag);i++)this.AddContact(this.m_proxyBuffer.data[e].index,this.m_proxyBuffer.data[i].index,this.m_contactBuffer)}}UpdateProxies(){const t=this.m_positionBuffer.data,e=this.m_inverseDiameter;for(let s=0;s<this.m_proxyBuffer.count;++s){const i=this.m_proxyBuffer.data[s],n=t[i.index];i.tag=Bo.computeTag(e*n.x,e*n.y)}}SortProxies(){oo(this.m_proxyBuffer.data,0,this.m_proxyBuffer.count,Ao.CompareProxyProxy)}FilterContacts(){const t=this.GetParticleContactFilter();if(null===t)return;const e=this;this.m_contactBuffer.RemoveIf(s=>0!=(s.flags&Xn.b2_particleContactFilterParticle)&&!t.ShouldCollideParticleParticle(e,s.indexA,s.indexB))}NotifyContactListenerPreContact(t,e){null!==this.GetParticleContactListener()&&(t.Initialize(this.m_contactBuffer,this.m_flagsBuffer),e.Initialize(this.m_contactBuffer,this.m_flagsBuffer))}NotifyContactListenerPostContact(t,e){const s=this.GetParticleContactListener();if(null===s)return;for(let e=0;e<this.m_contactBuffer.count;++e){const i=this.m_contactBuffer.data[e],n=t.Find(i);n>=0?t.Invalidate(n):s.BeginContactParticleParticle(this,i)}for(let e=0;e<t.GetCount();e++)t.GetValidBuffer()[e]&&s.EndContactParticleParticle(this,t.GetBuffer()[e]);const i=new Mo(this);i.Initialize(this.m_contactBuffer,this.m_flagsBuffer);for(let t=0;t<i.GetCount();t++){const n=i.GetBuffer()[t],o=e.Find(n);o>=0?e.Invalidate(o):s.BeginContactParticleGroupParticleGroup(this,n)}for(let t=0;t<e.GetCount();t++)e.GetValidBuffer()[t]&&s.EndContactParticleGroupParticleGroup(this,e.GetBuffer()[t])}static b2ParticleContactIsZombie(t){return(t.flags&Xn.b2_zombieParticle)===Xn.b2_zombieParticle}UpdateContacts(t){this.UpdateProxies(),this.SortProxies();const e=new bo,s=new Mo(this);this.NotifyContactListenerPreContact(e,s),this.FindContacts(),this.FilterContacts(),this.NotifyContactListenerPostContact(e,s),t&&this.m_contactBuffer.RemoveIf(Bo.b2ParticleContactIsZombie)}NotifyBodyContactListenerPreContact(t,e){null!==this.GetFixtureContactListener()&&(t.Initialize(this.m_bodyContactBuffer,this.m_flagsBuffer),e.Initialize(this.m_bodyContactBuffer,this.m_flagsBuffer))}NotifyBodyContactListenerPostContact(t,e){const s=this.GetFixtureContactListener();if(null===s)return;for(let e=0;e<this.m_bodyContactBuffer.count;e++){const i=this.m_bodyContactBuffer.data[e],n=t.Find(i);n>=0?t.Invalidate(n):s.BeginContactFixtureParticle(this,i)}for(let e=0;e<t.GetCount();e++)t.GetValidBuffer()[e]&&s.EndContactFixtureParticle(this,t.GetBuffer()[e]);const i=new vo(this);i.Initialize(this.m_bodyContactBuffer,this.m_flagsBuffer);for(let t=0;t<i.GetCount();t++){const n=i.GetBuffer()[t],o=e.Find(n);o>=0?e.Invalidate(o):s.BeginContactBodyParticleGroup(this,n)}for(let t=0;t<e.GetCount();t++)e.GetValidBuffer()[t]&&s.EndContactBodyParticleGroup(this,e.GetBuffer()[t])}UpdateBodyContacts(){const t=new wo,e=new vo(this);if(this.NotifyBodyContactListenerPreContact(t,e),this.m_stuckThreshold>0){const t=this.GetParticleCount();for(let e=0;e<t;e++)this.m_bodyContactCountBuffer.data[e]=0,this.m_timestamp>this.m_lastBodyContactStepBuffer.data[e]+1&&(this.m_consecutiveContactStepsBuffer.data[e]=0)}this.m_bodyContactBuffer.SetCount(0),this.m_stuckParticleBuffer.SetCount(0);const s=Bo.UpdateBodyContacts_s_aabb;this.ComputeAABB(s),null===this.UpdateBodyContacts_callback&&(this.UpdateBodyContacts_callback=new Lo(this));const i=this.UpdateBodyContacts_callback;this.m_world.QueryAABB(i,s),this.m_def.strictContactCheck&&this.RemoveSpuriousBodyContacts(),this.NotifyBodyContactListenerPostContact(t,e)}Solve(t){if(0!==this.m_count&&(this.m_expirationTimeBuffer.data&&this.SolveLifetimes(t),this.m_allParticleFlags&Xn.b2_zombieParticle&&this.SolveZombie(),this.m_needsUpdateAllParticleFlags&&this.UpdateAllParticleFlags(),this.m_needsUpdateAllGroupFlags&&this.UpdateAllGroupFlags(),!this.m_paused))for(this.m_iterationIndex=0;this.m_iterationIndex<t.particleIterations;this.m_iterationIndex++){++this.m_timestamp;const e=Bo.Solve_s_subStep.Copy(t);e.dt/=t.particleIterations,e.inv_dt*=t.particleIterations,this.UpdateContacts(!1),this.UpdateBodyContacts(),this.ComputeWeight(),this.m_allGroupFlags&On.b2_particleGroupNeedsUpdateDepth&&this.ComputeDepth(),this.m_allParticleFlags&Xn.b2_reactiveParticle&&this.UpdatePairsAndTriadsWithReactiveParticles(),this.m_hasForce&&this.SolveForce(e),this.m_allParticleFlags&Xn.b2_viscousParticle&&this.SolveViscous(),this.m_allParticleFlags&Xn.b2_repulsiveParticle&&this.SolveRepulsive(e),this.m_allParticleFlags&Xn.b2_powderParticle&&this.SolvePowder(e),this.m_allParticleFlags&Xn.b2_tensileParticle&&this.SolveTensile(e),this.m_allGroupFlags&On.b2_solidParticleGroup&&this.SolveSolid(e),this.m_allParticleFlags&Xn.b2_colorMixingParticle&&this.SolveColorMixing(),this.SolveGravity(e),this.m_allParticleFlags&Xn.b2_staticPressureParticle&&this.SolveStaticPressure(e),this.SolvePressure(e),this.SolveDamping(e),this.m_allParticleFlags&Bo.k_extraDampingFlags&&this.SolveExtraDamping(),this.m_allParticleFlags&Xn.b2_elasticParticle&&this.SolveElastic(e),this.m_allParticleFlags&Xn.b2_springParticle&&this.SolveSpring(e),this.LimitVelocity(e),this.m_allGroupFlags&On.b2_rigidParticleGroup&&this.SolveRigidDamping(),this.m_allParticleFlags&Xn.b2_barrierParticle&&this.SolveBarrier(e),this.SolveCollision(e),this.m_allGroupFlags&On.b2_rigidParticleGroup&&this.SolveRigid(e),this.m_allParticleFlags&Xn.b2_wallParticle&&this.SolveWall();for(let t=0;t<this.m_count;t++){const s=this.m_positionBuffer.data[t];s.SelfMulAdd(e.dt,this.m_velocityBuffer.data[t]);const i=this.m_positionConstraintBuffer[t];i&&Mt.ClampV(s,i[0],i[1],s)}this.m_positionConstraintBuffer.length=0}}SolveCollision(t){const e=Bo.SolveCollision_s_aabb,s=this.m_positionBuffer.data,i=this.m_velocityBuffer.data,n=e;n.lowerBound.x=+_,n.lowerBound.y=+_,n.upperBound.x=-_,n.upperBound.y=-_;for(let e=0;e<this.m_count;e++){const o=i[e],r=s[e],a=r.x+t.dt*o.x,h=r.y+t.dt*o.y;n.lowerBound.x=ht(n.lowerBound.x,ht(r.x,a)),n.lowerBound.y=ht(n.lowerBound.y,ht(r.y,h)),n.upperBound.x=lt(n.upperBound.x,lt(r.x,a)),n.upperBound.y=lt(n.upperBound.y,lt(r.y,h))}null===this.SolveCollision_callback&&(this.SolveCollision_callback=new Ro(this,t));const o=this.SolveCollision_callback;o.m_step=t,this.m_world.QueryAABB(o,n)}LimitVelocity(t){const e=this.m_velocityBuffer.data,s=this.GetCriticalVelocitySquared(t);for(let t=0;t<this.m_count;t++){const i=e[t],n=Mt.DotVV(i,i);n>s&&i.SelfMul(ft(s/n))}}SolveGravity(t){const e=Bo.SolveGravity_s_gravity,s=this.m_velocityBuffer.data,i=Mt.MulSV(t.dt*this.m_def.gravityScale,this.m_world.GetGravity(),e);for(let t=0;t<this.m_count;t++)s[t].SelfAdd(i)}SolveBarrier(t){const e=Bo.SolveBarrier_s_aabb,s=Bo.SolveBarrier_s_va,i=Bo.SolveBarrier_s_vb,n=Bo.SolveBarrier_s_pba,o=Bo.SolveBarrier_s_vba,r=Bo.SolveBarrier_s_vc,a=Bo.SolveBarrier_s_pca,h=Bo.SolveBarrier_s_vca,l=Bo.SolveBarrier_s_qba,_=Bo.SolveBarrier_s_qca,m=Bo.SolveBarrier_s_dv,c=Bo.SolveBarrier_s_f,u=this.m_positionBuffer.data,d=this.m_velocityBuffer.data;for(let t=0;t<this.m_count;t++){0!=(this.m_flagsBuffer.data[t]&Bo.k_barrierWallFlags)&&d[t].SetZero()}const f=N*t.dt,p=this.GetParticleMass();for(let y=0;y<this.m_pairBuffer.count;y++){const x=this.m_pairBuffer.data[y];if(x.flags&Xn.b2_barrierParticle){const y=x.indexA,B=x.indexB,S=u[y],A=u[B],C=e;Mt.MinV(S,A,C.lowerBound),Mt.MaxV(S,A,C.upperBound);const V=this.m_groupBuffer[y],g=this.m_groupBuffer[B],w=this.GetLinearVelocity(V,y,S,s),v=this.GetLinearVelocity(g,B,A,i),b=Mt.SubVV(A,S,n),M=Mt.SubVV(v,w,o),P=this.GetInsideBoundsEnumerator(C);let I;for(;(I=P.GetNext())>=0;){const e=u[I],s=this.m_groupBuffer[I];if(V!==s&&g!==s){const i=this.GetLinearVelocity(s,I,e,r),n=Mt.SubVV(e,S,a),o=Mt.SubVV(i,w,h),u=Mt.CrossVV(M,o),y=Mt.CrossVV(b,o)-Mt.CrossVV(n,M),x=Mt.CrossVV(b,n);let B,A;const C=l,V=_;if(0===u){if(0===y)continue;if(A=-x/y,!(A>=0&&A<f))continue;if(Mt.AddVMulSV(b,A,M,C),Mt.AddVMulSV(n,A,o,V),B=Mt.DotVV(C,V)/Mt.DotVV(C,C),!(B>=0&&B<=1))continue}else{const t=y*y-4*x*u;if(t<0)continue;const e=ft(t);let s=(-y-e)/(2*u),i=(-y+e)/(2*u);if(s>i){const t=s;s=i,i=t}if(A=s,Mt.AddVMulSV(b,A,M,C),Mt.AddVMulSV(n,A,o,V),B=Mt.DotVV(C,V)/Mt.DotVV(C,C),!(A>=0&&A<f&&B>=0&&B<=1)){if(A=i,!(A>=0&&A<f))continue;if(Mt.AddVMulSV(b,A,M,C),Mt.AddVMulSV(n,A,o,V),B=Mt.DotVV(C,V)/Mt.DotVV(C,C),!(B>=0&&B<=1))continue}}const g=m;g.x=w.x+B*M.x-i.x,g.y=w.y+B*M.y-i.y;const v=Mt.MulSV(p,g,c);if(s&&this.IsRigidGroup(s)){const t=s.GetMass(),i=s.GetInertia();t>0&&s.m_linearVelocity.SelfMulAdd(1/t,v),i>0&&(s.m_angularVelocity+=Mt.CrossVV(Mt.SubVV(e,s.GetCenter(),Mt.s_t0),v)/i)}else d[I].SelfAdd(g);this.ParticleApplyForce(I,v.SelfMul(-t.inv_dt))}}}}}SolveStaticPressure(t){this.m_staticPressureBuffer=this.RequestBuffer(this.m_staticPressureBuffer);const e=this.GetCriticalPressure(t),s=this.m_def.staticPressureStrength*e,i=T*e,n=this.m_def.staticPressureRelaxation;for(let t=0;t<this.m_def.staticPressureIterations;t++){for(let t=0;t<this.m_count;t++)this.m_accumulationBuffer[t]=0;for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];if(e.flags&Xn.b2_staticPressureParticle){const t=e.indexA,s=e.indexB,i=e.weight;this.m_accumulationBuffer[t]+=i*this.m_staticPressureBuffer[s],this.m_accumulationBuffer[s]+=i*this.m_staticPressureBuffer[t]}}for(let t=0;t<this.m_count;t++){const e=this.m_weightBuffer[t];if(this.m_flagsBuffer.data[t]&Xn.b2_staticPressureParticle){const o=(this.m_accumulationBuffer[t]+s*(e-R))/(e+n);this.m_staticPressureBuffer[t]=_t(o,0,i)}else this.m_staticPressureBuffer[t]=0}}}ComputeWeight(){for(let t=0;t<this.m_count;t++)this.m_weightBuffer[t]=0;for(let t=0;t<this.m_bodyContactBuffer.count;t++){const e=this.m_bodyContactBuffer.data[t],s=e.index,i=e.weight;this.m_weightBuffer[s]+=i}for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t],s=e.indexA,i=e.indexB,n=e.weight;this.m_weightBuffer[s]+=n,this.m_weightBuffer[i]+=n}}SolvePressure(t){const e=Bo.SolvePressure_s_f,s=this.m_positionBuffer.data,i=this.m_velocityBuffer.data,n=this.GetCriticalPressure(t),o=this.m_def.pressureStrength*n,r=T*n;for(let t=0;t<this.m_count;t++){const e=o*lt(0,this.m_weightBuffer[t]-R);this.m_accumulationBuffer[t]=ht(e,r)}if(this.m_allParticleFlags&Bo.k_noPressureFlags)for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&Bo.k_noPressureFlags&&(this.m_accumulationBuffer[t]=0);if(this.m_allParticleFlags&Xn.b2_staticPressureParticle)for(let t=0;t<this.m_count;t++)this.m_flagsBuffer.data[t]&Xn.b2_staticPressureParticle&&(this.m_accumulationBuffer[t]+=this.m_staticPressureBuffer[t]);const a=t.dt/(this.m_def.density*this.m_particleDiameter),h=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const n=this.m_bodyContactBuffer.data[t],r=n.index,l=n.body,_=n.weight,m=n.mass,c=n.normal,u=s[r],d=this.m_accumulationBuffer[r]+o*_,f=Mt.MulSV(a*_*m*d,c,e);i[r].SelfMulSub(h,f),l.ApplyLinearImpulse(f,u,!0)}for(let t=0;t<this.m_contactBuffer.count;t++){const s=this.m_contactBuffer.data[t],n=s.indexA,o=s.indexB,r=s.weight,h=s.normal,l=this.m_accumulationBuffer[n]+this.m_accumulationBuffer[o],_=Mt.MulSV(a*r*l,h,e);i[n].SelfSub(_),i[o].SelfAdd(_)}}SolveDamping(t){const e=Bo.SolveDamping_s_v,s=Bo.SolveDamping_s_f,i=this.m_positionBuffer.data,n=this.m_velocityBuffer.data,o=this.m_def.dampingStrength,r=1/this.GetCriticalVelocity(t),a=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const h=this.m_bodyContactBuffer.data[t],l=h.index,_=h.body,m=h.weight,c=h.mass,u=h.normal,d=i[l],f=Mt.SubVV(_.GetLinearVelocityFromWorldPoint(d,Mt.s_t0),n[l],e),p=Mt.DotVV(f,u);if(p<0){const t=lt(o*m,ht(-r*p,.5)),e=Mt.MulSV(t*c*p,u,s);n[l].SelfMulAdd(a,e),_.ApplyForce(e.SelfNeg(),d,!0)}}for(let t=0;t<this.m_contactBuffer.count;t++){const i=this.m_contactBuffer.data[t],a=i.indexA,h=i.indexB,l=i.weight,_=i.normal,m=Mt.SubVV(n[h],n[a],e),c=Mt.DotVV(m,_);if(c<0){const t=lt(o*l,ht(-r*c,.5)),e=Mt.MulSV(t*c,_,s);n[a].SelfAdd(e),n[h].SelfSub(e)}}}SolveRigidDamping(){const t=Bo.SolveRigidDamping_s_t0,e=Bo.SolveRigidDamping_s_t1,s=Bo.SolveRigidDamping_s_p,i=Bo.SolveRigidDamping_s_v,n=[0],o=[0],r=[0],a=[0],h=[0],l=[0],_=this.m_positionBuffer.data,m=this.m_def.dampingStrength;for(let s=0;s<this.m_bodyContactBuffer.count;s++){const c=this.m_bodyContactBuffer.data[s],u=c.index,d=this.m_groupBuffer[u];if(d&&this.IsRigidGroup(d)){const s=c.body,f=c.normal,p=c.weight,y=_[u],x=Mt.SubVV(s.GetLinearVelocityFromWorldPoint(y,t),d.GetLinearVelocityFromWorldPoint(y,e),i),B=Mt.DotVV(x,f);if(B<0){this.InitDampingParameterWithRigidGroupOrParticle(n,o,r,!0,d,u,y,f),this.InitDampingParameter(a,h,l,s.GetMass(),s.GetInertia()-s.GetMass()*s.GetLocalCenter().LengthSquared(),s.GetWorldCenter(),y,f);const t=m*ht(p,1)*this.ComputeDampingImpulse(n[0],o[0],r[0],a[0],h[0],l[0],B);this.ApplyDamping(n[0],o[0],r[0],!0,d,u,t,f),s.ApplyLinearImpulse(Mt.MulSV(-t,f,Mt.s_t0),y,!0)}}}for(let c=0;c<this.m_contactBuffer.count;c++){const u=this.m_contactBuffer.data[c],d=u.indexA,f=u.indexB,p=u.normal,y=u.weight,x=this.m_groupBuffer[d],B=this.m_groupBuffer[f],S=this.IsRigidGroup(x),A=this.IsRigidGroup(B);if(x!==B&&(S||A)){const c=Mt.MidVV(_[d],_[f],s),u=Mt.SubVV(this.GetLinearVelocity(B,f,c,t),this.GetLinearVelocity(x,d,c,e),i),C=Mt.DotVV(u,p);if(C<0){this.InitDampingParameterWithRigidGroupOrParticle(n,o,r,S,x,d,c,p),this.InitDampingParameterWithRigidGroupOrParticle(a,h,l,A,B,f,c,p);const t=m*y*this.ComputeDampingImpulse(n[0],o[0],r[0],a[0],h[0],l[0],C);this.ApplyDamping(n[0],o[0],r[0],S,x,d,t,p),this.ApplyDamping(a[0],h[0],l[0],A,B,f,-t,p)}}}}SolveExtraDamping(){const t=Bo.SolveExtraDamping_s_v,e=Bo.SolveExtraDamping_s_f,s=this.m_velocityBuffer.data,i=this.m_positionBuffer.data,n=this.GetParticleInvMass();for(let o=0;o<this.m_bodyContactBuffer.count;o++){const r=this.m_bodyContactBuffer.data[o],a=r.index;if(this.m_flagsBuffer.data[a]&Bo.k_extraDampingFlags){const o=r.body,h=r.mass,l=r.normal,_=i[a],m=Mt.SubVV(o.GetLinearVelocityFromWorldPoint(_,Mt.s_t0),s[a],t),c=Mt.DotVV(m,l);if(c<0){const t=Mt.MulSV(.5*h*c,l,e);s[a].SelfMulAdd(n,t),o.ApplyLinearImpulse(t.SelfNeg(),_,!0)}}}}SolveWall(){const t=this.m_velocityBuffer.data;for(let e=0;e<this.m_count;e++)this.m_flagsBuffer.data[e]&Xn.b2_wallParticle&&t[e].SetZero()}SolveRigid(t){const e=Bo.SolveRigid_s_position,s=Bo.SolveRigid_s_rotation,i=Bo.SolveRigid_s_transform,n=Bo.SolveRigid_s_velocityTransform,o=this.m_positionBuffer.data,r=this.m_velocityBuffer.data;for(let a=this.m_groupList;a;a=a.GetNext())if(a.m_groupFlags&On.b2_rigidParticleGroup){a.UpdateStatistics();const h=s;h.SetAngle(t.dt*a.m_angularVelocity);const l=Mt.AddVV(a.m_center,Mt.SubVV(Mt.MulSV(t.dt,a.m_linearVelocity,Mt.s_t0),Lt.MulRV(h,a.m_center,Mt.s_t1),Mt.s_t0),e),_=i;_.SetPositionRotation(l,h),Rt.MulXX(_,a.m_transform,a.m_transform);const m=n;m.p.x=t.inv_dt*_.p.x,m.p.y=t.inv_dt*_.p.y,m.q.s=t.inv_dt*_.q.s,m.q.c=t.inv_dt*(_.q.c-1);for(let t=a.m_firstIndex;t<a.m_lastIndex;t++)Rt.MulXV(m,o[t],r[t])}}SolveElastic(t){const e=Bo.SolveElastic_s_pa,s=Bo.SolveElastic_s_pb,i=Bo.SolveElastic_s_pc,n=Bo.SolveElastic_s_r,o=Bo.SolveElastic_s_t0,r=this.m_positionBuffer.data,a=this.m_velocityBuffer.data,h=t.inv_dt*this.m_def.elasticStrength;for(let l=0;l<this.m_triadBuffer.count;l++){const _=this.m_triadBuffer.data[l];if(_.flags&Xn.b2_elasticParticle){const l=_.indexA,m=_.indexB,c=_.indexC,u=e.Copy(r[l]),d=s.Copy(r[m]),f=i.Copy(r[c]),p=a[l],y=a[m],x=a[c];u.SelfMulAdd(t.dt,p),d.SelfMulAdd(t.dt,y),f.SelfMulAdd(t.dt,x);const B=(u.x+d.x+f.x)/3,S=(u.y+d.y+f.y)/3;u.x-=B,u.y-=S,d.x-=B,d.y-=S,f.x-=B,f.y-=S;const A=_.pa,C=_.pb,V=_.pc,g=n;g.s=Mt.CrossVV(A,u)+Mt.CrossVV(C,d)+Mt.CrossVV(V,f),g.c=Mt.DotVV(A,u)+Mt.DotVV(C,d)+Mt.DotVV(V,f);let w=dt(g.s*g.s+g.c*g.c);isFinite(w)||(w=198177537e11),g.s*=w,g.c*=w;const v=h*("number"==typeof _.strength?_.strength:_.strength());Lt.MulRV(g,A,o),Mt.SubVV(o,u,o),Mt.MulSV(v,o,o),p.SelfAdd(o),Lt.MulRV(g,C,o),Mt.SubVV(o,d,o),Mt.MulSV(v,o,o),y.SelfAdd(o),Lt.MulRV(g,V,o),Mt.SubVV(o,f,o),Mt.MulSV(v,o,o),x.SelfAdd(o)}}}SolveSpring(t){const e=Bo.SolveSpring_s_pa,s=Bo.SolveSpring_s_pb,i=Bo.SolveSpring_s_d,n=Bo.SolveSpring_s_f,o=this.m_positionBuffer.data,r=this.m_velocityBuffer.data,a=t.inv_dt*this.m_def.springStrength;for(let h=0;h<this.m_pairBuffer.count;h++){const l=this.m_pairBuffer.data[h];if(l.flags&Xn.b2_springParticle){const h=l.indexA,_=l.indexB,m=e.Copy(o[h]),c=s.Copy(o[_]),u=r[h],d=r[_];m.SelfMulAdd(t.dt,u),c.SelfMulAdd(t.dt,d);const f=Mt.SubVV(c,m,i),p=l.distance,y=f.Length(),x=a*l.strength,B=Mt.MulSV(x*(p-y)/y,f,n);u.SelfSub(B),d.SelfAdd(B)}}}SolveTensile(t){const e=Bo.SolveTensile_s_weightedNormal,s=Bo.SolveTensile_s_s,i=Bo.SolveTensile_s_f,n=this.m_velocityBuffer.data;for(let t=0;t<this.m_count;t++)this.m_accumulation2Buffer[t]=new Mt,this.m_accumulation2Buffer[t].SetZero();for(let t=0;t<this.m_contactBuffer.count;t++){const s=this.m_contactBuffer.data[t];if(s.flags&Xn.b2_tensileParticle){const t=s.indexA,i=s.indexB,n=s.weight,o=s.normal,r=Mt.MulSV((1-n)*n,o,e);this.m_accumulation2Buffer[t].SelfSub(r),this.m_accumulation2Buffer[i].SelfAdd(r)}}const o=this.GetCriticalVelocity(t),r=this.m_def.surfaceTensionPressureStrength*o,a=this.m_def.surfaceTensionNormalStrength*o,h=k*o;for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];if(e.flags&Xn.b2_tensileParticle){const t=e.indexA,o=e.indexB,l=e.weight,_=e.normal,m=this.m_weightBuffer[t]+this.m_weightBuffer[o],c=Mt.SubVV(this.m_accumulation2Buffer[o],this.m_accumulation2Buffer[t],s),u=ht(r*(m-2)+a*Mt.DotVV(c,_),h)*l,d=Mt.MulSV(u,_,i);n[t].SelfSub(d),n[o].SelfAdd(d)}}}SolveViscous(){const t=Bo.SolveViscous_s_v,e=Bo.SolveViscous_s_f,s=this.m_positionBuffer.data,i=this.m_velocityBuffer.data,n=this.m_def.viscousStrength,o=this.GetParticleInvMass();for(let r=0;r<this.m_bodyContactBuffer.count;r++){const a=this.m_bodyContactBuffer.data[r],h=a.index;if(this.m_flagsBuffer.data[h]&Xn.b2_viscousParticle){const r=a.body,l=a.weight,_=a.mass,m=s[h],c=Mt.SubVV(r.GetLinearVelocityFromWorldPoint(m,Mt.s_t0),i[h],t),u=Mt.MulSV(n*_*l,c,e);i[h].SelfMulAdd(o,u),r.ApplyLinearImpulse(u.SelfNeg(),m,!0)}}for(let s=0;s<this.m_contactBuffer.count;s++){const o=this.m_contactBuffer.data[s];if(o.flags&Xn.b2_viscousParticle){const s=o.indexA,r=o.indexB,a=o.weight,h=Mt.SubVV(i[r],i[s],t),l=Mt.MulSV(n*a,h,e);i[s].SelfAdd(l),i[r].SelfSub(l)}}}SolveRepulsive(t){const e=Bo.SolveRepulsive_s_f,s=this.m_velocityBuffer.data,i=this.m_def.repulsiveStrength*this.GetCriticalVelocity(t);for(let t=0;t<this.m_contactBuffer.count;t++){const n=this.m_contactBuffer.data[t];if(n.flags&Xn.b2_repulsiveParticle){const t=n.indexA,o=n.indexB;if(this.m_groupBuffer[t]!==this.m_groupBuffer[o]){const r=n.weight,a=n.normal,h=Mt.MulSV(i*r,a,e);s[t].SelfSub(h),s[o].SelfAdd(h)}}}}SolvePowder(t){const e=Bo.SolvePowder_s_f,s=this.m_positionBuffer.data,i=this.m_velocityBuffer.data,n=this.m_def.powderStrength*this.GetCriticalVelocity(t),o=1-L,r=this.GetParticleInvMass();for(let t=0;t<this.m_bodyContactBuffer.count;t++){const a=this.m_bodyContactBuffer.data[t],h=a.index;if(this.m_flagsBuffer.data[h]&Xn.b2_powderParticle){const t=a.weight;if(t>o){const l=a.body,_=a.mass,m=s[h],c=a.normal,u=Mt.MulSV(n*_*(t-o),c,e);i[h].SelfMulSub(r,u),l.ApplyLinearImpulse(u,m,!0)}}}for(let t=0;t<this.m_contactBuffer.count;t++){const s=this.m_contactBuffer.data[t];if(s.flags&Xn.b2_powderParticle){const t=s.weight;if(t>o){const r=s.indexA,a=s.indexB,h=s.normal,l=Mt.MulSV(n*(t-o),h,e);i[r].SelfSub(l),i[a].SelfAdd(l)}}}}SolveSolid(t){const e=Bo.SolveSolid_s_f,s=this.m_velocityBuffer.data;this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer);const i=t.inv_dt*this.m_def.ejectionStrength;for(let t=0;t<this.m_contactBuffer.count;t++){const n=this.m_contactBuffer.data[t],o=n.indexA,r=n.indexB;if(this.m_groupBuffer[o]===this.m_groupBuffer[r])continue;const a=n.weight,h=n.normal,l=this.m_depthBuffer[o]+this.m_depthBuffer[r],_=Mt.MulSV(i*l*a,h,e);s[o].SelfSub(_),s[r].SelfAdd(_)}}SolveForce(t){const e=this.m_velocityBuffer.data,s=t.dt*this.GetParticleInvMass();for(let t=0;t<this.m_count;t++)e[t].SelfMulAdd(s,this.m_forceBuffer[t]);this.m_hasForce=!1}SolveColorMixing(){const t=.5*this.m_def.colorMixingStrength;if(t)for(let e=0;e<this.m_contactBuffer.count;e++){const s=this.m_contactBuffer.data[e],i=s.indexA,o=s.indexB;if(this.m_flagsBuffer.data[i]&this.m_flagsBuffer.data[o]&Xn.b2_colorMixingParticle){const e=this.m_colorBuffer.data[i],s=this.m_colorBuffer.data[o];n.MixColors(e,s,t)}}}SolveZombie(){let t=0;const e=[];for(let t=0;t<this.m_count;t++)e[t]=D;let s=0;for(let i=0;i<this.m_count;i++){const n=this.m_flagsBuffer.data[i];if(n&Xn.b2_zombieParticle){const t=this.m_world.m_destructionListener;if(n&Xn.b2_destructionListenerParticle&&t&&t.SayGoodbyeParticle(this,i),this.m_handleIndexBuffer.data){const t=this.m_handleIndexBuffer.data[i];t&&(t.SetIndex(D),this.m_handleIndexBuffer.data[i]=null)}e[i]=D}else{if(e[i]=t,i!==t){if(this.m_handleIndexBuffer.data){const e=this.m_handleIndexBuffer.data[i];e&&e.SetIndex(t),this.m_handleIndexBuffer.data[t]=e}this.m_flagsBuffer.data[t]=this.m_flagsBuffer.data[i],this.m_lastBodyContactStepBuffer.data&&(this.m_lastBodyContactStepBuffer.data[t]=this.m_lastBodyContactStepBuffer.data[i]),this.m_bodyContactCountBuffer.data&&(this.m_bodyContactCountBuffer.data[t]=this.m_bodyContactCountBuffer.data[i]),this.m_consecutiveContactStepsBuffer.data&&(this.m_consecutiveContactStepsBuffer.data[t]=this.m_consecutiveContactStepsBuffer.data[i]),this.m_positionBuffer.data[t].Copy(this.m_positionBuffer.data[i]),this.m_velocityBuffer.data[t].Copy(this.m_velocityBuffer.data[i]),this.m_groupBuffer[t]=this.m_groupBuffer[i],this.m_hasForce&&this.m_forceBuffer[t].Copy(this.m_forceBuffer[i]),this.m_staticPressureBuffer&&(this.m_staticPressureBuffer[t]=this.m_staticPressureBuffer[i]),this.m_depthBuffer&&(this.m_depthBuffer[t]=this.m_depthBuffer[i]),this.m_colorBuffer.data&&this.m_colorBuffer.data[t].Copy(this.m_colorBuffer.data[i]),this.m_userDataBuffer.data&&(this.m_userDataBuffer.data[t]=this.m_userDataBuffer.data[i]),this.m_expirationTimeBuffer.data&&(this.m_expirationTimeBuffer.data[t]=this.m_expirationTimeBuffer.data[i])}t++,s|=n}}const i=t=>t.index<0,n=t=>t.indexA<0||t.indexB<0,o=t=>t.index<0,r=t=>t.indexA<0||t.indexB<0,a=t=>t.indexA<0||t.indexB<0||t.indexC<0;for(let t=0;t<this.m_proxyBuffer.count;t++){const s=this.m_proxyBuffer.data[t];s.index=e[s.index]}this.m_proxyBuffer.RemoveIf(i);for(let t=0;t<this.m_contactBuffer.count;t++){const s=this.m_contactBuffer.data[t];s.indexA=e[s.indexA],s.indexB=e[s.indexB]}this.m_contactBuffer.RemoveIf(n);for(let t=0;t<this.m_bodyContactBuffer.count;t++){const s=this.m_bodyContactBuffer.data[t];s.index=e[s.index]}this.m_bodyContactBuffer.RemoveIf(o);for(let t=0;t<this.m_pairBuffer.count;t++){const s=this.m_pairBuffer.data[t];s.indexA=e[s.indexA],s.indexB=e[s.indexB]}this.m_pairBuffer.RemoveIf(r);for(let t=0;t<this.m_triadBuffer.count;t++){const s=this.m_triadBuffer.data[t];s.indexA=e[s.indexA],s.indexB=e[s.indexB],s.indexC=e[s.indexC]}if(this.m_triadBuffer.RemoveIf(a),this.m_indexByExpirationTimeBuffer.data){let t=0;for(let s=0;s<this.m_count;s++){const i=e[this.m_indexByExpirationTimeBuffer.data[s]];i!==D&&(this.m_indexByExpirationTimeBuffer.data[t++]=i)}}for(let s=this.m_groupList;s;s=s.GetNext()){let i=t,n=0,o=!1;for(let t=s.m_firstIndex;t<s.m_lastIndex;t++){const s=e[t];s>=0?(i=ht(i,s),n=lt(n,s+1)):o=!0}i<n?(s.m_firstIndex=i,s.m_lastIndex=n,o&&s.m_groupFlags&On.b2_solidParticleGroup&&this.SetGroupFlags(s,s.m_groupFlags|On.b2_particleGroupNeedsUpdateDepth)):(s.m_firstIndex=0,s.m_lastIndex=0,s.m_groupFlags&On.b2_particleGroupCanBeEmpty||this.SetGroupFlags(s,s.m_groupFlags|On.b2_particleGroupWillBeDestroyed))}this.m_count=t,this.m_allParticleFlags=s,this.m_needsUpdateAllParticleFlags=!1;for(let t=this.m_groupList;t;){const e=t.GetNext();t.m_groupFlags&On.b2_particleGroupWillBeDestroyed&&this.DestroyParticleGroup(t),t=e}}SolveLifetimes(t){this.m_timeElapsed=this.LifetimeToExpirationTime(t.dt);const e=this.GetQuantizedTimeElapsed(),s=this.m_expirationTimeBuffer.data,i=this.m_indexByExpirationTimeBuffer.data,n=this.GetParticleCount();if(this.m_expirationTimeBufferRequiresSorting){oo(i,0,n,(t,e)=>{const i=s[t],n=s[e],o=i<=0;return o===n<=0?i>n:o}),this.m_expirationTimeBufferRequiresSorting=!1}for(let t=n-1;t>=0;--t){const n=i[t],o=s[n];if(e<o||o<=0)break;this.DestroyParticle(n)}}RotateBuffer(t,e,s){if(t!==e&&e!==s){if(_o(this.m_flagsBuffer.data,t,e,s),this.m_lastBodyContactStepBuffer.data&&_o(this.m_lastBodyContactStepBuffer.data,t,e,s),this.m_bodyContactCountBuffer.data&&_o(this.m_bodyContactCountBuffer.data,t,e,s),this.m_consecutiveContactStepsBuffer.data&&_o(this.m_consecutiveContactStepsBuffer.data,t,e,s),_o(this.m_positionBuffer.data,t,e,s),_o(this.m_velocityBuffer.data,t,e,s),_o(this.m_groupBuffer,t,e,s),this.m_hasForce&&_o(this.m_forceBuffer,t,e,s),this.m_staticPressureBuffer&&_o(this.m_staticPressureBuffer,t,e,s),this.m_depthBuffer&&_o(this.m_depthBuffer,t,e,s),this.m_colorBuffer.data&&_o(this.m_colorBuffer.data,t,e,s),this.m_userDataBuffer.data&&_o(this.m_userDataBuffer.data,t,e,s),this.m_handleIndexBuffer.data){_o(this.m_handleIndexBuffer.data,t,e,s);for(let e=t;e<s;++e){const t=this.m_handleIndexBuffer.data[e];t&&t.SetIndex(i(t.GetIndex()))}}if(this.m_expirationTimeBuffer.data){_o(this.m_expirationTimeBuffer.data,t,e,s);const n=this.GetParticleCount(),o=this.m_indexByExpirationTimeBuffer.data;for(let t=0;t<n;++t)o[t]=i(o[t])}for(let t=0;t<this.m_proxyBuffer.count;t++){const e=this.m_proxyBuffer.data[t];e.index=i(e.index)}for(let t=0;t<this.m_contactBuffer.count;t++){const e=this.m_contactBuffer.data[t];e.indexA=i(e.indexA),e.indexB=i(e.indexB)}for(let t=0;t<this.m_bodyContactBuffer.count;t++){const e=this.m_bodyContactBuffer.data[t];e.index=i(e.index)}for(let t=0;t<this.m_pairBuffer.count;t++){const e=this.m_pairBuffer.data[t];e.indexA=i(e.indexA),e.indexB=i(e.indexB)}for(let t=0;t<this.m_triadBuffer.count;t++){const e=this.m_triadBuffer.data[t];e.indexA=i(e.indexA),e.indexB=i(e.indexB),e.indexC=i(e.indexC)}for(let t=this.m_groupList;t;t=t.GetNext())t.m_firstIndex=i(t.m_firstIndex),t.m_lastIndex=i(t.m_lastIndex-1)+1}function i(i){return i<t?i:i<e?i+s-e:i<s?i+t-e:i}}GetCriticalVelocity(t){return this.m_particleDiameter*t.inv_dt}GetCriticalVelocitySquared(t){const e=this.GetCriticalVelocity(t);return e*e}GetCriticalPressure(t){return this.m_def.density*this.GetCriticalVelocitySquared(t)}GetParticleStride(){return L*this.m_particleDiameter}GetParticleMass(){const t=this.GetParticleStride();return this.m_def.density*t*t}GetParticleInvMass(){const t=this.m_inverseDiameter*(1/L);return this.m_inverseDensity*t*t}GetFixtureContactFilter(){return this.m_allParticleFlags&Xn.b2_fixtureContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null}GetParticleContactFilter(){return this.m_allParticleFlags&Xn.b2_particleContactFilterParticle?this.m_world.m_contactManager.m_contactFilter:null}GetFixtureContactListener(){return this.m_allParticleFlags&Xn.b2_fixtureContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null}GetParticleContactListener(){return this.m_allParticleFlags&Xn.b2_particleContactListenerParticle?this.m_world.m_contactManager.m_contactListener:null}SetUserOverridableBuffer(t,e){t.data=e,t.userSuppliedCapacity=e.length}SetGroupFlags(t,e){const s=t.m_groupFlags;(s^e)&On.b2_solidParticleGroup&&(e|=On.b2_particleGroupNeedsUpdateDepth),s&~e&&(this.m_needsUpdateAllGroupFlags=!0),~this.m_allGroupFlags&e&&(e&On.b2_solidParticleGroup&&(this.m_depthBuffer=this.RequestBuffer(this.m_depthBuffer)),this.m_allGroupFlags|=e),t.m_groupFlags=e}static BodyContactCompare(t,e){return t.index===e.index?t.weight>e.weight:t.index<e.index}RemoveSpuriousBodyContacts(){oo(this.m_bodyContactBuffer.data,0,this.m_bodyContactBuffer.count,Bo.BodyContactCompare);const t=Bo.RemoveSpuriousBodyContacts_s_n,e=Bo.RemoveSpuriousBodyContacts_s_pos,s=Bo.RemoveSpuriousBodyContacts_s_normal,i=this;let n=-1,o=0;this.m_bodyContactBuffer.count=ao(this.m_bodyContactBuffer.data,r=>{if(r.index!==n&&(o=0,n=r.index),o++>3)return!0;const a=t.Copy(r.normal);a.SelfMul(i.m_particleDiameter*(1-r.weight));const h=Mt.AddVV(i.m_positionBuffer.data[r.index],a,e);if(!r.fixture.TestPoint(h)){const t=r.fixture.GetShape().GetChildCount();for(let e=0;e<t;e++){const t=s;if(r.fixture.ComputeDistance(h,t,e)<B)return!1}return!0}return!1},this.m_bodyContactBuffer.count)}DetectStuckParticle(t){this.m_stuckThreshold<=0||(++this.m_bodyContactCountBuffer.data[t],2===this.m_bodyContactCountBuffer.data[t]&&(++this.m_consecutiveContactStepsBuffer.data[t],this.m_consecutiveContactStepsBuffer.data[t]>this.m_stuckThreshold&&(this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()]=t)),this.m_lastBodyContactStepBuffer.data[t]=this.m_timestamp)}ValidateParticleIndex(t){return t>=0&&t<this.GetParticleCount()&&t!==D}GetQuantizedTimeElapsed(){return Math.floor(this.m_timeElapsed/4294967296)}LifetimeToExpirationTime(t){return this.m_timeElapsed+Math.floor(t/this.m_def.lifetimeGranularity*4294967296)}ForceCanBeApplied(t){return!(t&Xn.b2_wallParticle)}PrepareForceBuffer(){if(!this.m_hasForce){for(let t=0;t<this.m_count;t++)this.m_forceBuffer[t].SetZero();this.m_hasForce=!0}}IsRigidGroup(t){return null!==t&&0!=(t.m_groupFlags&On.b2_rigidParticleGroup)}GetLinearVelocity(t,e,s,i){return t&&this.IsRigidGroup(t)?t.GetLinearVelocityFromWorldPoint(s,i):i.Copy(this.m_velocityBuffer.data[e])}InitDampingParameter(t,e,s,i,n,o,r,a){t[0]=i>0?1/i:0,e[0]=n>0?1/n:0,s[0]=Mt.CrossVV(Mt.SubVV(r,o,Mt.s_t0),a)}InitDampingParameterWithRigidGroupOrParticle(t,e,s,i,n,o,r,a){if(n&&i)this.InitDampingParameter(t,e,s,n.GetMass(),n.GetInertia(),n.GetCenter(),r,a);else{const i=this.m_flagsBuffer.data[o];this.InitDampingParameter(t,e,s,i&Xn.b2_wallParticle?0:this.GetParticleMass(),0,r,r,a)}}ComputeDampingImpulse(t,e,s,i,n,o,r){const a=t+e*s*s+i+n*o*o;return a>0?r/a:0}ApplyDamping(t,e,s,i,n,o,r,a){n&&i?(n.m_linearVelocity.SelfMulAdd(r*t,a),n.m_angularVelocity+=r*s*e):this.m_velocityBuffer.data[o].SelfMulAdd(r*t,a)}}Bo.xTruncBits=12,Bo.yTruncBits=12,Bo.tagBits=32,Bo.yOffset=1<<Bo.yTruncBits-1,Bo.yShift=Bo.tagBits-Bo.yTruncBits,Bo.xShift=Bo.tagBits-Bo.yTruncBits-Bo.xTruncBits,Bo.xScale=1<<Bo.xShift,Bo.xOffset=Bo.xScale*(1<<Bo.xTruncBits-1),Bo.yMask=(1<<Bo.yTruncBits)-1<<Bo.yShift,Bo.xMask=~Bo.yMask,Bo.DestroyParticlesInShape_s_aabb=new Me,Bo.CreateParticleGroup_s_transform=new Rt,Bo.ComputeCollisionEnergy_s_v=new Mt,Bo.QueryShapeAABB_s_aabb=new Me,Bo.QueryPointAABB_s_aabb=new Me,Bo.RayCast_s_aabb=new Me,Bo.RayCast_s_p=new Mt,Bo.RayCast_s_v=new Mt,Bo.RayCast_s_n=new Mt,Bo.RayCast_s_point=new Mt,Bo.k_pairFlags=Xn.b2_springParticle,Bo.k_triadFlags=Xn.b2_elasticParticle,Bo.k_noPressureFlags=Xn.b2_powderParticle|Xn.b2_tensileParticle,Bo.k_extraDampingFlags=Xn.b2_staticPressureParticle,Bo.k_barrierWallFlags=Xn.b2_barrierParticle|Xn.b2_wallParticle,Bo.CreateParticlesStrokeShapeForGroup_s_edge=new Je,Bo.CreateParticlesStrokeShapeForGroup_s_d=new Mt,Bo.CreateParticlesStrokeShapeForGroup_s_p=new Mt,Bo.CreateParticlesFillShapeForGroup_s_aabb=new Me,Bo.CreateParticlesFillShapeForGroup_s_p=new Mt,Bo.UpdatePairsAndTriads_s_dab=new Mt,Bo.UpdatePairsAndTriads_s_dbc=new Mt,Bo.UpdatePairsAndTriads_s_dca=new Mt,Bo.AddContact_s_d=new Mt,Bo.UpdateBodyContacts_s_aabb=new Me,Bo.Solve_s_subStep=new mn,Bo.SolveCollision_s_aabb=new Me,Bo.SolveGravity_s_gravity=new Mt,Bo.SolveBarrier_s_aabb=new Me,Bo.SolveBarrier_s_va=new Mt,Bo.SolveBarrier_s_vb=new Mt,Bo.SolveBarrier_s_pba=new Mt,Bo.SolveBarrier_s_vba=new Mt,Bo.SolveBarrier_s_vc=new Mt,Bo.SolveBarrier_s_pca=new Mt,Bo.SolveBarrier_s_vca=new Mt,Bo.SolveBarrier_s_qba=new Mt,Bo.SolveBarrier_s_qca=new Mt,Bo.SolveBarrier_s_dv=new Mt,Bo.SolveBarrier_s_f=new Mt,Bo.SolvePressure_s_f=new Mt,Bo.SolveDamping_s_v=new Mt,Bo.SolveDamping_s_f=new Mt,Bo.SolveRigidDamping_s_t0=new Mt,Bo.SolveRigidDamping_s_t1=new Mt,Bo.SolveRigidDamping_s_p=new Mt,Bo.SolveRigidDamping_s_v=new Mt,Bo.SolveExtraDamping_s_v=new Mt,Bo.SolveExtraDamping_s_f=new Mt,Bo.SolveRigid_s_position=new Mt,Bo.SolveRigid_s_rotation=new Lt,Bo.SolveRigid_s_transform=new Rt,Bo.SolveRigid_s_velocityTransform=new Rt,Bo.SolveElastic_s_pa=new Mt,Bo.SolveElastic_s_pb=new Mt,Bo.SolveElastic_s_pc=new Mt,Bo.SolveElastic_s_r=new Lt,Bo.SolveElastic_s_t0=new Mt,Bo.SolveSpring_s_pa=new Mt,Bo.SolveSpring_s_pb=new Mt,Bo.SolveSpring_s_d=new Mt,Bo.SolveSpring_s_f=new Mt,Bo.SolveTensile_s_weightedNormal=new Mt,Bo.SolveTensile_s_s=new Mt,Bo.SolveTensile_s_f=new Mt,Bo.SolveViscous_s_v=new Mt,Bo.SolveViscous_s_f=new Mt,Bo.SolveRepulsive_s_f=new Mt,Bo.SolvePowder_s_f=new Mt,Bo.SolveSolid_s_f=new Mt,Bo.RemoveSpuriousBodyContacts_s_n=new Mt,Bo.RemoveSpuriousBodyContacts_s_pos=new Mt,Bo.RemoveSpuriousBodyContacts_s_normal=new Mt;class So{constructor(){this._data=null,this.userSuppliedCapacity=0}get data(){return this._data}set data(t){this._data=t}}class Ao{constructor(){this.index=D,this.tag=0}static CompareProxyProxy(t,e){return t.tag<e.tag}static CompareTagProxy(t,e){return t<e.tag}static CompareProxyTag(t,e){return t.tag<e}}class Co{constructor(t,e,s,i,n){this.m_system=t,this.m_xLower=(e&Bo.xMask)>>>0,this.m_xUpper=(s&Bo.xMask)>>>0,this.m_yLower=(e&Bo.yMask)>>>0,this.m_yUpper=(s&Bo.yMask)>>>0,this.m_first=i,this.m_last=n}GetNext(){for(;this.m_first<this.m_last;){const t=(this.m_system.m_proxyBuffer.data[this.m_first].tag&Bo.xMask)>>>0;if(t>=this.m_xLower&&t<=this.m_xUpper)return this.m_system.m_proxyBuffer.data[this.m_first++].index;this.m_first++}return D}}class Vo{constructor(){this.next=null,this.count=0,this.index=0}}class go{constructor(){this.data=[],this.valid=[],this.count=0}Clear(){this.data.length=0,this.valid.length=0,this.count=0}GetCount(){return this.count}Invalidate(t){this.valid[t]=!1}GetValidBuffer(){return this.valid}GetBuffer(){return this.data}SetCount(t){this.count=t}Append(t){this.data[this.count]=t,this.valid[this.count]=!0,this.count++}}class wo extends go{Initialize(t,e){this.Clear();for(let s=0;s<t.count;s++){const i=t.data[s];e.data[i.index]&Xn.b2_fixtureContactListenerParticle&&this.Append(i.Clone())}}Find(t){for(let e=0;e<this.GetCount();e++)if(this.data[e].fixture===t.fixture&&this.data[e].index===t.index)return e;return D}}class vo extends go{constructor(t){super(),this.particleSystem=t}Initialize(t,e){this.Clear();for(let s=0;s<t.count;s++){const i=t.data[s];if(!(e.data[i.index]&Xn.b2_fixtureContactListenerParticle))continue;this.particleSystem.m_groupBuffer[i.index]&&(this.Find(i)===D&&this.Append(i.Clone()))}}Find(t){if(!this.data.length)return D;const e=this.particleSystem.m_groupBuffer[t.index];for(let s=0;s<this.data.length;s++){const i=this.particleSystem.m_groupBuffer[this.data[s].index];if(this.data[s].body.m_id===t.body.m_id&&(null==e?void 0:e.id)===(null==i?void 0:i.id))return s}return D}}class bo extends go{Initialize(t,e){this.Clear();for(let s=0;s<t.count;s++){const i=t.data[s];(e.data[i.indexA]&Xn.b2_particleContactListenerParticle||e.data[i.indexB]&Xn.b2_particleContactListenerParticle)&&(this.Find(i)||this.Append(i.Clone()))}}Find(t){for(let e=0;e<this.GetCount();e++)if(this.data[e].indexA===t.indexA&&this.data[e].indexB===t.indexB)return e;return D}}class Mo extends go{constructor(t){super(),this.particleSystem=t}Initialize(t,e){this.Clear();for(let s=0;s<t.count;s++){const i=t.data[s];if(!(e.data[i.indexA]&Xn.b2_particleContactListenerParticle||e.data[i.indexB]&Xn.b2_particleContactListenerParticle))continue;const n=this.particleSystem.m_groupBuffer[i.indexA],o=this.particleSystem.m_groupBuffer[i.indexB];n&&o&&n!==o&&(this.Find(i)===D&&this.Append(i.Clone()))}}Find(t){const e=this.particleSystem.m_groupBuffer[t.indexA],s=this.particleSystem.m_groupBuffer[t.indexB];for(let t=0;t<this.data.length;t++){const i=this.particleSystem.m_groupBuffer[this.data[t].indexA],n=this.particleSystem.m_groupBuffer[this.data[t].indexB];if(e===i&&s===n||e===n&&s===i)return t}return D}}class Po{IsNecessary(t){return!0}ShouldCreatePair(t,e){return!0}ShouldCreateTriad(t,e,s){return!0}}class Io extends an{constructor(t,e,s,i){super(),this.m_callDestructionListener=!1,this.m_destroyed=0,this.m_system=t,this.m_shape=e,this.m_xf=s,this.m_callDestructionListener=i,this.m_destroyed=0}ReportFixture(t){return!1}ReportParticle(t,e){return t===this.m_system&&(this.m_shape.TestPoint(this.m_xf,this.m_system.m_positionBuffer.data[e])&&(this.m_system.DestroyParticle(e,this.m_callDestructionListener),this.m_destroyed++),!0)}Destroyed(){return this.m_destroyed}}class Go extends Po{constructor(t){super(),this.m_threshold=0,this.m_threshold=t}ShouldCreatePair(t,e){return t<this.m_threshold&&this.m_threshold<=e||e<this.m_threshold&&this.m_threshold<=t}ShouldCreateTriad(t,e,s){return(t<this.m_threshold||e<this.m_threshold||s<this.m_threshold)&&(this.m_threshold<=t||this.m_threshold<=e||this.m_threshold<=s)}}class Do extends je{constructor(t,e=t.length){super(Ne.e_unknown,0),this.m_shapeCount=0,this.m_shapes=t,this.m_shapeCount=e}Clone(){throw new Error}GetChildCount(){return 1}TestPoint(t,e){for(let s=0;s<this.m_shapeCount;s++)if(this.m_shapes[s].TestPoint(t,e))return!0;return!1}ComputeDistance(t,e,s,i){return 0}RayCast(t,e,s,i){return!1}ComputeAABB(t,e,s){const i=new Me;t.lowerBound.x=+_,t.lowerBound.y=+_,t.upperBound.x=-_,t.upperBound.y=-_;for(let s=0;s<this.m_shapeCount;s++){const n=this.m_shapes[s].GetChildCount();for(let o=0;o<n;o++){const n=i;this.m_shapes[s].ComputeAABB(n,e,o),t.Combine1(n)}}}ComputeMass(t,e){}SetupDistanceProxy(t,e){}ComputeSubmergedArea(t,e,s,i){return 0}Dump(t){}}class Fo extends Po{constructor(t){super(),this.m_flagsBuffer=t}IsNecessary(t){return 0!=(this.m_flagsBuffer.data[t]&Xn.b2_reactiveParticle)}}class Lo extends co{constructor(t){super(t)}ReportFixtureAndParticle(t,e,s){const i=Lo.ReportFixtureAndParticle_s_n,n=Lo.ReportFixtureAndParticle_s_rp,o=this.m_system.m_positionBuffer.data[s],r=i,a=t.ComputeDistance(o,r,e);if(a<this.m_system.m_particleDiameter&&this.ShouldCollideFixtureParticle(t,s)){const e=t.GetBody(),i=e.GetWorldCenter(),h=e.GetMass(),l=e.GetInertia()-h*e.GetLocalCenter().LengthSquared(),_=h>0?1/h:0,m=l>0?1/l:0,c=this.m_system.m_flagsBuffer.data[s]&Xn.b2_wallParticle?0:this.m_system.GetParticleInvMass(),u=Mt.SubVV(o,i,n),d=Mt.CrossVV(u,r),f=c+_+m*d*d,p=this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];p.index=s,p.body=e,p.fixture=t,p.weight=1-a*this.m_system.m_inverseDiameter,p.normal.Copy(r.SelfNeg()),p.mass=f>0?1/f:0,this.m_system.DetectStuckParticle(s)}}}Lo.ReportFixtureAndParticle_s_n=new Mt,Lo.ReportFixtureAndParticle_s_rp=new Mt;class Ro extends co{constructor(t,e){super(t),this.m_step=e}ReportFixtureAndParticle(t,e,s){const i=Ro.ReportFixtureAndParticle_s_p1,n=Ro.ReportFixtureAndParticle_s_output,o=Ro.ReportFixtureAndParticle_s_input,r=Ro.ReportFixtureAndParticle_s_p,a=Ro.ReportFixtureAndParticle_s_v,h=Ro.ReportFixtureAndParticle_s_f,l=t.GetBody(),_=this.m_system.m_positionBuffer.data[s],m=this.m_system.m_velocityBuffer.data[s],c=n,u=o;if(0===this.m_system.m_iterationIndex){const e=Rt.MulTXV(l.m_xf0,_,i);t.GetShape().GetType()===Ne.e_circleShape&&(e.SelfSub(l.GetLocalCenter()),Lt.MulRV(l.m_xf0.q,e,e),Lt.MulTRV(l.m_xf.q,e,e),e.SelfAdd(l.GetLocalCenter())),Rt.MulXV(l.m_xf,e,u.p1)}else u.p1.Copy(_);if(Mt.AddVMulSV(_,this.m_step.dt,m,u.p2),u.maxFraction=1,this.ShouldCollideFixtureParticle(t,e)&&t.RayCast(c,u,e)){const t=c.normal,e=r;e.x=(1-c.fraction)*u.p1.x+c.fraction*u.p2.x+B*t.x,e.y=(1-c.fraction)*u.p1.y+c.fraction*u.p2.y+B*t.y;const i=a;i.x=this.m_step.inv_dt*(e.x-_.x),i.y=this.m_step.inv_dt*(e.y-_.y),this.m_system.m_velocityBuffer.data[s].Copy(i);const n=h;n.x=this.m_step.inv_dt*this.m_system.GetParticleMass()*(m.x-i.x),n.y=this.m_step.inv_dt*this.m_system.GetParticleMass()*(m.y-i.y),this.m_system.ParticleApplyForce(s,n)}}ReportParticle(t,e){return!1}}Ro.ReportFixtureAndParticle_s_p1=new Mt,Ro.ReportFixtureAndParticle_s_output=new be,Ro.ReportFixtureAndParticle_s_input=new ve,Ro.ReportFixtureAndParticle_s_p=new Mt,Ro.ReportFixtureAndParticle_s_v=new Mt,Ro.ReportFixtureAndParticle_s_f=new Mt;class To{constructor(t){this.m_contactManager=new ln,this.m_bodyList=null,this.m_jointList=null,this.m_particleSystemList=null,this.m_bodyCount=0,this.m_jointCount=0,this.m_gravity=new Mt,this.m_allowSleep=!0,this.m_destructionListener=null,this.m_debugDraw=null,this.m_inv_dt0=0,this.m_newContacts=!1,this.m_locked=!1,this.m_clearForces=!0,this.m_warmStarting=!0,this.m_continuousPhysics=!0,this.m_subStepping=!1,this.m_stepComplete=!0,this.m_profile=new _n,this.m_island=new Mn,this.s_stack=[],this.m_controllerList=null,this.m_controllerCount=0,this.m_gravity.Copy(t)}SetDestructionListener(t){this.m_destructionListener=t}SetContactFilter(t){this.m_contactManager.m_contactFilter=t}SetContactListener(t){this.m_contactManager.m_contactListener=t}SetDebugDraw(t){this.m_debugDraw=t}CreateBody(t=new Ei){if(this.IsLocked())throw new Error;const e=new Ni(t,this);return e.m_prev=null,e.m_next=this.m_bodyList,this.m_bodyList&&(this.m_bodyList.m_prev=e),this.m_bodyList=e,++this.m_bodyCount,e}DestroyBody(t){if(this.IsLocked())throw new Error;let e=t.m_jointList;for(;e;){const s=e;e=e.next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeJoint(s.joint),this.DestroyJoint(s.joint),t.m_jointList=e}t.m_jointList=null;let s=t.m_controllerList;for(;s;){const e=s;s=s.nextController,e.controller.RemoveBody(t)}let i=t.m_contactList;for(;i;){const t=i;i=i.next,this.m_contactManager.Destroy(t.contact)}t.m_contactList=null;let n=t.m_fixtureList;for(;n;){const e=n;n=n.m_next,this.m_destructionListener&&this.m_destructionListener.SayGoodbyeFixture(e),e.DestroyProxies(),e.Reset(),t.m_fixtureList=n,t.m_fixtureCount-=1}t.m_fixtureList=null,t.m_fixtureCount=0,t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_bodyList&&(this.m_bodyList=t.m_next),--this.m_bodyCount}static _Joint_Create(t){switch(t.type){case gi.e_distanceJoint:return new Fi(t);case gi.e_mouseJoint:return new Dn(t);case gi.e_prismaticJoint:return new Ln(t);case gi.e_revoluteJoint:return new zn(t);case gi.e_pulleyJoint:return new kn(t);case gi.e_gearJoint:return new bn(t);case gi.e_wheelJoint:return new Jn(t);case gi.e_weldJoint:return new Nn(t);case gi.e_frictionJoint:return new wn(t);case gi.e_motorJoint:return new In(t);case gi.e_areaJoint:return new Ri(t)}throw new Error}static _Joint_Destroy(t){}CreateJoint(t){if(this.IsLocked())throw new Error;const e=To._Joint_Create(t);e.m_prev=null,e.m_next=this.m_jointList,this.m_jointList&&(this.m_jointList.m_prev=e),this.m_jointList=e,++this.m_jointCount,e.m_edgeA.prev=null,e.m_edgeA.next=e.m_bodyA.m_jointList,e.m_bodyA.m_jointList&&(e.m_bodyA.m_jointList.prev=e.m_edgeA),e.m_bodyA.m_jointList=e.m_edgeA,e.m_edgeB.prev=null,e.m_edgeB.next=e.m_bodyB.m_jointList,e.m_bodyB.m_jointList&&(e.m_bodyB.m_jointList.prev=e.m_edgeB),e.m_bodyB.m_jointList=e.m_edgeB;const s=e.m_bodyA,i=e.m_bodyB;if(!e.m_collideConnected){let t=i.GetContactList();for(;t;)t.other===s&&t.contact.FlagForFiltering(),t=t.next}return e}DestroyJoint(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_jointList&&(this.m_jointList=t.m_next);const e=t.m_bodyA,s=t.m_bodyB,i=t.m_collideConnected;if(e.SetAwake(!0),s.SetAwake(!0),t.m_edgeA.prev&&(t.m_edgeA.prev.next=t.m_edgeA.next),t.m_edgeA.next&&(t.m_edgeA.next.prev=t.m_edgeA.prev),t.m_edgeA===e.m_jointList&&(e.m_jointList=t.m_edgeA.next),t.m_edgeA.Reset(),t.m_edgeB.prev&&(t.m_edgeB.prev.next=t.m_edgeB.next),t.m_edgeB.next&&(t.m_edgeB.next.prev=t.m_edgeB.prev),t.m_edgeB===s.m_jointList&&(s.m_jointList=t.m_edgeB.next),t.m_edgeB.Reset(),To._Joint_Destroy(t),--this.m_jointCount,!i){let t=s.GetContactList();for(;t;)t.other===e&&t.contact.FlagForFiltering(),t=t.next}}CreateParticleSystem(t){if(this.IsLocked())throw new Error;const e=new Bo(t,this);return e.m_prev=null,e.m_next=this.m_particleSystemList,this.m_particleSystemList&&(this.m_particleSystemList.m_prev=e),this.m_particleSystemList=e,e}DestroyParticleSystem(t){if(this.IsLocked())throw new Error;t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_particleSystemList&&(this.m_particleSystemList=t.m_next)}CalculateReasonableParticleIterations(t){if(null===this.m_particleSystemList)return 1;return Qn(this.m_gravity.Length(),function(t){let e=_;for(let s=t.GetParticleSystemList();null!==s;s=s.m_next)e=ht(e,s.GetRadius());return e}(this),t)}Step(t,e,s,i=this.CalculateReasonableParticleIterations(t)){const n=To.Step_s_stepTimer.Reset();this.m_newContacts&&(this.m_contactManager.FindNewContacts(),this.m_newContacts=!1),this.m_locked=!0;const o=To.Step_s_step;o.dt=t,o.velocityIterations=e,o.positionIterations=s,o.particleIterations=i,o.inv_dt=t>0?1/t:0,o.dtRatio=this.m_inv_dt0*t,o.warmStarting=this.m_warmStarting;const r=To.Step_s_timer.Reset();if(this.m_contactManager.Collide(),this.m_profile.collide=r.GetMilliseconds(),this.m_stepComplete&&o.dt>0){const t=To.Step_s_timer.Reset();for(let t=this.m_particleSystemList;t;t=t.m_next)t.Solve(o);this.Solve(o),this.m_profile.solve=t.GetMilliseconds()}if(this.m_continuousPhysics&&o.dt>0){const t=To.Step_s_timer.Reset();this.SolveTOI(o),this.m_profile.solveTOI=t.GetMilliseconds()}o.dt>0&&(this.m_inv_dt0=o.inv_dt),this.m_clearForces&&this.ClearForces(),this.m_locked=!1,this.m_profile.step=n.GetMilliseconds()}ClearForces(){for(let t=this.m_bodyList;t;t=t.m_next)t.m_force.SetZero(),t.m_torque=0}DrawParticleSystem(t){if(null===this.m_debugDraw)return;const e=t.GetParticleCount();if(!e)return;const s=t.GetRadius(),i=t.GetPositionBuffer();let n=null;t.m_colorBuffer.data&&(n=t.GetColorBuffer());const o=t.GetTriads().map(t=>[t.indexA,t.indexB,t.indexC]),a=this.m_debugDraw.GetFlags();a&r.e_particleBit&&this.m_debugDraw.DrawParticles(i,s,n,e),a&r.e_particleTriadBit&&this.m_debugDraw.DrawParticleTriads(i,o,null)}DebugDraw(){if(null===this.m_debugDraw)return;const t=this.m_debugDraw.GetFlags(),e=To.DebugDraw_s_color.SetRGB(0,0,0);if(t&r.e_shapeBit)for(let t=this.m_bodyList;t;t=t.m_next){const s=t.m_xf;this.m_debugDraw.PushTransform(s);for(let s=t.GetFixtureList();s;s=s.m_next)t.GetType()===wi.b2_dynamicBody&&0===t.m_mass?this.DrawShape(s,new n(1,0,0)):t.IsEnabled()?t.GetType()===wi.b2_staticBody?(e.SetRGB(.5,.9,.5),this.DrawShape(s,e)):t.GetType()===wi.b2_kinematicBody?(e.SetRGB(.5,.5,.9),this.DrawShape(s,e)):t.IsAwake()?(e.SetRGB(.9,.7,.7),this.DrawShape(s,e)):(e.SetRGB(.6,.6,.6),this.DrawShape(s,e)):(e.SetRGB(.5,.5,.3),this.DrawShape(s,e));this.m_debugDraw.PopTransform(s)}if(t&r.e_particleBit||t&r.e_particleTriadBit){this.m_debugDraw.PushTransform(Rt.IDENTITY);for(let t=this.m_particleSystemList;t;t=t.m_next)this.DrawParticleSystem(t);this.m_debugDraw.PopTransform(Rt.IDENTITY)}if(t&r.e_jointBit)for(let t=this.m_jointList;t;t=t.m_next)t.Draw(this.m_debugDraw);if(t&r.e_pairBit){e.SetRGB(.3,.9,.9);for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){const s=t.GetFixtureA(),i=t.GetFixtureB(),n=t.GetChildIndexA(),o=t.GetChildIndexB(),r=s.GetAABB(n).GetCenter(),a=i.GetAABB(o).GetCenter();this.m_debugDraw.DrawSegment(r,a,e)}}if(t&r.e_aabbBit){e.SetRGB(.9,.3,.9);const t=To.DebugDraw_s_vs;for(let s=this.m_bodyList;s;s=s.m_next)if(s.IsEnabled())for(let i=s.GetFixtureList();i;i=i.m_next)for(let s=0;s<i.m_proxyCount;++s){const n=i.m_proxies[s].treeNode.aabb;t[0].Set(n.lowerBound.x,n.lowerBound.y),t[1].Set(n.upperBound.x,n.lowerBound.y),t[2].Set(n.upperBound.x,n.upperBound.y),t[3].Set(n.lowerBound.x,n.upperBound.y),this.m_debugDraw.DrawPolygon(t,4,e)}}if(t&r.e_centerOfMassBit)for(let t=this.m_bodyList;t;t=t.m_next){const e=To.DebugDraw_s_xf;e.q.Copy(t.m_xf.q),e.p.Copy(t.GetWorldCenter()),this.m_debugDraw.DrawTransform(e)}if(t&r.e_controllerBit)for(let t=this.m_controllerList;t;t=t.m_next)t.Draw(this.m_debugDraw)}QueryAABB(...t){t[0]instanceof an?this._QueryAABB(t[0],t[1]):this._QueryAABB(null,t[0],t[1])}_QueryAABB(t,e,s){if(this.m_contactManager.m_broadPhase.Query(e,e=>{const i=e.userData.fixture;return t?t.ReportFixture(i):!s||s(i)}),t instanceof an)for(let s=this.m_particleSystemList;s;s=s.m_next)t.ShouldQueryParticleSystem(s)&&s.QueryAABB(t,e)}QueryAllAABB(t,e=[]){return this.QueryAABB(t,t=>(e.push(t),!0)),e}QueryPointAABB(...t){t[0]instanceof an?this._QueryPointAABB(t[0],t[1]):this._QueryPointAABB(null,t[0],t[1])}_QueryPointAABB(t,e,s){if(this.m_contactManager.m_broadPhase.QueryPoint(e,e=>{const i=e.userData.fixture;return t?t.ReportFixture(i):!s||s(i)}),t instanceof an)for(let s=this.m_particleSystemList;s;s=s.m_next)t.ShouldQueryParticleSystem(s)&&s.QueryPointAABB(t,e)}QueryAllPointAABB(t,e=[]){return this.QueryPointAABB(t,t=>(e.push(t),!0)),e}QueryFixtureShape(...t){t[0]instanceof an?this._QueryFixtureShape(t[0],t[1],t[2],t[3]):this._QueryFixtureShape(null,t[0],t[1],t[2],t[3])}_QueryFixtureShape(t,e,s,i,n){const o=To.QueryFixtureShape_s_aabb;if(e.ComputeAABB(o,i,s),this.m_contactManager.m_broadPhase.Query(o,o=>{const r=o.userData,a=r.fixture;if(Le(e,s,a.GetShape(),r.childIndex,i,a.GetBody().GetTransform())){if(t)return t.ReportFixture(a);if(n)return n(a)}return!0}),t instanceof an)for(let e=this.m_particleSystemList;e;e=e.m_next)t.ShouldQueryParticleSystem(e)&&e.QueryAABB(t,o)}QueryAllFixtureShape(t,e,s,i=[]){return this.QueryFixtureShape(t,e,s,t=>(i.push(t),!0)),i}QueryFixturePoint(...t){t[0]instanceof an?this._QueryFixturePoint(t[0],t[1]):this._QueryFixturePoint(null,t[0],t[1])}_QueryFixturePoint(t,e,s){if(this.m_contactManager.m_broadPhase.QueryPoint(e,i=>{const n=i.userData.fixture;if(n.TestPoint(e)){if(t)return t.ReportFixture(n);if(s)return s(n)}return!0}),t)for(let s=this.m_particleSystemList;s;s=s.m_next)t.ShouldQueryParticleSystem(s)&&s.QueryPointAABB(t,e)}QueryAllFixturePoint(t,e=[]){return this.QueryFixturePoint(t,t=>(e.push(t),!0)),e}RayCast(...t){t[0]instanceof hn?this._RayCast(t[0],t[1],t[2]):this._RayCast(null,t[0],t[1],t[2])}_RayCast(t,e,s,i){const n=To.RayCast_s_input;if(n.maxFraction=1,n.p1.Copy(e),n.p2.Copy(s),this.m_contactManager.m_broadPhase.RayCast(n,(n,o)=>{const r=o.userData,a=r.fixture,h=r.childIndex,l=To.RayCast_s_output;if(a.RayCast(l,n,h)){const n=l.fraction,o=To.RayCast_s_point;if(o.Set((1-n)*e.x+n*s.x,(1-n)*e.y+n*s.y),t)return t.ReportFixture(a,o,l.normal,n);if(i)return i(a,o,l.normal,n)}return n.maxFraction}),t)for(let i=this.m_particleSystemList;i;i=i.m_next)t.ShouldQueryParticleSystem(i)&&i.RayCast(t,e,s)}RayCastOne(t,e){let s=null,i=1;return this.RayCast(t,e,(t,e,n,o)=>(o<i&&(i=o,s=t),i)),s}RayCastAll(t,e,s=[]){return this.RayCast(t,e,(t,e,i,n)=>(s.push(t),1)),s}GetBodyList(){return this.m_bodyList}GetJointList(){return this.m_jointList}GetParticleSystemList(){return this.m_particleSystemList}GetContactList(){return this.m_contactManager.m_contactList}SetAllowSleeping(t){if(t!==this.m_allowSleep&&(this.m_allowSleep=t,!this.m_allowSleep))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetAllowSleeping(){return this.m_allowSleep}SetWarmStarting(t){this.m_warmStarting=t}GetWarmStarting(){return this.m_warmStarting}SetContinuousPhysics(t){this.m_continuousPhysics=t}GetContinuousPhysics(){return this.m_continuousPhysics}SetSubStepping(t){this.m_subStepping=t}GetSubStepping(){return this.m_subStepping}GetProxyCount(){return this.m_contactManager.m_broadPhase.GetProxyCount()}GetBodyCount(){return this.m_bodyCount}GetJointCount(){return this.m_jointCount}GetContactCount(){return this.m_contactManager.m_contactCount}GetTreeHeight(){return this.m_contactManager.m_broadPhase.GetTreeHeight()}GetTreeBalance(){return this.m_contactManager.m_broadPhase.GetTreeBalance()}GetTreeQuality(){return this.m_contactManager.m_broadPhase.GetTreeQuality()}SetGravity(t,e=!0){if(!Mt.IsEqualToV(this.m_gravity,t)&&(this.m_gravity.Copy(t),e))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetGravity(){return this.m_gravity}IsLocked(){return this.m_locked}SetAutoClearForces(t){this.m_clearForces=t}GetAutoClearForces(){return this.m_clearForces}ShiftOrigin(t){if(this.IsLocked())throw new Error;for(let e=this.m_bodyList;e;e=e.m_next)e.m_xf.p.SelfSub(t),e.m_sweep.c0.SelfSub(t),e.m_sweep.c.SelfSub(t);for(let e=this.m_jointList;e;e=e.m_next)e.ShiftOrigin(t);this.m_contactManager.m_broadPhase.ShiftOrigin(t)}GetContactManager(){return this.m_contactManager}GetProfile(){return this.m_profile}Dump(t){if(this.m_locked)return;t("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n",this.m_gravity.x,this.m_gravity.y),t("this.m_world.SetGravity(g);\n"),t("const bodies: b2Body[] = [];\n"),t("const joints: b2Joint[] = [];\n");let e=0;for(let s=this.m_bodyList;s;s=s.m_next)s.m_islandIndex=e,s.Dump(t),++e;e=0;for(let t=this.m_jointList;t;t=t.m_next)t.m_index=e,++e;for(let e=this.m_jointList;e;e=e.m_next)e.m_type!==gi.e_gearJoint&&(t("{\n"),e.Dump(t),t("}\n"));for(let e=this.m_jointList;e;e=e.m_next)e.m_type===gi.e_gearJoint&&(t("{\n"),e.Dump(t),t("}\n"))}DrawShape(t,e){if(null===this.m_debugDraw)return;const s=t.GetShape();switch(s.m_type){case Ne.e_circleShape:{const t=s,i=t.m_p,n=t.m_radius,o=Mt.UNITX;this.m_debugDraw.DrawSolidCircle(i,n,o,e);break}case Ne.e_edgeShape:{const t=s,i=t.m_vertex1,n=t.m_vertex2;this.m_debugDraw.DrawSegment(i,n,e),!1===t.m_oneSided&&(this.m_debugDraw.DrawPoint(i,4,e),this.m_debugDraw.DrawPoint(n,4,e));break}case Ne.e_chainShape:{const t=s,i=t.m_count,n=t.m_vertices;let o=n[0];for(let t=1;t<i;++t){const s=n[t];this.m_debugDraw.DrawSegment(o,s,e),o=s}break}case Ne.e_polygonShape:{const t=s,i=t.m_count,n=t.m_vertices;this.m_debugDraw.DrawSolidPolygon(n,i,e);break}}}Solve(t){for(let t=this.m_bodyList;t;t=t.m_next)t.m_xf0.Copy(t.m_xf);for(let e=this.m_controllerList;e;e=e.m_next)e.Step(t);this.m_profile.solveInit=0,this.m_profile.solveVelocity=0,this.m_profile.solvePosition=0;const e=this.m_island;e.Initialize(this.m_bodyCount,this.m_contactManager.m_contactCount,this.m_jointCount,this.m_contactManager.m_contactListener);for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_jointList;t;t=t.m_next)t.m_islandFlag=!1;const s=this.s_stack;for(let i=this.m_bodyList;i;i=i.m_next){if(i.m_islandFlag)continue;if(!i.IsAwake()||!i.IsEnabled())continue;if(i.GetType()===wi.b2_staticBody)continue;e.Clear();let n=0;for(s[n++]=i,i.m_islandFlag=!0;n>0;){const t=s[--n];if(!t)throw new Error;if(e.AddBody(t),t.GetType()!==wi.b2_staticBody){t.m_awakeFlag=!0;for(let i=t.m_contactList;i;i=i.next){const t=i.contact;if(t.m_islandFlag)continue;if(!t.IsEnabled()||!t.IsTouching())continue;const o=t.m_fixtureA.m_isSensor,r=t.m_fixtureB.m_isSensor;if(o||r)continue;e.AddContact(t),t.m_islandFlag=!0;const a=i.other;a.m_islandFlag||(s[n++]=a,a.m_islandFlag=!0)}for(let i=t.m_jointList;i;i=i.next){if(i.joint.m_islandFlag)continue;const t=i.other;t.IsEnabled()&&(e.AddJoint(i.joint),i.joint.m_islandFlag=!0,t.m_islandFlag||(s[n++]=t,t.m_islandFlag=!0))}}}const o=new _n;e.Solve(o,t,this.m_gravity,this.m_allowSleep),this.m_profile.solveInit+=o.solveInit,this.m_profile.solveVelocity+=o.solveVelocity,this.m_profile.solvePosition+=o.solvePosition;for(let t=0;t<e.m_bodyCount;++t){const s=e.m_bodies[t];s.GetType()===wi.b2_staticBody&&(s.m_islandFlag=!1)}}for(let t=0;t<s.length&&s[t];++t)s[t]=null;const i=new qt;for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag&&t.GetType()!==wi.b2_staticBody&&t.SynchronizeFixtures();this.m_contactManager.FindNewContacts(),this.m_profile.broadphase=i.GetMilliseconds()}SolveTOI(t){const e=this.m_island;if(e.Initialize(2*V,V,0,this.m_contactManager.m_contactListener),this.m_stepComplete){for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1,t.m_sweep.alpha0=0;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_toiFlag=!1,t.m_islandFlag=!1,t.m_toiCount=0,t.m_toi=1}for(;;){let s=null,i=1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){if(!t.IsEnabled())continue;if(t.m_toiCount>C)continue;let e=1;if(t.m_toiFlag)e=t.m_toi;else{const s=t.GetFixtureA(),i=t.GetFixtureB();if(s.IsSensor()||i.IsSensor())continue;const n=s.GetBody(),o=i.GetBody(),r=n.m_type,a=o.m_type,h=n.IsAwake()&&r!==wi.b2_staticBody,l=o.IsAwake()&&a!==wi.b2_staticBody;if(!h&&!l)continue;const _=n.IsBullet()||r!==wi.b2_dynamicBody,m=o.IsBullet()||a!==wi.b2_dynamicBody;if(!_&&!m)continue;let c=n.m_sweep.alpha0;n.m_sweep.alpha0<o.m_sweep.alpha0?(c=o.m_sweep.alpha0,n.m_sweep.Advance(c)):o.m_sweep.alpha0<n.m_sweep.alpha0&&(c=n.m_sweep.alpha0,o.m_sweep.Advance(c));const u=t.GetChildIndexA(),d=t.GetChildIndexB(),f=To.SolveTOI_s_toi_input;f.proxyA.SetShape(s.GetShape(),u),f.proxyB.SetShape(i.GetShape(),d),f.sweepA.Copy(n.m_sweep),f.sweepB.Copy(o.m_sweep),f.tMax=1;const p=To.SolveTOI_s_toi_output;Vi(p,f);const y=p.t;e=p.state===_i.e_touching?ht(c+(1-c)*y,1):1,t.m_toi=e,t.m_toiFlag=!0}e<i&&(s=t,i=e)}if(null===s||1-10*m<i){this.m_stepComplete=!0;break}const n=s.GetFixtureA(),o=s.GetFixtureB(),r=n.GetBody(),a=o.GetBody(),h=To.SolveTOI_s_backup1.Copy(r.m_sweep),l=To.SolveTOI_s_backup2.Copy(a.m_sweep);if(r.Advance(i),a.Advance(i),s.Update(this.m_contactManager.m_contactListener),s.m_toiFlag=!1,++s.m_toiCount,!s.IsEnabled()||!s.IsTouching()){s.SetEnabled(!1),r.m_sweep.Copy(h),a.m_sweep.Copy(l),r.SynchronizeTransform(),a.SynchronizeTransform();continue}r.SetAwake(!0),a.SetAwake(!0),e.Clear(),e.AddBody(r),e.AddBody(a),e.AddContact(s),r.m_islandFlag=!0,a.m_islandFlag=!0,s.m_islandFlag=!0;for(let t=0;t<2;++t){const s=0===t?r:a;if(s.m_type===wi.b2_dynamicBody)for(let t=s.m_contactList;t&&e.m_bodyCount!==e.m_bodyCapacity&&e.m_contactCount!==e.m_contactCapacity;t=t.next){const n=t.contact;if(n.m_islandFlag)continue;const o=t.other;if(o.m_type===wi.b2_dynamicBody&&!s.IsBullet()&&!o.IsBullet())continue;const r=n.m_fixtureA.m_isSensor,a=n.m_fixtureB.m_isSensor;if(r||a)continue;const h=To.SolveTOI_s_backup.Copy(o.m_sweep);o.m_islandFlag||o.Advance(i),n.Update(this.m_contactManager.m_contactListener),n.IsEnabled()&&n.IsTouching()?(n.m_islandFlag=!0,e.AddContact(n),o.m_islandFlag||(o.m_islandFlag=!0,o.m_type!==wi.b2_staticBody&&o.SetAwake(!0),e.AddBody(o))):(o.m_sweep.Copy(h),o.SynchronizeTransform())}}const _=To.SolveTOI_s_subStep;_.dt=(1-i)*t.dt,_.inv_dt=1/_.dt,_.dtRatio=1,_.positionIterations=20,_.velocityIterations=t.velocityIterations,_.particleIterations=t.particleIterations,_.warmStarting=!1,e.SolveTOI(_,r.m_islandIndex,a.m_islandIndex);for(let t=0;t<e.m_bodyCount;++t){const s=e.m_bodies[t];if(s.m_islandFlag=!1,s.m_type===wi.b2_dynamicBody){s.SynchronizeFixtures();for(let t=s.m_contactList;t;t=t.next)t.contact.m_toiFlag=!1,t.contact.m_islandFlag=!1}}if(this.m_contactManager.FindNewContacts(),this.m_subStepping){this.m_stepComplete=!1;break}}}AddController(t){return t.m_next=this.m_controllerList,t.m_prev=null,this.m_controllerList&&(this.m_controllerList.m_prev=t),this.m_controllerList=t,++this.m_controllerCount,t}RemoveController(t){return t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),this.m_controllerList===t&&(this.m_controllerList=t.m_next),--this.m_controllerCount,t.m_prev=null,t.m_next=null,t}}To.Step_s_step=new mn,To.Step_s_stepTimer=new qt,To.Step_s_timer=new qt,To.DebugDraw_s_color=new n(0,0,0),To.DebugDraw_s_vs=Mt.MakeArray(4),To.DebugDraw_s_xf=new Rt,To.QueryFixtureShape_s_aabb=new Me,To.RayCast_s_input=new ve,To.RayCast_s_output=new be,To.RayCast_s_point=new Mt,To.SolveTOI_s_subStep=new mn,To.SolveTOI_s_backup=new Tt,To.SolveTOI_s_backup1=new Tt,To.SolveTOI_s_backup2=new Tt,To.SolveTOI_s_toi_input=new li,To.SolveTOI_s_toi_output=new ci,function(t){t[t.b2_pbdStretchingModel=0]="b2_pbdStretchingModel",t[t.b2_xpbdStretchingModel=1]="b2_xpbdStretchingModel"}(Zn||(Zn={})),function(t){t[t.b2_springAngleBendingModel=0]="b2_springAngleBendingModel",t[t.b2_pbdAngleBendingModel=1]="b2_pbdAngleBendingModel",t[t.b2_xpbdAngleBendingModel=2]="b2_xpbdAngleBendingModel",t[t.b2_pbdDistanceBendingModel=3]="b2_pbdDistanceBendingModel",t[t.b2_pbdHeightBendingModel=4]="b2_pbdHeightBendingModel",t[t.b2_pbdTriangleBendingModel=5]="b2_pbdTriangleBendingModel"}(Un||(Un={}));class ko{constructor(){this.stretchingModel=Zn.b2_pbdStretchingModel,this.bendingModel=Un.b2_pbdAngleBendingModel,this.damping=0,this.stretchStiffness=1,this.stretchHertz=0,this.stretchDamping=0,this.bendStiffness=.5,this.bendHertz=1,this.bendDamping=0,this.isometric=!1,this.fixedEffectiveMass=!1,this.warmStart=!1}Copy(t){return this.stretchingModel=t.stretchingModel,this.bendingModel=t.bendingModel,this.damping=t.damping,this.stretchStiffness=t.stretchStiffness,this.stretchHertz=t.stretchHertz,this.stretchDamping=t.stretchDamping,this.bendStiffness=t.bendStiffness,this.bendHertz=t.bendHertz,this.bendDamping=t.bendDamping,this.isometric=t.isometric,this.fixedEffectiveMass=t.fixedEffectiveMass,this.warmStart=t.warmStart,this}}class qo{constructor(){this.position=new Mt,this.vertices=[],this.count=0,this.masses=[],this.gravity=new Mt,this.tuning=new ko}}class zo{constructor(){this.i1=0,this.i2=0,this.invMass1=0,this.invMass2=0,this.L=0,this.lambda=0,this.spring=0,this.damper=0}}class Eo{constructor(){this.i1=0,this.i2=0,this.i3=0,this.invMass1=0,this.invMass2=0,this.invMass3=0,this.invEffectiveMass=0,this.lambda=0,this.L1=0,this.L2=0,this.alpha1=0,this.alpha2=0,this.spring=0,this.damper=0}}class No{constructor(){this.m_position=new Mt,this.m_count=0,this.m_stretchCount=0,this.m_bendCount=0,this.m_stretchConstraints=[],this.m_bendConstraints=[],this.m_bindPositions=[],this.m_ps=[],this.m_p0s=[],this.m_vs=[],this.m_invMasses=[],this.m_gravity=new Mt,this.m_tuning=new ko}Create(t){function e(t,e,s){for(let i=0;i<e;++i)t[i]=s(i)}this.m_position.Copy(t.position),this.m_count=t.count,e(this.m_bindPositions,this.m_count,()=>new Mt),e(this.m_ps,this.m_count,()=>new Mt),e(this.m_p0s,this.m_count,()=>new Mt),e(this.m_vs,this.m_count,()=>new Mt),e(this.m_invMasses,this.m_count,()=>0);for(let e=0;e<this.m_count;++e){this.m_bindPositions[e].Copy(t.vertices[e]),this.m_ps[e].Copy(t.vertices[e]).SelfAdd(this.m_position),this.m_p0s[e].Copy(t.vertices[e]).SelfAdd(this.m_position),this.m_vs[e].SetZero();const s=t.masses[e];this.m_invMasses[e]=s>0?1/s:0}this.m_stretchCount=this.m_count-1,this.m_bendCount=this.m_count-2,e(this.m_stretchConstraints,this.m_stretchCount,()=>new zo),e(this.m_bendConstraints,this.m_bendCount,()=>new Eo);for(let t=0;t<this.m_stretchCount;++t){const e=this.m_stretchConstraints[t],s=this.m_ps[t],i=this.m_ps[t+1];e.i1=t,e.i2=t+1,e.L=Mt.DistanceVV(s,i),e.invMass1=this.m_invMasses[t],e.invMass2=this.m_invMasses[t+1],e.lambda=0,e.damper=0,e.spring=0}for(let t=0;t<this.m_bendCount;++t){const e=this.m_bendConstraints[t],s=this.m_ps[t],i=this.m_ps[t+1],n=this.m_ps[t+2];e.i1=t,e.i2=t+1,e.i3=t+2,e.invMass1=this.m_invMasses[t],e.invMass2=this.m_invMasses[t+1],e.invMass3=this.m_invMasses[t+2],e.invEffectiveMass=0,e.L1=Mt.DistanceVV(s,i),e.L2=Mt.DistanceVV(i,n),e.lambda=0;const o=Mt.SubVV(i,s,new Mt),r=Mt.SubVV(n,i,new Mt),a=o.LengthSquared(),h=r.LengthSquared();if(a*h==0)continue;const l=(new Mt).Copy(o).SelfSkew().SelfMul(-1/a),_=(new Mt).Copy(r).SelfSkew().SelfMul(1/h),m=l.Clone().SelfNeg(),c=l.Clone().SelfSub(_),u=_.Clone();e.invEffectiveMass=e.invMass1*Mt.DotVV(m,m)+e.invMass2*Mt.DotVV(c,c)+e.invMass3*Mt.DotVV(u,u);const d=Mt.SubVV(n,s,new Mt),f=d.LengthSquared();0!==f&&(e.alpha1=Mt.DotVV(r,d)/f,e.alpha2=Mt.DotVV(o,d)/f)}this.m_gravity.Copy(t.gravity),this.SetTuning(t.tuning)}SetTuning(t){this.m_tuning.Copy(t);const e=2*u*this.m_tuning.bendHertz;for(let t=0;t<this.m_bendCount;++t){const s=this.m_bendConstraints[t],i=s.L1*s.L1,n=s.L2*s.L2;if(i*n==0){s.spring=0,s.damper=0;continue}const o=1/s.L1+1/s.L2,r=s.invMass1/i+s.invMass2*o*o+s.invMass3/n;if(0===r){s.spring=0,s.damper=0;continue}const a=1/r;s.spring=a*e*e,s.damper=2*a*this.m_tuning.bendDamping*e}const s=2*u*this.m_tuning.stretchHertz;for(let t=0;t<this.m_stretchCount;++t){const e=this.m_stretchConstraints[t],i=e.invMass1+e.invMass2;if(0===i)continue;const n=1/i;e.spring=n*s*s,e.damper=2*n*this.m_tuning.stretchDamping*s}}Step(t,e,s){if(0===t)return;const i=1/t,n=Math.exp(-t*this.m_tuning.damping);for(let e=0;e<this.m_count;++e)this.m_invMasses[e]>0?(this.m_vs[e].x*=n,this.m_vs[e].y*=n,this.m_vs[e].x+=t*this.m_gravity.x,this.m_vs[e].y+=t*this.m_gravity.y):(this.m_vs[e].x=i*(this.m_bindPositions[e].x+s.x-this.m_p0s[e].x),this.m_vs[e].y=i*(this.m_bindPositions[e].y+s.y-this.m_p0s[e].y));this.m_tuning.bendingModel===Un.b2_springAngleBendingModel&&this.ApplyBendForces(t);for(let t=0;t<this.m_bendCount;++t)this.m_bendConstraints[t].lambda=0;for(let t=0;t<this.m_stretchCount;++t)this.m_stretchConstraints[t].lambda=0;for(let e=0;e<this.m_count;++e)this.m_ps[e].x+=t*this.m_vs[e].x,this.m_ps[e].y+=t*this.m_vs[e].y;for(let s=0;s<e;++s)this.m_tuning.bendingModel===Un.b2_pbdAngleBendingModel?this.SolveBend_PBD_Angle():this.m_tuning.bendingModel===Un.b2_xpbdAngleBendingModel?this.SolveBend_XPBD_Angle(t):this.m_tuning.bendingModel===Un.b2_pbdDistanceBendingModel?this.SolveBend_PBD_Distance():this.m_tuning.bendingModel===Un.b2_pbdHeightBendingModel?this.SolveBend_PBD_Height():this.m_tuning.bendingModel===Un.b2_pbdTriangleBendingModel&&this.SolveBend_PBD_Triangle(),this.m_tuning.stretchingModel===Zn.b2_pbdStretchingModel?this.SolveStretch_PBD():this.m_tuning.stretchingModel===Zn.b2_xpbdStretchingModel&&this.SolveStretch_XPBD(t);for(let t=0;t<this.m_count;++t)this.m_vs[t].x=i*(this.m_ps[t].x-this.m_p0s[t].x),this.m_vs[t].y=i*(this.m_ps[t].y-this.m_p0s[t].y),this.m_p0s[t].Copy(this.m_ps[t])}Reset(t){this.m_position.Copy(t);for(let t=0;t<this.m_count;++t)this.m_ps[t].x=this.m_bindPositions[t].x+this.m_position.x,this.m_ps[t].y=this.m_bindPositions[t].y+this.m_position.y,this.m_p0s[t].x=this.m_bindPositions[t].x+this.m_position.x,this.m_p0s[t].y=this.m_bindPositions[t].y+this.m_position.y,this.m_vs[t].SetZero();for(let t=0;t<this.m_bendCount;++t)this.m_bendConstraints[t].lambda=0;for(let t=0;t<this.m_stretchCount;++t)this.m_stretchConstraints[t].lambda=0}Draw(t){const e=new n(.4,.5,.7),s=new n(.1,.8,.1),i=new n(.7,.2,.4);for(let n=0;n<this.m_count-1;++n){t.DrawSegment(this.m_ps[n],this.m_ps[n+1],e);const o=this.m_invMasses[n]>0?i:s;t.DrawPoint(this.m_ps[n],5,o)}const o=this.m_invMasses[this.m_count-1]>0?i:s;t.DrawPoint(this.m_ps[this.m_count-1],5,o)}SolveStretch_PBD(){const t=this.m_tuning.stretchStiffness;for(let e=0;e<this.m_stretchCount;++e){const s=this.m_stretchConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=n.Clone().SelfSub(i),r=o.Normalize(),a=s.invMass1+s.invMass2;if(0===a)continue;const h=s.invMass1/a,l=s.invMass2/a;i.x-=t*h*(s.L-r)*o.x,i.y-=t*h*(s.L-r)*o.y,n.x+=t*l*(s.L-r)*o.x,n.y+=t*l*(s.L-r)*o.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n)}}SolveStretch_XPBD(t){for(let e=0;e<this.m_stretchCount;++e){const s=this.m_stretchConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=i.Clone().SelfSub(this.m_p0s[s.i1]),r=n.Clone().SelfSub(this.m_p0s[s.i2]),a=n.Clone().SelfSub(i),h=a.Normalize(),l=a.Clone().SelfNeg(),_=a,m=s.invMass1+s.invMass2;if(0===m)continue;const c=1/(s.spring*t*t),u=c*(t*t*s.damper)/t,d=h-s.L,f=Mt.DotVV(l,o)+Mt.DotVV(_,r),p=-(d+c*s.lambda+u*f)/((1+u)*m+c);i.x+=s.invMass1*p*l.x,i.y+=s.invMass1*p*l.y,n.x+=s.invMass2*p*_.x,n.y+=s.invMass2*p*_.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),s.lambda+=p}}SolveBend_PBD_Angle(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1],n=this.m_ps[s.i2],o=this.m_ps[s.i3],r=n.Clone().SelfSub(i),a=o.Clone().SelfSub(n),h=Mt.CrossVV(r,a),l=Mt.DotVV(r,a),_=Vt(h,l);let m=0,c=0;if(this.m_tuning.isometric?(m=s.L1*s.L1,c=s.L2*s.L2):(m=r.LengthSquared(),c=a.LengthSquared()),m*c==0)continue;const u=(new Mt).Copy(r).SelfSkew().SelfMul(-1/m),d=(new Mt).Copy(a).SelfSkew().SelfMul(1/c),f=u.Clone().SelfNeg(),p=u.Clone().SelfSub(d),y=d;let x=0;x=this.m_tuning.fixedEffectiveMass?s.invEffectiveMass:s.invMass1*Mt.DotVV(f,f)+s.invMass2*Mt.DotVV(p,p)+s.invMass3*Mt.DotVV(y,y),0===x&&(x=s.invEffectiveMass);const B=-t*_/x;i.x+=s.invMass1*B*f.x,i.y+=s.invMass1*B*f.y,n.x+=s.invMass2*B*p.x,n.y+=s.invMass2*B*p.y,o.x+=s.invMass3*B*y.x,o.y+=s.invMass3*B*y.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o)}}SolveBend_XPBD_Angle(t){for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1],n=this.m_ps[s.i2],o=this.m_ps[s.i3],r=i.Clone().SelfSub(this.m_p0s[s.i1]),a=n.Clone().SelfSub(this.m_p0s[s.i2]),h=o.Clone().SelfSub(this.m_p0s[s.i3]),l=n.Clone().SelfSub(i),_=o.Clone().SelfSub(n);let m,c;if(this.m_tuning.isometric?(m=s.L1*s.L1,c=s.L2*s.L2):(m=l.LengthSquared(),c=_.LengthSquared()),m*c==0)continue;const u=Mt.CrossVV(l,_),d=Mt.DotVV(l,_),f=Vt(u,d),p=(new Mt).Copy(l).SelfSkew().SelfMul(-1/m),y=(new Mt).Copy(_).SelfSkew().SelfMul(1/c),x=p.Clone().SelfNeg(),B=p.Clone().SelfSub(y),S=y;let A;if(A=this.m_tuning.fixedEffectiveMass?s.invEffectiveMass:s.invMass1*Mt.DotVV(x,x)+s.invMass2*Mt.DotVV(B,B)+s.invMass3*Mt.DotVV(S,S),0===A)continue;const C=1/(s.spring*t*t),V=C*(t*t*s.damper)/t,g=f,w=Mt.DotVV(x,r)+Mt.DotVV(B,a)+Mt.DotVV(S,h),v=-(g+C*s.lambda+V*w)/((1+V)*A+C);i.x+=s.invMass1*v*x.x,i.y+=s.invMass1*v*x.y,n.x+=s.invMass2*v*B.x,n.y+=s.invMass2*v*B.y,o.x+=s.invMass3*v*S.x,o.y+=s.invMass3*v*S.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o),s.lambda+=v}}SolveBend_PBD_Distance(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=s.i1,n=s.i3,o=this.m_ps[i].Clone(),r=this.m_ps[n].Clone(),a=r.Clone().SelfSub(o),h=a.Normalize(),l=s.invMass1+s.invMass3;if(0===l)continue;const _=s.invMass1/l,m=s.invMass3/l;o.x-=t*_*(s.L1+s.L2-h)*a.x,o.y-=t*_*(s.L1+s.L2-h)*a.y,r.x+=t*m*(s.L1+s.L2-h)*a.x,r.y+=t*m*(s.L1+s.L2-h)*a.y,this.m_ps[i].Copy(o),this.m_ps[n].Copy(r)}}SolveBend_PBD_Height(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=this.m_ps[s.i3].Clone(),r=new Mt;r.x=s.alpha1*i.x+s.alpha2*o.x-n.x,r.y=s.alpha1*i.y+s.alpha2*o.y-n.y;const a=r.Length();if(0===a)continue;const h=r.Clone().SelfMul(1/a),l=h.Clone().SelfMul(s.alpha1),_=h.Clone().SelfNeg(),m=h.Clone().SelfMul(s.alpha2),c=s.invMass1*s.alpha1*s.alpha1+s.invMass2+s.invMass3*s.alpha2*s.alpha2;if(0===c)continue;const u=-t*(1/c)*a;i.x+=s.invMass1*u*l.x,i.y+=s.invMass1*u*l.y,n.x+=s.invMass2*u*_.x,n.y+=s.invMass2*u*_.y,o.x+=s.invMass3*u*m.x,o.y+=s.invMass3*u*m.y,this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o)}}SolveBend_PBD_Triangle(){const t=this.m_tuning.bendStiffness;for(let e=0;e<this.m_bendCount;++e){const s=this.m_bendConstraints[e],i=this.m_ps[s.i1].Clone(),n=this.m_ps[s.i2].Clone(),o=this.m_ps[s.i3].Clone(),r=s.invMass1,a=s.invMass2,h=s.invMass3,l=t/(r+h+2*a),_=new Mt;_.x=n.x-1/3*(i.x+n.x+o.x),_.y=n.y-1/3*(i.y+n.y+o.y);const m=new Mt;m.x=2*r*l*_.x,m.y=2*r*l*_.y;const c=new Mt;c.x=-4*a*l*_.x,c.y=-4*a*l*_.y;const u=new Mt;u.x=2*h*l*_.x,u.y=2*h*l*_.y,i.SelfAdd(m),n.SelfAdd(c),o.SelfAdd(u),this.m_ps[s.i1].Copy(i),this.m_ps[s.i2].Copy(n),this.m_ps[s.i3].Copy(o)}}ApplyBendForces(t){const e=2*u*this.m_tuning.bendHertz;for(let s=0;s<this.m_bendCount;++s){const i=this.m_bendConstraints[s],n=this.m_ps[i.i1].Clone(),o=this.m_ps[i.i2].Clone(),r=this.m_ps[i.i3].Clone(),a=this.m_vs[i.i1],h=this.m_vs[i.i2],l=this.m_vs[i.i3],_=n.Clone().SelfSub(n),m=r.Clone().SelfSub(o);let c,u;if(this.m_tuning.isometric?(c=i.L1*i.L1,u=i.L2*i.L2):(c=_.LengthSquared(),u=m.LengthSquared()),c*u==0)continue;const d=Mt.CrossVV(_,m),f=Mt.DotVV(_,m),p=Vt(d,f),y=(new Mt).Copy(_).SelfSkew().SelfMul(-1/c),x=(new Mt).Copy(m).SelfSkew().SelfMul(1/u),B=y.Clone().SelfNeg(),S=y.Clone().SelfSub(x),A=x;let C=0;if(C=this.m_tuning.fixedEffectiveMass?i.invEffectiveMass:i.invMass1*Mt.DotVV(B,B)+i.invMass2*Mt.DotVV(S,S)+i.invMass3*Mt.DotVV(A,A),0===C)continue;const V=1/C,g=-t*(V*e*e*p+2*V*this.m_tuning.bendDamping*e*(Mt.DotVV(B,a)+Mt.DotVV(S,h)+Mt.DotVV(A,l)));this.m_vs[i.i1].x+=i.invMass1*g*B.x,this.m_vs[i.i1].y+=i.invMass1*g*B.y,this.m_vs[i.i2].x+=i.invMass2*g*S.x,this.m_vs[i.i2].y+=i.invMass2*g*S.y,this.m_vs[i.i3].x+=i.invMass3*g*A.x,this.m_vs[i.i3].y+=i.invMass3*g*A.y}}}class jo{constructor(t,e){this.prevBody=null,this.nextBody=null,this.prevController=null,this.nextController=null,this.controller=t,this.body=e}}class Jo{constructor(){this.m_bodyList=null,this.m_bodyCount=0,this.m_prev=null,this.m_next=null}GetNext(){return this.m_next}GetPrev(){return this.m_prev}GetBodyList(){return this.m_bodyList}AddBody(t){const e=new jo(this,t);e.nextBody=this.m_bodyList,e.prevBody=null,this.m_bodyList&&(this.m_bodyList.prevBody=e),this.m_bodyList=e,++this.m_bodyCount,e.nextController=t.m_controllerList,e.prevController=null,t.m_controllerList&&(t.m_controllerList.prevController=e),t.m_controllerList=e,++t.m_controllerCount}RemoveBody(t){if(this.m_bodyCount<=0)throw new Error;let e=this.m_bodyList;for(;e&&e.body!==t;)e=e.nextBody;if(null===e)throw new Error;e.prevBody&&(e.prevBody.nextBody=e.nextBody),e.nextBody&&(e.nextBody.prevBody=e.prevBody),this.m_bodyList===e&&(this.m_bodyList=e.nextBody),--this.m_bodyCount,e.nextController&&(e.nextController.prevController=e.prevController),e.prevController&&(e.prevController.nextController=e.nextController),t.m_controllerList===e&&(t.m_controllerList=e.nextController),--t.m_controllerCount}Clear(){for(;this.m_bodyList;)this.RemoveBody(this.m_bodyList.body);this.m_bodyCount=0}}class Xo extends Jo{constructor(){super(...arguments),this.normal=new Mt(0,1),this.offset=0,this.density=0,this.velocity=new Mt(0,0),this.linearDrag=0,this.angularDrag=0,this.useDensity=!1,this.useWorldGravity=!0,this.gravity=new Mt(0,0)}Step(t){if(this.m_bodyList){this.useWorldGravity&&this.gravity.Copy(this.m_bodyList.body.GetWorld().GetGravity());for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body;if(!e.IsAwake())continue;const s=new Mt,i=new Mt;let n=0,o=0;for(let t=e.GetFixtureList();t;t=t.m_next){const r=new Mt,a=t.GetShape().ComputeSubmergedArea(this.normal,this.offset,e.GetTransform(),r);n+=a,s.x+=a*r.x,s.y+=a*r.y;let h=0;h=this.useDensity?t.GetDensity():1,o+=a*h,i.x+=a*r.x*h,i.y+=a*r.y*h}if(s.x/=n,s.y/=n,i.x/=o,i.y/=o,n<m)continue;const r=this.gravity.Clone().SelfNeg();r.SelfMul(this.density*n),e.ApplyForce(r,i);const a=e.GetLinearVelocityFromWorldPoint(s,new Mt);a.SelfSub(this.velocity),a.SelfMul(-this.linearDrag*n),e.ApplyForce(a,s),e.ApplyTorque(-e.GetInertia()/e.GetMass()*n*e.GetAngularVelocity()*this.angularDrag)}}}Draw(t){const e=100,s=new Mt,i=new Mt;s.x=this.normal.x*this.offset+this.normal.y*e,s.y=this.normal.y*this.offset-this.normal.x*e,i.x=this.normal.x*this.offset-this.normal.y*e,i.y=this.normal.y*this.offset+this.normal.x*e;const o=new n(0,0,.8);t.DrawSegment(s,i,o)}}class Oo extends Jo{constructor(){super(...arguments),this.A=new Mt(0,0)}Step(t){const e=Mt.MulSV(t.dt,this.A,Oo.Step_s_dtA);for(let t=this.m_bodyList;t;t=t.nextBody){const s=t.body;s.IsAwake()&&s.SetLinearVelocity(Mt.AddVV(s.GetLinearVelocity(),e,Mt.s_t0))}}Draw(t){}}Oo.Step_s_dtA=new Mt;class Zo extends Jo{constructor(){super(...arguments),this.F=new Mt(0,0)}Step(t){for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body;e.IsAwake()&&e.ApplyForce(this.F,e.GetWorldCenter())}}Draw(t){}}class Uo extends Jo{constructor(){super(...arguments),this.G=1,this.invSqr=!0}Step(t){if(this.invSqr)for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body,s=e.GetWorldCenter(),i=e.GetMass();for(let n=this.m_bodyList;n&&n!==t;n=n.nextBody){const t=n.body,o=t.GetWorldCenter(),r=t.GetMass(),a=o.x-s.x,h=o.y-s.y,l=a*a+h*h;if(l<m)continue;const _=Uo.Step_s_f.Set(a,h);_.SelfMul(this.G/l/ft(l)*i*r),e.IsAwake()&&e.ApplyForce(_,s),t.IsAwake()&&t.ApplyForce(_.SelfMul(-1),o)}}else for(let t=this.m_bodyList;t;t=t.nextBody){const e=t.body,s=e.GetWorldCenter(),i=e.GetMass();for(let n=this.m_bodyList;n&&n!==t;n=n.nextBody){const t=n.body,o=t.GetWorldCenter(),r=t.GetMass(),a=o.x-s.x,h=o.y-s.y,l=a*a+h*h;if(l<m)continue;const _=Uo.Step_s_f.Set(a,h);_.SelfMul(this.G/l*i*r),e.IsAwake()&&e.ApplyForce(_,s),t.IsAwake()&&t.ApplyForce(_.SelfMul(-1),o)}}}Draw(t){}}Uo.Step_s_f=new Mt;class Wo extends Jo{constructor(){super(...arguments),this.T=new Dt,this.maxTimestep=0}Step(t){let e=t.dt;if(!(e<=m)){e>this.maxTimestep&&this.maxTimestep>0&&(e=this.maxTimestep);for(let t=this.m_bodyList;t;t=t.nextBody){const s=t.body;if(!s.IsAwake())continue;const i=s.GetWorldVector(Dt.MulMV(this.T,s.GetLocalVector(s.GetLinearVelocity(),Mt.s_t0),Mt.s_t1),Wo.Step_s_damping);s.SetLinearVelocity(Mt.AddVV(s.GetLinearVelocity(),Mt.MulSV(e,i,Mt.s_t0),Mt.s_t1))}}}Draw(t){}SetAxisAligned(t,e){this.T.ex.x=-t,this.T.ex.y=0,this.T.ey.x=0,this.T.ey.y=-e,this.maxTimestep=t>0||e>0?1/lt(t,e):0}}Wo.Step_s_damping=new Mt;const Qo=wi.b2_staticBody,Yo=wi.b2_kinematicBody,Ko=wi.b2_dynamicBody,Ho=Un.b2_springAngleBendingModel,$o=Un.b2_pbdAngleBendingModel,tr=Un.b2_xpbdAngleBendingModel,er=Un.b2_pbdDistanceBendingModel,sr=Un.b2_pbdHeightBendingModel,ir=Un.b2_pbdTriangleBendingModel,nr=Zn.b2_pbdStretchingModel,or=Zn.b2_xpbdStretchingModel}}]);